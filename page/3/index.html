<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="All In">
<meta property="og:type" content="website">
<meta property="og:title" content="Andrew&#39;s Blog">
<meta property="og:url" content="http://andrewpqc.github.io/page/3/index.html">
<meta property="og:site_name" content="Andrew&#39;s Blog">
<meta property="og:description" content="All In">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Andrew&#39;s Blog">
<meta name="twitter:description" content="All In">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://andrewpqc.github.io/page/3/">





  <title>Andrew's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Andrew's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Stay hungry, Stay foolish.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2018/04/24/setup-k8s-dashboard-on-cluster/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/24/setup-k8s-dashboard-on-cluster/" itemprop="url">为集群配置安装kubernetes-dashboard插件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-24T21:02:38+08:00">
                2018-04-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kubernetes/" itemprop="url" rel="index">
                    <span itemprop="name">Kubernetes</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>kubernetes-Dashboard是一个基于Web UI的kubernetes用户接口。你可以使用它在kubernetes集群中部署、调试容器化的应用，管理集群本身，创建、预览、更新集群中所拥有的资源对象，扩展和滚动更新你的应用。下面就来记录一下我是如何配置安装kuernetes-dashboard的。</p>
<p>kubernetes-dashboard 1.6.x以前和1.7.x的差距比较大，主要增加了一些https的认证。由于我们的集群的版本为1.7.5，下面打算安装kubernetes-dashboard V1.7.1,首先我们需要做的就是下载需要的镜像。</p>
<h1 id="镜像准备"><a href="#镜像准备" class="headerlink" title="镜像准备"></a>镜像准备</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -o errexit</span><br><span class="line"><span class="built_in">set</span> -o nounset</span><br><span class="line"><span class="built_in">set</span> -o pipefail</span><br><span class="line"></span><br><span class="line">GCR_URL=gcr.io/google_containers</span><br><span class="line">DOCKERHUB_URL=alleyj</span><br><span class="line"></span><br><span class="line">images=(kubernetes-dashboard-init-amd64:V1.0.1</span><br><span class="line">    kubernetes-dashboard-amd64:v1.7.1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> imageName <span class="keyword">in</span> <span class="variable">$&#123;images[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">  docker pull <span class="variable">$DOCKERHUB_URL</span>/<span class="variable">$imageName</span></span><br><span class="line">  docker tag <span class="variable">$DOCKERHUB_URL</span>/<span class="variable">$imageName</span> <span class="variable">$GCR_URL</span>/<span class="variable">$imageName</span></span><br><span class="line">  docker rmi <span class="variable">$DOCKERHUB_URL</span>/<span class="variable">$imageName</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h1 id="下载对应的yml文件"><a href="#下载对应的yml文件" class="headerlink" title="下载对应的yml文件"></a>下载对应的yml文件</h1><p>接下来我们需要一个kubernetes-dashboard.yaml的配置文件，可以直接在<a href="https://github.com/kubernetes/dashboard/tree/master/src/deploy/recommended" target="_blank" rel="noopener">dashboard的仓库中</a>的dashboard/src/deploy/recommended文件夹下下载。<strong>注意:由于我们这里安装的是kubernetes-dashboard V1.7.1,所以我们需要下载对应版本的kubernetes-dashboard.yaml文件。具体做法是，调整repository的tag至v1.7.1</strong>。查看文件的内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"># Copyright 2015 Google Inc. All Rights Reserved.</span><br><span class="line">#</span><br><span class="line"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line"># you may not use this file except in compliance with the License.</span><br><span class="line"># You may obtain a copy of the License at</span><br><span class="line">#</span><br><span class="line">#     http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line">#</span><br><span class="line"># Unless required by applicable law or agreed to in writing, software</span><br><span class="line"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"># See the License for the specific language governing permissions and</span><br><span class="line"># limitations under the License.</span><br><span class="line"></span><br><span class="line"># Configuration to deploy release version of the Dashboard UI compatible with</span><br><span class="line"># Kubernetes 1.7.</span><br><span class="line">#</span><br><span class="line"># Example usage: kubectl create -f &lt;this_file&gt;</span><br><span class="line"></span><br><span class="line"># ------------------- Dashboard Secret ------------------- #</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard-certs</span><br><span class="line">  namespace: kube-system</span><br><span class="line">type: Opaque</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"># ------------------- Dashboard Service Account ------------------- #</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kube-system</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"># ------------------- Dashboard Role &amp; Role Binding ------------------- #</span><br><span class="line"></span><br><span class="line">kind: Role</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">metadata:</span><br><span class="line">  name: kubernetes-dashboard-minimal</span><br><span class="line">  namespace: kube-system</span><br><span class="line">rules:</span><br><span class="line">  # Allow Dashboard to create and watch for changes of &apos;kubernetes-dashboard-key-holder&apos; secret.</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources: [&quot;secrets&quot;]</span><br><span class="line">  verbs: [&quot;create&quot;, &quot;watch&quot;]</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources: [&quot;secrets&quot;]</span><br><span class="line">  # Allow Dashboard to get, update and delete &apos;kubernetes-dashboard-key-holder&apos; secret.</span><br><span class="line">  resourceNames: [&quot;kubernetes-dashboard-key-holder&quot;, &quot;kubernetes-dashboard-certs&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;update&quot;, &quot;delete&quot;]</span><br><span class="line">  # Allow Dashboard to get metrics from heapster.</span><br><span class="line">- apiGroups: [&quot;&quot;]</span><br><span class="line">  resources: [&quot;services&quot;]</span><br><span class="line">  resourceNames: [&quot;heapster&quot;]</span><br><span class="line">  verbs: [&quot;proxy&quot;]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">kind: RoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: kubernetes-dashboard-minimal</span><br><span class="line">  namespace: kube-system</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: Role</span><br><span class="line">  name: kubernetes-dashboard-minimal</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kube-system</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"># ------------------- Dashboard Deployment ------------------- #</span><br><span class="line"></span><br><span class="line">kind: Deployment</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  revisionHistoryLimit: 10</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      k8s-app: kubernetes-dashboard</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        k8s-app: kubernetes-dashboard</span><br><span class="line">    spec:</span><br><span class="line">      initContainers:</span><br><span class="line">      - name: kubernetes-dashboard-init</span><br><span class="line">        image: gcr.io/google_containers/kubernetes-dashboard-init-amd64:v1.0.0</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: kubernetes-dashboard-certs</span><br><span class="line">          mountPath: /certs</span><br><span class="line">      containers:</span><br><span class="line">      - name: kubernetes-dashboard</span><br><span class="line">        image: gcr.io/google_containers/kubernetes-dashboard-amd64:v1.7.1</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 9090</span><br><span class="line">          protocol: TCP</span><br><span class="line">        args:</span><br><span class="line">          - --tls-key-file=/certs/dashboard.key</span><br><span class="line">          - --tls-cert-file=/certs/dashboard.crt</span><br><span class="line">          # Uncomment the following line to manually specify Kubernetes API server Host</span><br><span class="line">          # If not specified, Dashboard will attempt to auto discover the API server and connect</span><br><span class="line">          # to it. Uncomment only if the default does not work.</span><br><span class="line">          # - --apiserver-host=http://my-address:port</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: kubernetes-dashboard-certs</span><br><span class="line">          mountPath: /certs</span><br><span class="line">          readOnly: true</span><br><span class="line">          # Create on-disk volume to store exec logs</span><br><span class="line">        - mountPath: /tmp</span><br><span class="line">          name: tmp-volume</span><br><span class="line">        livenessProbe:</span><br><span class="line">          httpGet:</span><br><span class="line">            scheme: HTTPS</span><br><span class="line">            path: /</span><br><span class="line">            port: 8443</span><br><span class="line">          initialDelaySeconds: 30</span><br><span class="line">          timeoutSeconds: 30</span><br><span class="line">      volumes:</span><br><span class="line">      - name: kubernetes-dashboard-certs</span><br><span class="line">        secret:</span><br><span class="line">          secretName: kubernetes-dashboard-certs</span><br><span class="line">      - name: tmp-volume</span><br><span class="line">        emptyDir: &#123;&#125;</span><br><span class="line">      serviceAccountName: kubernetes-dashboard</span><br><span class="line">      # Comment the following tolerations if Dashboard must not be deployed on master</span><br><span class="line">      tolerations:</span><br><span class="line">      - key: node-role.kubernetes.io/master</span><br><span class="line">        effect: NoSchedule</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"># ------------------- Dashboard Service ------------------- #</span><br><span class="line"></span><br><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kube-system</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - port: 443</span><br><span class="line">      targetPort: 8443</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br></pre></td></tr></table></figure>

<p>查看上述的文件，可以看到这里需要的两个镜像都已经存在于本地，但是略有不同的是这里需要的<code>kubernetes-dashboard-init-amd64:v1.0.0</code>，而我们本地有的镜像tag为<code>v1.0.1</code>,所以我们这里更改一下这个yml文件，将<code>kubernetes-dashboard-init-amd64的tag</code>从<code>v1.0.0</code>改为<code>v1.0.1</code>.</p>
<h1 id="创建相应的资源"><a href="#创建相应的资源" class="headerlink" title="创建相应的资源"></a>创建相应的资源</h1><h2 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kc create -f kubernetes-dashboard.yml</span><br></pre></td></tr></table></figure>

<p>查看kube-system中，kubernetes-dashboard所对应的pod的状态一直是这样的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                                              READY     STATUS     RESTARTS   AGE</span><br><span class="line">kubernetes-dashboard-3554419144-j2qqp             0/1       Init:0/1   0          3m</span><br></pre></td></tr></table></figure>

<p>我们discribe一下这个pod</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe pod kubernetes-dashboard-3554419144-j2qqp -n kube-system</span><br></pre></td></tr></table></figure>

<p>输出的Event如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Events:</span><br><span class="line">  FirstSeen	LastSeen	Count	From					SubObjectPath					Type		Reason			Message</span><br><span class="line">  ---------	--------	-----	----					-------------					--------	------			-------</span><br><span class="line">  29s		29s		1	default-scheduler									Normal		Scheduled		Successfully assigned kubernetes-dashboard-3554419144-j2qqp to izwz9f6pgul78p7die5tlzz</span><br><span class="line">  29s		29s		1	kubelet, izwz9f6pgul78p7die5tlzz							Normal		SuccessfulMountVolume	MountVolume.SetUp succeeded <span class="keyword">for</span> volume <span class="string">"tmp-volume"</span> </span><br><span class="line">  29s		29s		1	kubelet, izwz9f6pgul78p7die5tlzz							Normal		SuccessfulMountVolume	MountVolume.SetUp succeeded <span class="keyword">for</span> volume <span class="string">"kubernetes-dashboard-certs"</span> </span><br><span class="line">  29s		29s		1	kubelet, izwz9f6pgul78p7die5tlzz							Normal		SuccessfulMountVolume	MountVolume.SetUp succeeded <span class="keyword">for</span> volume <span class="string">"kubernetes-dashboard-token-5mhr7"</span> </span><br><span class="line">  28s		28s		1	kubelet, izwz9f6pgul78p7die5tlzz	spec.initContainers&#123;kubernetes-dashboard-init&#125;	Normal		Pulled			Container image <span class="string">"gcr.io/google_containers/kubernetes-dashboard-init-amd64:v1.0.1"</span> already present on machine</span><br><span class="line">  28s		28s		1	kubelet, izwz9f6pgul78p7die5tlzz	spec.initContainers&#123;kubernetes-dashboard-init&#125;	Normal		Created			Created container</span><br><span class="line">  28s		28s		1	kubelet, izwz9f6pgul78p7die5tlzz	spec.initContainers&#123;kubernetes-dashboard-init&#125;	Normal		Started			Started container</span><br><span class="line">  27s		8s		3	kubelet, izwz9f6pgul78p7die5tlzz	spec.containers&#123;kubernetes-dashboard&#125;		Normal		Pulled			Container image <span class="string">"gcr.io/google_containers/kubernetes-dashboard-amd64:v1.7.1"</span> already present on machine</span><br><span class="line">  27s		8s		3	kubelet, izwz9f6pgul78p7die5tlzz	spec.containers&#123;kubernetes-dashboard&#125;		Normal		Created			Created container</span><br><span class="line">  26s		7s		3	kubelet, izwz9f6pgul78p7die5tlzz	spec.containers&#123;kubernetes-dashboard&#125;		Normal		Started			Started container</span><br><span class="line">  25s		4s		5	kubelet, izwz9f6pgul78p7die5tlzz	spec.containers&#123;kubernetes-dashboard&#125;		Warning		BackOff			Back-off restarting failed container</span><br></pre></td></tr></table></figure>

<p>可以看到，initContainer kubernetes-dashboard-init容器全运行正常，kubernetes-dashboard容器运行失败。</p>
<p>接着我们来查看一下logs:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl logs kubernetes-dashboard-3554419144-j2qqp -n kube-system</span><br></pre></td></tr></table></figure>

<p>输出如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2018/04/24 14:41:19 Using in-cluster config to connect to apiserver</span><br><span class="line">2018/04/24 14:41:19 Using service account token for csrf signing</span><br><span class="line">2018/04/24 14:41:19 No request provided. Skipping authorization</span><br><span class="line">2018/04/24 14:41:19 Starting overwatch</span><br><span class="line">2018/04/24 14:41:19 Successful initial request to the apiserver, version: v1.7.5</span><br><span class="line">2018/04/24 14:41:19 New synchronizer has been registered: kubernetes-dashboard-key-holder-kube-system. Starting</span><br><span class="line">2018/04/24 14:41:19 Starting secret synchronizer for kubernetes-dashboard-key-holder in namespace kube-system</span><br><span class="line">2018/04/24 14:41:19 Initializing secret synchronizer synchronously using secret kubernetes-dashboard-key-holder from namespace kube-system</span><br><span class="line">2018/04/24 14:41:19 Initializing JWE encryption key from synchronized object</span><br><span class="line">2018/04/24 14:41:19 Creating in-cluster Heapster client</span><br><span class="line">2018/04/24 14:41:19 Serving securely on HTTPS port: 8443</span><br><span class="line">2018/04/24 14:41:19 open /certs/dashboard.crt: no such file or directory</span><br></pre></td></tr></table></figure>

<p>可以看到，这里说没有<code>/certs/dashboard.crt</code>文件，这个证书文件本应该是在运行init容器时创建的，但是这里不知道为什么我们这里没有创建成功。</p>
<p>下面，我们删除刚才由<code>kubernetes-dashboard.yml</code>文件所创建的资源，然后采取openssl来创建自签名证书。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete -f kubenetes-dashboard.yml</span><br></pre></td></tr></table></figure>

<h2 id="再次尝试"><a href="#再次尝试" class="headerlink" title="再次尝试"></a>再次尝试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ openssl req -newkey rsa:4096 -nodes -sha256 -keyout dashboard.key -x509 -days 365 -out dashboard.crt</span><br></pre></td></tr></table></figure>

<p>依据提示，填写签发者信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Generating a 4096 bit RSA private key</span><br><span class="line">......................++</span><br><span class="line">....................................................................................................++</span><br><span class="line">writing new private key to &apos;dashboard.key&apos;</span><br><span class="line">-----</span><br><span class="line">You are about to be asked to enter information that will be incorporated</span><br><span class="line">into your certificate request.</span><br><span class="line">What you are about to enter is what is called a Distinguished Name or a DN.</span><br><span class="line">There are quite a few fields but you can leave some blank</span><br><span class="line">For some fields there will be a default value,</span><br><span class="line">If you enter &apos;.&apos;, the field will be left blank.</span><br><span class="line">-----</span><br><span class="line">Country Name (2 letter code) [XX]:CN</span><br><span class="line">State or Province Name (full name) []:Hubei  </span><br><span class="line">Locality Name (eg, city) [Default City]:Wuhan</span><br><span class="line">Organization Name (eg, company) [Default Company Ltd]:Muxistudio</span><br><span class="line">Organizational Unit Name (eg, section) []:be</span><br><span class="line">Common Name (eg, your name or your server&apos;s hostname) []:iZwz9f6pgul78p7die5tlzZ</span><br><span class="line">Email Address []:3480437308@qq.com</span><br></pre></td></tr></table></figure>

<p>执行完之后，你的命令执行目录就会多出来两个文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ll</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--. 1 root root 2086 Nov 14 09:59 dashboard.crt</span><br><span class="line">-rw-r--r--. 1 root root 3272 Nov 14 09:59 dashboard.key</span><br></pre></td></tr></table></figure>

<p>将这两个文件移动到<code>/certs/</code>目录之下，然后根据这两个文件使用下面的命令来创建secret,来替换掉kubernetes-dashboard.yml中定义的secret：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create secret generic kubernetes-dashboard-certs --from-file=/certs -n kube-system</span><br></pre></td></tr></table></figure>

<p>下面，我们再次依据<code>kubernetes-dashboard.yml</code>来创建dashboard所需要的资源对象:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f kubernetes-dashboard.yml</span><br></pre></td></tr></table></figure>

<p>输出如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">serviceaccount &quot;kubernetes-dashboard&quot; created</span><br><span class="line">role &quot;kubernetes-dashboard-minimal&quot; created</span><br><span class="line">rolebinding &quot;kubernetes-dashboard-minimal&quot; created</span><br><span class="line">deployment &quot;kubernetes-dashboard&quot; created</span><br><span class="line">service &quot;kubernetes-dashboard&quot; created</span><br><span class="line">Error from server (AlreadyExists): error when creating &quot;dashboard.yml&quot;: secrets &quot;kubernetes-dashboard-certs&quot; already exists</span><br></pre></td></tr></table></figure>

<p>从输出也可以看出来，其他资源已经创建成功，而<code>kubernetes-dashboard-certs</code>则被我们成功替换掉了。</p>
<p>下面，我们查看一下dashboard对应的pod的事件:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe pod kubernetes-dashboard-3554419144-jjj5q -n kube-system</span><br></pre></td></tr></table></figure>

<p>事件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Events:</span><br><span class="line">  FirstSeen	LastSeen	Count	From					SubObjectPath					Type		Reason			Message</span><br><span class="line">  ---------	--------	-----	----					-------------					--------	------			-------</span><br><span class="line">  3m		3m		1	default-scheduler									Normal		Scheduled		Successfully assigned kubernetes-dashboard-3554419144-jjj5q to izwz9f6pgul78p7die5tlzz</span><br><span class="line">  3m		3m		1	kubelet, izwz9f6pgul78p7die5tlzz							Normal		SuccessfulMountVolume	MountVolume.SetUp succeeded for volume &quot;tmp-volume&quot; </span><br><span class="line">  3m		3m		1	kubelet, izwz9f6pgul78p7die5tlzz							Normal		SuccessfulMountVolume	MountVolume.SetUp succeeded for volume &quot;kubernetes-dashboard-token-jzx4v&quot; </span><br><span class="line">  3m		3m		1	kubelet, izwz9f6pgul78p7die5tlzz							Normal		SuccessfulMountVolume	MountVolume.SetUp succeeded for volume &quot;kubernetes-dashboard-certs&quot; </span><br><span class="line">  3m		3m		1	kubelet, izwz9f6pgul78p7die5tlzz	spec.initContainers&#123;kubernetes-dashboard-init&#125;	Normal		Pulled			Container image &quot;gcr.io/google_containers/kubernetes-dashboard-init-amd64:v1.0.1&quot; already present on machine</span><br><span class="line">  3m		3m		1	kubelet, izwz9f6pgul78p7die5tlzz	spec.initContainers&#123;kubernetes-dashboard-init&#125;	Normal		Created			Created container</span><br><span class="line">  3m		3m		1	kubelet, izwz9f6pgul78p7die5tlzz	spec.initContainers&#123;kubernetes-dashboard-init&#125;	Normal		Started			Started container</span><br><span class="line">  3m		3m		1	kubelet, izwz9f6pgul78p7die5tlzz	spec.containers&#123;kubernetes-dashboard&#125;		Normal		Pulled			Container image &quot;gcr.io/google_containers/kubernetes-dashboard-amd64:v1.7.1&quot; already present on machine</span><br><span class="line">  3m		3m		1	kubelet, izwz9f6pgul78p7die5tlzz	spec.containers&#123;kubernetes-dashboard&#125;		Normal		Created			Created container</span><br><span class="line">  3m		3m		1	kubelet, izwz9f6pgul78p7die5tlzz	spec.containers&#123;kubernetes-dashboard&#125;		Normal		Started			Started container</span><br></pre></td></tr></table></figure>

<p>如上，一切正常。我们的kubernetes-dashboard插件就此安装完成。</p>
<h1 id="暴露服务"><a href="#暴露服务" class="headerlink" title="暴露服务"></a>暴露服务</h1><p>下面，我们要访问服务器上的<code>kubernetes-dashboard</code>服务就还需要做下面的一步操作：将kubernetes-dashboard的service变为外部可路由。将service的类型由默认的ClusterIP改为NodePort.<br>执行下面的命令，更改service的配置文件:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl edit service kubernetes-dashboard -n kube-system</span><br></pre></td></tr></table></figure>

<p>更改完成之后，我们查看服务的暴露的主机端口:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get service kubernetes-dashboard -n kube-system</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                   CLUSTER-IP       EXTERNAL-IP   PORT(S)         AGE</span><br><span class="line">kubernetes-dashboard   10.109.219.222   &lt;nodes&gt;       443:30087/TCP   52m</span><br></pre></td></tr></table></figure>

<p>如上，服务暴露的主机端口为30087,我们访问<code>https://&lt;主机公网IP&gt;:30087/</code>即可访问到dashboard服务。注意，<strong>这里使用的是HTTPS服务，并且使用的是自签名证书，所以在我们初次进入时，浏览器会因为无法识别证书的签署机构而阻止继续访问，这时我们只需要点击高级选项，标识网站为安全即可。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2018/04/23/setup-kubernetes-cluster-with-kubeadm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/23/setup-kubernetes-cluster-with-kubeadm/" itemprop="url">用Kubeadm搭建一个k8s 1.7.5的单节点集群</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-23T22:09:21+08:00">
                2018-04-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kubernetes/" itemprop="url" rel="index">
                    <span itemprop="name">Kubernetes</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.muxixyz.com" target="_blank" rel="noopener">团队</a>近期打算自己开发一个基于kubernetes的应用部署、监控、维护、管理的云平台MAE(Muxi APP Engine)，思路来自于赵老板的一篇<a href="http://zxc0328.github.io/2017/05/27/mae/#more" target="_blank" rel="noopener">博客</a>。可以让用户直接在可视化的环境下完成应用的部署、集群维护的一个服务。开发首先得需要一个kubernetes集群，这几天一直在弄kubernetes的东西。今天就先总结一下集群搭建的基本过程，记录一下搭建过程中遇到的坑，希望能够给后来者以参考。</p>
<h1 id="基本环境"><a href="#基本环境" class="headerlink" title="基本环境"></a>基本环境</h1><p>由于是学生团队，搭建过程基于的环境比较简陋：</p>
<ul>
<li>阿里云学生机一台，CentOS 7.4 ,64位的操作系统</li>
<li>CPU:1核</li>
<li>内存：2G</li>
<li>带宽：1Mbps</li>
</ul>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><h2 id="节点命名"><a href="#节点命名" class="headerlink" title="节点命名"></a>节点命名</h2><p>阿里云的机器的hostname默认都是一长串由字母和数字组成的字符串，没有什么规律。为了便于以后的管理，我们可以使用<a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/networking_guide/sec_configuring_host_names_using_hostnamectl" target="_blank" rel="noopener">hostnamectl命令</a>来给我们的节点取一个具有语义性的名字。具体操作,在root用户下运行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hostnamectl <span class="built_in">set</span>-hostname <span class="string">"k8s-master"</span></span><br></pre></td></tr></table></figure>

<p>因为我们这里只有一台主机，所以就给它命名成k8s-master.</p>
<h2 id="禁用防火墙"><a href="#禁用防火墙" class="headerlink" title="禁用防火墙"></a>禁用防火墙</h2><p>如果各个主机启用了防火墙，需要开放Kubernetes各个组件所需要的端口，可以查看Installing kubeadm中的<a href="https://kubernetes.io/docs/setup/independent/install-kubeadm/#check-required-ports" target="_blank" rel="noopener">Check required ports</a>一节。 这里简单起见在各节点禁用防火墙：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop firewalld</span><br><span class="line">$ systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure>

<p>创建/etc/sysctl.d/k8s.conf文件，添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br></pre></td></tr></table></figure>

<p>执行<code>sysctl -p /etc/sysctl.d/k8s.conf</code>使修改生效。</p>
<h2 id="禁用SELINUX"><a href="#禁用SELINUX" class="headerlink" title="禁用SELINUX"></a>禁用SELINUX</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ setenforce 0</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/selinux/config</span><br></pre></td></tr></table></figure>

<p>修改成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure>

<p>修改<code>/etc/selinux/config</code>文件的过程也可以直接这样:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -i <span class="string">'s/SELINUX=enforcing/SELINUX=disabled/g'</span> /etc/selinux/config</span><br></pre></td></tr></table></figure>

<h2 id="关闭系统的Swap"><a href="#关闭系统的Swap" class="headerlink" title="关闭系统的Swap"></a>关闭系统的Swap</h2><p>Kubernetes 1.8开始要求关闭系统的Swap。如果不关闭，默认配置下kubelet将无法启动。可以通过kubelet的启动参数<code>--fail-swap-on=false</code>更改这个限制。 我们这里关闭系统的Swap:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ swapoff -a</span><br></pre></td></tr></table></figure>

<p>修改<code>/etc/fstab</code>文件，注释掉<code>SWAP</code>的自动挂载，使用<code>free -m</code>确认swap已经关闭。<br><code>swappiness</code>参数调整，修改/etc/sysctl.d/k8s.conf添加下面一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.swappiness=0</span><br></pre></td></tr></table></figure>

<p>执行sysctl -p /etc/sysctl.d/k8s.conf使修改生效。</p>
<h1 id="安装并配置docker"><a href="#安装并配置docker" class="headerlink" title="安装并配置docker"></a>安装并配置docker</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>docker属于kubernetes的基础设施,一般来说docker 1.12是比较稳定的，我们要在阿里云学生机上下载docker需要先添加docker的镜像源，像下面这样:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt;/etc/yum.repos.d/docker.repo &lt;&lt;EOF</span><br><span class="line">[dockerrepo]</span><br><span class="line">name=Docker Repository</span><br><span class="line">baseurl=https://yum.dockerproject.org/repo/main/centos/7</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://yum.dockerproject.org/gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>然后通过下面的命令将服务器上的软件包信息先在本地缓存,以提高搜索安装软件的速度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum makecache</span><br></pre></td></tr></table></figure>

<p>现在你可以通过下面的命令来查看你新添加的软件源中可以安装的docker的版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum list docker-engine showduplicates</span><br></pre></td></tr></table></figure>

<p>这里我们选择安装docker 1.12.6</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install docker-engine-1.12.6-1.el7.centos.x86_64</span><br></pre></td></tr></table></figure>

<p>启动docker:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl <span class="built_in">enable</span> docker</span><br><span class="line">$ systemctl start docker</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>下面我们需要到<code>docker　hub</code>镜像仓库中拉取镜像，为了加快拉取镜像的速度，我们在这里给<code>docker</code>配置一下加速器。国内的阿里云、daoclode、时速云等均有免费的docker加速器提供，大家可以自行google。这里我采用阿里云的镜像加速服务。因为在下面的kubeadm初始化master节点的时候，需要保证docker的<code>cgroup driver</code>类型与<code>kubelet</code>启动时使用的<code>cgroup driver</code>一致(<code>cgroupfs</code>或者<code>systemd</code>),所以这里也一并展示一下配置docker的<code>cgroup driver</code>的方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/docker</span><br><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://sw9esv3f.mirror.aliyuncs.com"</span>]，</span><br><span class="line">  <span class="string">"exec-opts"</span>: [<span class="string">"native.cgroupdriver=systemd"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>因为修改了配置文件，所以这里需要重启一下docker.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h1 id="安装k8s相关镜像及组件"><a href="#安装k8s相关镜像及组件" class="headerlink" title="安装k8s相关镜像及组件"></a>安装k8s相关镜像及组件</h1><p>k8s集群分为master节点和node节点，master节点主要用于对于集群进行管理。k8s安装一般有两种安装方式，第一种为官方提供的工具kubeadm安装，第二种为二进制文件安装，此处主要介绍第一种</p>
<h2 id="相关镜像下载"><a href="#相关镜像下载" class="headerlink" title="相关镜像下载"></a>相关镜像下载</h2><p>由于使用kubeadm在安装的过程中会使用一些谷歌开源的镜像，但是国内无法访问到gcr.io，所以一般情况下我们需要翻墙拉取镜像，但是有以下前辈已经拉取到我们所需的镜像，并且传到了dockerhub上，我们可以直接使用这上面的镜像。并且刚才配置了加速器，所以拉取的速度也是很快的。这里就推荐两个docker hub上的仓库:<a href="https://hub.docker.com/search/?isAutomated=0&isOfficial=0&page=1&pullCount=0&q=alleyj&starCount=0" target="_blank" rel="noopener">alleyj</a>,<a href="https://hub.docker.com/u/mirrorgooglecontainers/" target="_blank" rel="noopener">mirrorgooglecontainers</a><br>这里以alleyj的仓库为例，先需要从这个仓库里pull我们需要的镜像，然后使用<code>docker tag</code>命令将镜像的前缀改为<code>gcr.io/google_containers</code>,最后使用<code>docker rmi</code>去掉之前的镜像记录。可以使用如下脚本完成以上操作:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -o errexit</span><br><span class="line"><span class="built_in">set</span> -o nounset</span><br><span class="line"><span class="built_in">set</span> -o pipefail</span><br><span class="line"></span><br><span class="line">KUBE_VERSION=v1.7.5</span><br><span class="line">KUBE_PAUSE_VERSION=3.0</span><br><span class="line">ETCD_VERSION=3.0.17</span><br><span class="line">DNS_VERSION=1.14.4</span><br><span class="line"></span><br><span class="line">GCR_URL=gcr.io/google_containers</span><br><span class="line">DOCKERHUB_URL=alleyj</span><br><span class="line"></span><br><span class="line">images=(kube-proxy-amd64:<span class="variable">$&#123;KUBE_VERSION&#125;</span></span><br><span class="line">kube-scheduler-amd64:<span class="variable">$&#123;KUBE_VERSION&#125;</span></span><br><span class="line">kube-controller-manager-amd64:<span class="variable">$&#123;KUBE_VERSION&#125;</span></span><br><span class="line">kube-apiserver-amd64:<span class="variable">$&#123;KUBE_VERSION&#125;</span></span><br><span class="line">pause-amd64:<span class="variable">$&#123;KUBE_PAUSE_VERSION&#125;</span></span><br><span class="line">etcd-amd64:<span class="variable">$&#123;ETCD_VERSION&#125;</span></span><br><span class="line">k8s-dns-sidecar-amd64:<span class="variable">$&#123;DNS_VERSION&#125;</span></span><br><span class="line">k8s-dns-kube-dns-amd64:<span class="variable">$&#123;DNS_VERSION&#125;</span></span><br><span class="line">k8s-dns-dnsmasq-nanny-amd64:<span class="variable">$&#123;DNS_VERSION&#125;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> imageName <span class="keyword">in</span> <span class="variable">$&#123;images[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">  docker pull <span class="variable">$DOCKERHUB_URL</span>/<span class="variable">$imageName</span></span><br><span class="line">  docker tag <span class="variable">$DOCKERHUB_URL</span>/<span class="variable">$imageName</span> <span class="variable">$GCR_URL</span>/<span class="variable">$imageName</span></span><br><span class="line">  docker rmi <span class="variable">$DOCKERHUB_URL</span>/<span class="variable">$imageName</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>kubernetes各个版本所需要的镜像版本可以参见－&gt;<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-init/#running-kubeadm-without-an-internet-connection" target="_blank" rel="noopener">这里</a></p>
<h2 id="组件下载"><a href="#组件下载" class="headerlink" title="组件下载"></a>组件下载</h2><p>这里我们还需要下载的组件是<code>kubelet</code>,<code>kubectl</code>,<code>kubeadm</code>,<code>kubernetes-cni</code>。首先添加yum源:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt;EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>然后可以通过下面的命令来查看该镜像源中可以安装的对应组件的版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ yum list kubeadm showduplicates</span><br><span class="line">$ yum list kubelet showduplicates</span><br><span class="line">$ yum list kubectl showduplicates</span><br><span class="line">$ yum list kubernetes-cni showduplicates</span><br></pre></td></tr></table></figure>

<p>这里，我们选择下面的版本安装.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install -y kubernetes-cni-0.5.1-0.x86_64 </span><br><span class="line">yum install -y kubelet-1.7.5-0.x86_64 </span><br><span class="line">yum install -y kubectl-1.7.5-0.x86_64 </span><br><span class="line">yum install -y kubeadm-1.7.5-0.x86_64</span><br></pre></td></tr></table></figure>

<p>启动kubelet.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure>

<h2 id="配置kubelet"><a href="#配置kubelet" class="headerlink" title="配置kubelet"></a>配置kubelet</h2><p>kubelet负责在节点上启动，终止，重启容器。我们需要对其进行响应的配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/systemd/system/kubelet.service.d/20-pod-infra-image.conf &lt;&lt;EOF</span><br><span class="line">[Service]</span><br><span class="line">Environment=<span class="string">"KUBELET_EXTRA_ARGS=--pod-infra-container-image=gcr.io/google_containers/pause-amd64:3.0"</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>上面配置的是kubelet的启动参数，指定了pause容器镜像。这个pause容器在pod中担任Linux命名空间共享的基础,启用pid命名空间，开启init进程。更多关于pause容器的内容，可以看－&gt;<a href="https://jimmysong.io/posts/what-is-a-pause-container/" target="_blank" rel="noopener">这里</a><br>在kubeadm初始化master节点的过程中，我们还需要设置两个环境变量:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> KUBE_REPO_PREFIX=<span class="string">"gcr.io/google_containers"</span></span><br><span class="line"><span class="built_in">export</span> KUBE_ETCD_IMAGE=<span class="string">"gcr.io/google_containers/etcd-amd64:3.0.17"</span></span><br></pre></td></tr></table></figure>

<p>这两个环境变量指定了kubernetes所需的系统镜像的前缀，和etcd镜像的完整名称。由于这些镜像现在都以gcr.io/google_containers为前缀存在于本地，所以不用考虑说以gcr.io/google_containers为前缀拉取不到镜像的问题。</p>
<p>配置完毕，我们重新启动kubelet:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure>

<h1 id="kubeadm初始化master节点"><a href="#kubeadm初始化master节点" class="headerlink" title="kubeadm初始化master节点"></a>kubeadm初始化master节点</h1><p>到目前为止，我们搭建单节点集群所需要的所有软件，镜像全部安装完毕。下面我们就是要使用kubeadm来初始化集群。这个地方就开始遇到各种坑了。首先，在<code>kubeadm init</code>之前我们需要<strong>保证本机的<code>docker</code>和<code>kubelet</code>服务都处于运行状态</strong>.所以我们先来确认一下这两个服务是否都跑起来了:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl status docker</span><br><span class="line">$ systemctl status kubelet</span><br></pre></td></tr></table></figure>

<p>如果你在运行上面的两个命令后看到的都是绿色，那么很幸运，你跳过了这个坑。不幸的是，笔者的kubelet一直无法跑起来。<code>systemctl status kubelet</code>的输出如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">● kubelet.service - kubelet: The Kubernetes Node Agent</span><br><span class="line">   Loaded: loaded (/etc/systemd/system/kubelet.service; enabled; vendor preset: disabled)</span><br><span class="line">  Drop-In: /etc/systemd/system/kubelet.service.d</span><br><span class="line">           └─10-kubeadm.conf, 20-pod-infra-image.conf</span><br><span class="line">   Active: activating (auto-restart) (Result: exit-code) since 日 2018-04-22 10:26:38 CST; 1s ago</span><br><span class="line">     Docs: http://kubernetes.io/docs/</span><br><span class="line">  Process: 21169 ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_SYSTEM_PODS_ARGS $KUBELET_NETWORK_ARGS $KUBELET_DNS_ARGS $KUBELET_AUTHZ_ARGS $KUBELET_CADVISOR_ARGS $KUBELET_CGROUP_ARGS $KUBELET_EXTRA_ARGS (code=exited, status=255)</span><br><span class="line"> Main PID: 21169 (code=exited, status=255)</span><br><span class="line"></span><br><span class="line">4月 22 10:26:38 iZwz9f6pgul78p7die5tlzZ kubelet[21169]: --seccomp-profile-root string                         &lt;Warning: Alpha feature&gt; ...comp&quot;)</span><br><span class="line">4月 22 10:26:38 iZwz9f6pgul78p7die5tlzZ kubelet[21169]: --stderrthreshold severity                            logs at or above this thr...ult 2)</span><br><span class="line">4月 22 10:26:38 iZwz9f6pgul78p7die5tlzZ kubelet[21169]: -v, --v Level                                             log level for V logs</span><br><span class="line">4月 22 10:26:38 iZwz9f6pgul78p7die5tlzZ kubelet[21169]: --version version[=true]                              Print version information and quit</span><br><span class="line">4月 22 10:26:38 iZwz9f6pgul78p7die5tlzZ kubelet[21169]: --vmodule moduleSpec                                  comma-separated list of p...ogging</span><br><span class="line">4月 22 10:26:38 iZwz9f6pgul78p7die5tlzZ systemd[1]: kubelet.service: main process exited, code=exited, status=255/n/a</span><br><span class="line">4月 22 10:26:38 iZwz9f6pgul78p7die5tlzZ kubelet[21169]: --volume-plugin-dir string                            The full path of the dire...xec/&quot;)</span><br><span class="line">4月 22 10:26:38 iZwz9f6pgul78p7die5tlzZ kubelet[21169]: F0422 10:26:38.470722   21169 server.go:145] unknown flag: --require-kubeconfig</span><br><span class="line">4月 22 10:26:38 iZwz9f6pgul78p7die5tlzZ systemd[1]: Unit kubelet.service entered failed state.</span><br><span class="line">4月 22 10:26:38 iZwz9f6pgul78p7die5tlzZ systemd[1]: kubelet.service failed.</span><br></pre></td></tr></table></figure>

<p>其实，现在看来这个地方也不叫做坑，上面的输出倒数第3行已经说的很清楚了<code>unknown flag: --require-kubeconfig</code>。这说明kubelet的启动参数中出现了一个它不认的flag.(笔者装的时候一直在查看kubelet的状态，就是没有好好看log，导致这里花费了许多时间。这说明仔细看log真的很重要!!!)。下面我们就去看看kubelet启动参数的配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/systemd/system/kubelet.service.d/10-kubeadm.conf</span><br></pre></td></tr></table></figure>

<p>文件内容如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=&quot;KUBELET_KUBECONFIG_ARGS=--kubeconfig=/etc/kubernetes/kubelet.conf --require-kubeconfig=true&quot;</span><br><span class="line">Environment=&quot;KUBELET_SYSTEM_PODS_ARGS=--pod-manifest-path=/etc/kubernetes/manifests --allow-privileged=true&quot;</span><br><span class="line">Environment=&quot;KUBELET_NETWORK_ARGS=--network-plugin=cni --cni-conf-dir=/etc/cni/net.d --cni-bin-dir=/opt/cni/bin&quot;</span><br><span class="line">Environment=&quot;KUBELET_DNS_ARGS=--cluster-dns=10.96.0.10 --cluster-domain=cluster.local&quot;</span><br><span class="line">Environment=&quot;KUBELET_AUTHZ_ARGS=--authorization-mode=Webhook --client-ca-file=/etc/kubernetes/pki/ca.crt&quot;</span><br><span class="line">Environment=&quot;KUBELET_CADVISOR_ARGS=--cadvisor-port=0&quot;</span><br><span class="line">Environment=&quot;KUBELET_CGROUP_ARGS=--cgroup-driver=systemd&quot;</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_SYSTEM_PODS_ARGS $KUBELET_NETWORK_ARGS $KUBELET_DNS_ARGS $KUBELET_AUTHZ_ARGS $KUBELET_CADVISOR_ARGS $KUBELET_CGROUP_ARGS $KUBELET_EXTRA_ARGS</span><br></pre></td></tr></table></figure>

<p>果真，在KUBELET_KUBECONFIG_ARGS中有一个参数<code>--require-kubeconfig=true</code>，去掉即可。<br>下面重新启动kubelet:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure>

<p>查看kubelet的状态，发现kubelet仍然没有运行起来:&lt;(<br>下面查看一下系统log,看看究竟发生了啥：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail -n 10 /var/<span class="built_in">log</span>/messages</span><br></pre></td></tr></table></figure>

<p>输出如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Apr 22 10:46:38 iZwz9f6pgul78p7die5tlzZ kubelet: Flag --authorization-mode has been deprecated, This parameter should be <span class="built_in">set</span> via the config file specified by the Kubelet<span class="string">'s --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.</span></span><br><span class="line"><span class="string">Apr 22 10:46:38 iZwz9f6pgul78p7die5tlzZ kubelet: Flag --client-ca-file has been deprecated, This parameter should be set via the config file specified by the Kubelet'</span>s --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ <span class="keyword">for</span> more information.</span><br><span class="line">Apr 22 10:46:38 iZwz9f6pgul78p7die5tlzZ kubelet: Flag --cadvisor-port has been deprecated, The default will change to 0 (disabled) <span class="keyword">in</span> 1.12, and the cadvisor port will be removed entirely <span class="keyword">in</span> 1.13</span><br><span class="line">Apr 22 10:46:38 iZwz9f6pgul78p7die5tlzZ kubelet: Flag --cgroup-driver has been deprecated, This parameter should be <span class="built_in">set</span> via the config file specified by the Kubelet<span class="string">'s --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ for more information.</span></span><br><span class="line"><span class="string">Apr 22 10:46:38 iZwz9f6pgul78p7die5tlzZ kubelet: Flag --fail-swap-on has been deprecated, This parameter should be set via the config file specified by the Kubelet'</span>s --config flag. See https://kubernetes.io/docs/tasks/administer-cluster/kubelet-config-file/ <span class="keyword">for</span> more information.</span><br><span class="line">Apr 22 10:46:38 iZwz9f6pgul78p7die5tlzZ kubelet: I0422 10:46:38.716591   21994 feature_gate.go:226] feature gates: &amp;&#123;&#123;&#125; map[]&#125;</span><br><span class="line">Apr 22 10:46:38 iZwz9f6pgul78p7die5tlzZ kubelet: F0422 10:46:38.716693   21994 server.go:218] unable to load client CA file /etc/kubernetes/pki/ca.crt: open /etc/kubernetes/pki/ca.crt: no such file or directory</span><br><span class="line">Apr 22 10:46:38 iZwz9f6pgul78p7die5tlzZ systemd: kubelet.service: main process exited, code=exited, status=255/n/a</span><br><span class="line">Apr 22 10:46:38 iZwz9f6pgul78p7die5tlzZ systemd: Unit kubelet.service entered failed state.</span><br><span class="line">Apr 22 10:46:38 iZwz9f6pgul78p7die5tlzZ systemd: kubelet.service failed.</span><br></pre></td></tr></table></figure>

<p>输出的第三行有这样一条：<code>unable to load client CA file /etc/kubernetes/pki/ca.crt: open /etc/kubernetes/pki/ca.crt: no such file or directory</code><br>关于这个客户端证书，笔者自己也没有怎么搞明白，后面需要接着研究。但是貌似这个证书是在<code>kubeadm init</code>的过程中创建的。所以笔者采取的方法是首先进行<code>kubeadm init</code>操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm init --apiserver-advertise-address=&lt;你的服务器ip&gt; --kubernetes-version=v1.7.5 --pod-network-cidr=10.244.0.0/12</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[kubeadm] WARNING: kubeadm is in beta, please do not use it for production clusters.</span><br><span class="line">[init] Using Kubernetes version: v1.7.5</span><br><span class="line">[init] Using Authorization modes: [Node RBAC]</span><br><span class="line">[preflight] Skipping pre-flight checks</span><br><span class="line">[kubeadm] WARNING: starting in 1.8, tokens expire after 24 hours by default (if you require a non-expiring token use --token-ttl 0)</span><br><span class="line">[certificates] Using the existing CA certificate and key.</span><br><span class="line">[certificates] Using the existing API Server certificate and key.</span><br><span class="line">[certificates] Using the existing API Server kubelet client certificate and key.</span><br><span class="line">[certificates] Using the existing service account token signing key.</span><br><span class="line">[certificates] Using the existing front-proxy CA certificate and key.</span><br><span class="line">[certificates] Using the existing front-proxy client certificate and key.</span><br><span class="line">[certificates] Valid certificates and keys now exist in &quot;/etc/kubernetes/pki&quot;</span><br><span class="line">[kubeconfig] Using existing up-to-date KubeConfig file: &quot;/etc/kubernetes/admin.conf&quot;</span><br><span class="line">[kubeconfig] Using existing up-to-date KubeConfig file: &quot;/etc/kubernetes/kubelet.conf&quot;</span><br><span class="line">[kubeconfig] Using existing up-to-date KubeConfig file: &quot;/etc/kubernetes/controller-manager.conf&quot;</span><br><span class="line">[kubeconfig] Using existing up-to-date KubeConfig file: &quot;/etc/kubernetes/scheduler.conf&quot;</span><br><span class="line">[apiclient] Created API client, waiting for the control plane to become ready</span><br></pre></td></tr></table></figure>

<p>初始化的过程卡在了上面输出的地方。其实想想这个过程绝对是会卡住的，毕竟现在<code>kubelet</code>都没有跑起来。如果你的kubelet已经跑起来了，但是这个<code>kubeadm init</code>还是会卡住，那么就有可能是你的<strong>docker的cgroup driver的类型与kubelet启动参数中指定的cgroup driver类型不一致导致的</strong>,你需要做的就是统一这两者之间的类型。</p>
<p>现在，让我们<code>Ctrl+C</code>终止上述的<code>kubeadm init</code>过程，然后重新启动我们的kubelet:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start kubelet</span><br></pre></td></tr></table></figure>

<p>查看kubelet的状态，kubelet已经跑起来了，乐乐乐:&gt;)</p>
<p>下面我们再次<code>kubeadm init</code>,注意这次我们需要加上<code>--skip-preflight-checks</code>跳过前期检查。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubeadm init --apiserver-advertise-address=&lt;你的服务器ip&gt; --kubernetes-version=v1.7.5 --pod-network-cidr=10.244.0.0/12 --skip-preflight-checks</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[kubeadm] WARNING: kubeadm is in beta, please do not use it for production clusters.</span><br><span class="line">[init] Using Kubernetes version: v1.7.5</span><br><span class="line">[init] Using Authorization modes: [Node RBAC]</span><br><span class="line">[preflight] Skipping pre-flight checks</span><br><span class="line">[kubeadm] WARNING: starting in 1.8, tokens expire after 24 hours by default (if you require a non-expiring token use --token-ttl 0)</span><br><span class="line">[certificates] Using the existing CA certificate and key.</span><br><span class="line">[certificates] Using the existing API Server certificate and key.</span><br><span class="line">[certificates] Using the existing API Server kubelet client certificate and key.</span><br><span class="line">[certificates] Using the existing service account token signing key.</span><br><span class="line">[certificates] Using the existing front-proxy CA certificate and key.</span><br><span class="line">[certificates] Using the existing front-proxy client certificate and key.</span><br><span class="line">[certificates] Valid certificates and keys now exist in &quot;/etc/kubernetes/pki&quot;</span><br><span class="line">[kubeconfig] Using existing up-to-date KubeConfig file: &quot;/etc/kubernetes/admin.conf&quot;</span><br><span class="line">[kubeconfig] Using existing up-to-date KubeConfig file: &quot;/etc/kubernetes/kubelet.conf&quot;</span><br><span class="line">[kubeconfig] Using existing up-to-date KubeConfig file: &quot;/etc/kubernetes/controller-manager.conf&quot;</span><br><span class="line">[kubeconfig] Using existing up-to-date KubeConfig file: &quot;/etc/kubernetes/scheduler.conf&quot;</span><br><span class="line">[apiclient] Created API client, waiting for the control plane to become ready</span><br><span class="line">[apiclient] All control plane components are healthy after 40.004549 seconds</span><br><span class="line">[token] Using token: xxxxxxxxxxxxxxxxx</span><br><span class="line">[apiconfig] Created RBAC rules</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line">[addons] Applied essential addon: kube-dns</span><br><span class="line"></span><br><span class="line">Your Kubernetes master has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run (as a regular user):</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  http://kubernetes.io/docs/admin/addons/</span><br><span class="line"></span><br><span class="line">You can now join any number of machines by running the following on each node</span><br><span class="line">as root:</span><br><span class="line"></span><br><span class="line">  kubeadm join --token xxxxx x.x.x.x:6443</span><br></pre></td></tr></table></figure>

<p>这下,<code>kubeadm init</code>终于成功了、了、了…</p>
<p>正如上面的输出所示，如果你需要让非root用户能够使用你的集群，你需要以该非root用户身份执行下面的命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure>

<p>现在你可以使用下面的命令来查看你的集群的运行状况了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods --all-namepaces</span><br><span class="line">$ kubectl get nodes </span><br><span class="line">$ kubectl get cs</span><br></pre></td></tr></table></figure>

<p>在笔者的机器上，kube-system中的kube-dns对应的pod的状态一直处于异常。这个就需要配置<code>overlay network</code>来解决。</p>
<h1 id="配置overlay-network"><a href="#配置overlay-network" class="headerlink" title="配置overlay network"></a>配置overlay network</h1><p>笔者开始的时候采用的是flannel来配置的<code>overlay network</code>,但是flannel并没有解决kube-dns对应的pod的异常状态，并且网上有声音说flannel与阿里云的主机兼容性不好。所以后面是根据<a href="https://medium.com/@jmarhee/note-on-troubleshooting-kubeadm-managed-kubernetes-cluster-setups-2b2c8248a4e8" target="_blank" rel="noopener">文章</a>来配置的Weave。但是目前团队的生产环境的集群的<code>overlay network</code>使用的是flannel，跑的也挺好的。所以我感觉这个东西也是具有很大的差异性的:&gt;),这里就一并写一下使用flannel、weave来配置集群<code>overlay network</code>的命令。下面的命令都是可以直接使用的。</p>
<h2 id="使用flannel"><a href="#使用flannel" class="headerlink" title="使用flannel"></a>使用flannel</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl --namespace kube-system apply -f https://raw.githubusercontent.com/coreos/flannel/v0.8.0/Documentation/kube-flannel-rbac.yml</span><br><span class="line">$ rm -rf kube-flannel.yml </span><br><span class="line">$ wget https://raw.githubusercontent.com/coreos/flannel/v0.8.0/Documentation/kube-flannel.yml</span><br><span class="line">$ sed -i <span class="string">'s/quay.io\/coreos\/flannel:v0.8.0-amd64/registry.cn-hangzhou.aliyuncs.com\/szss_k8s\/flannel:v0.8.0-amd64/g'</span> ./kube-flannel.yml</span><br><span class="line">$ kubectl --namespace kube-system apply -f ./kube-flannel.yml</span><br></pre></td></tr></table></figure>

<h2 id="使用weave"><a href="#使用weave" class="headerlink" title="使用weave"></a>使用weave</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> kubever=$(kubectl version | base64 | tr -d <span class="string">'\n'</span>)</span><br><span class="line">$ kubectl apply -f <span class="string">"https://cloud.weave.works/k8s/net?k8s-version=<span class="variable">$kubever</span>"</span></span><br></pre></td></tr></table></figure>

<p>由于我是改用weave才就kube-dns的pod才正常工作，所以我推荐大家使用weave来配置。</p>
<h1 id="最后一个问题"><a href="#最后一个问题" class="headerlink" title="最后一个问题"></a>最后一个问题</h1><p>至此，我们的单节点kubernetes集群就搭建完成了。大家在部署应用的时候可能还会遇到另外的一个问题。当你创建了deployment,service之后，查看你的应用的pod，你会发现所有的pod都处于<code>pending</code>的状态，<code>kubectl describe</code>发现这些pod都没有被调度。这是怎么回事呢？原来，我们现在只有一个节点，而kubernets的调度策略默认是不支持在master节点上放置应用pod的，具体的可以查看这个<a href="(https://github.com/kubernetes/kubernetes/issues/49440">issue</a>,可以使用下面的命令，来去掉这样的调度限制:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl taint nodes &lt;nodeName&gt; node-role.kubernetes.io/master:NoSchedule-</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>大致总结一下安装kubernetes集群的流程：</p>
<ul>
<li>准备系统环境</li>
<li>安装Docker</li>
<li>安装Kubernetes相关组件</li>
<li>Kubeadm init Master节点</li>
<li>安装Overlay Network</li>
<li>Join Node节点</li>
</ul>
<p>这里，由于只有一台主机，所以最后一步没有进行。在整个安装过程中，大致流程是不会改变的。但是可能还是会遇到各种各样的问题。这一次安装的过程让我深刻的体会到认真查看log的重要性，还有依据log去google的重要性。不管什么问题，只要你坚持，最终肯定会找到解决问题的方法。最后，感谢万能的互联网。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2018/04/11/something-about-SQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/11/something-about-SQL/" itemprop="url">SQL重难点总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-11T23:04:17+08:00">
                2018-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Database/" itemprop="url" rel="index">
                    <span itemprop="name">Database</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在看数据库的书籍，对数据库的操作，尤其是SQL语言更加熟悉了，概念方面理顺了许多。对以前比较陌生的东西也不再有畏惧感。所以写这篇博客把重难点的部分一并总结一下。</p>
<p>以下的SQL基于<strong>SQL必知必会</strong>书上的五张表:Vendors,Products,Customers,Orders,OrderItems.</p>
<h1 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h1><h2 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h2><p>如下我们可以计算供应商DLL01提供的产品数目：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_prods </span><br><span class="line"><span class="keyword">FROM</span> Products </span><br><span class="line"><span class="keyword">WHERE</span> vend_id = <span class="string">"DLL01"</span>;</span><br></pre></td></tr></table></figure>

<p>那如果我们需要分别计算每一个供应商的提供的产品的数量呢?这个时候就是分组大显身手的时候了。<strong>使用分组可以将数据分为多个逻辑组，对每个组进行聚集计算</strong>。如下:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id,<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_prods </span><br><span class="line"><span class="keyword">FROM</span> Products </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id;</span><br></pre></td></tr></table></figure>

<p>上面的SELECT语句指定了两个列：vend_id包含产品供应商的ID,num_prods为计算字段(用COUNT(*)函数建立)。<code>GROUP BY</code>子句指示DBMS按照vend_id排序并分组数据。这就会对每个vend_id而不是整个表计算一次num_prods.</p>
<h2 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h2><p>除了可以使用<code>GROUP BY</code>进行分组之外，还可以过滤分组，决定那些分组需要，那些分组可以滤去。过滤分组通过HAVING子句进行。例如下面过滤出产品数大于等于2的分组:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id,<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_prods </span><br><span class="line"><span class="keyword">FROM</span> Products </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id </span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>上面的语句中只有产品数目大于等于2的分组才能够被选择出来。</p>
<h2 id="HAVING-VS-WHERE"><a href="#HAVING-VS-WHERE" class="headerlink" title="HAVING VS WHERE"></a>HAVING VS WHERE</h2><p>众所周知，<code>WHERE</code>子句具有过滤的作用，但是<code>WHERE</code>子句指定的是过滤而不是分组，事实上<code>WHERE</code>没有分组的概念。<code>HAVING</code>非常类似于<code>WHERE</code>,目前绝大多数的<code>WHERE</code>子句都可以用<code>HAVING</code>来替代，唯一的差别是，<code>WHERE</code>过滤行，而<code>HAVING</code>过滤分组。另一种理解方式是：<code>WHERE</code>在数据分组前进行过滤，<code>HAVING</code>在数据分组后进行过滤。<code>WHERE</code>排除的行不包括在分组中。这可能会改变计算值，从而影响<code>HAVING</code>子句中基于这些值过滤掉的分组。<code>HAVING</code>与<code>WHERE</code>非常类似，如果不指定<code>GROUP BY</code>,则大多数的DBMS会同等的对待他们。不过我们自己还是需要区分这一点的，使用<strong>HAVING时应该结合GROUP BY子句，而WHERE子句用于标准的行级过滤</strong>。</p>
<h2 id="SELECT子句顺序"><a href="#SELECT子句顺序" class="headerlink" title="SELECT子句顺序"></a>SELECT子句顺序</h2><table>
<thead>
<tr>
<th align="center">子句</th>
<th align="center">说明</th>
<th align="center">是否必须使用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SELECT</td>
<td align="center">要返回的列或表达式</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">FROM</td>
<td align="center">从中检索数据的表</td>
<td align="center">仅在从表选择数据时使用</td>
</tr>
<tr>
<td align="center">WHERE</td>
<td align="center">行级过滤</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">GROUP BY</td>
<td align="center">分组说明</td>
<td align="center">仅在按组计算聚集时使用</td>
</tr>
<tr>
<td align="center">HAVING</td>
<td align="center">组级过滤</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">ORDER BY</td>
<td align="center">输出排序顺序</td>
<td align="center">否</td>
</tr>
</tbody></table>
<h1 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h1><p>SQL最强大的功能之一就是能在数据查询的执行中联结(join)表，联结是利用SQL的SELECT能执行的最重要的操作。为什么要使用联结操作呢？将数据分解为多个表能更有效的存储，更方便的处理，并且可伸缩性更好，这是关系型数据库的最大的特点。但是这些好处是有代价的。我们需要通过联结多个表返回一组输出，联结在运行时关联表中的正确的行。</p>
<h2 id="内联结"><a href="#内联结" class="headerlink" title="内联结"></a>内联结</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name,prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> Vendors,Products</span><br><span class="line"><span class="keyword">WHERE</span> Vendors.vend_id = Products.vend_id;</span><br></pre></td></tr></table></figure>

<p>如上，我们用<code>WHERE</code>子句将Products表的外键vend_id与它所引用的Vendors表的主键vend_id关联起来,这样就建立了这两张表的联结。上面的联结的大致执行过程是这样的：首先对于Vendors表中的每一个元组，都去比对Products表中的每一个元组，如果满足Vendors.vend_id = Products.vend_id,就从这两个元组中提取出指定的列，然后放到输出中，接着就去取Vendors表中的下一个元组，重复上面的过程。Vendors表中的所有元组执行完毕。这里有一个问题需要注意：对于Vendors表中的一个元组，如果在Products表中找不到满足Vendors.vend_id = Products.vend_id的元组(也就是该供应商没有提供产品)，这时候Vendors表中的这个元组放不放到输出中呢？对于上面的SQL，这样的元组不会放到输出中。</p>
<p>上面使用的联结称为<strong>等值联结(equijoin)</strong>，它基于两个表之间的相等测试。这种联结也称为<strong>内连接(inner join)</strong>。其实，可以对这种联结使用稍微不同的语法，明确指定联结类型，就像下面这样:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> Vendors <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Products</span><br><span class="line"><span class="keyword">ON</span> Vendors.vend_id = Products.vend_id;</span><br></pre></td></tr></table></figure>

<p>这条SQL语句和前面的那条语句所起的作用是等价的。这里，两个表之间的关系是以<code>INNER JOIN</code>指定的部分<code>FROM</code>子句，在使用这种语法时，联结条件用特定的<code>ON</code>子句而不是<code>WHERE</code>子句给出，传递给<code>ON</code>的实际条件与传递给<code>WHERE</code>的相同。</p>
<h2 id="联结多个表"><a href="#联结多个表" class="headerlink" title="联结多个表"></a>联结多个表</h2><p>SQL不限制一条SELECT语句中可以联结的表的数目，创建联结的基本规则也相同，首先列出所有表，然后定义表之间的关系，就像下面这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name,vend_name,prod_price,quantity</span><br><span class="line"><span class="keyword">FROM</span> OrderItems,Products,Vendors</span><br><span class="line"><span class="keyword">WHERE</span> Products.vend_id = Vendors.vend_id</span><br><span class="line"><span class="keyword">AND</span> OrderItems.prod_id = Products.prod_id</span><br><span class="line"><span class="keyword">AND</span> order_num = <span class="number">20007</span>;</span><br></pre></td></tr></table></figure>

<p>上面我们使用的只是内联结(也叫等值联结)的简单联结，下面我们看其他联结：自联结(self-join)、外联结(outer join).</p>
<h2 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h2><p>使用表别名能够在一个SELECT语句中不止一次的引用相同的表，我们可以使用利用表别名来完成同一个表的自联结。如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c1.cust_id, c1.cust_name,c1.cust_contact</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">AS</span> c1,Customers <span class="keyword">AS</span> c2</span><br><span class="line"><span class="keyword">WHERE</span> c1.cust_name = c2.cust_name</span><br><span class="line"><span class="keyword">AND</span> c2.cust_contact = <span class="string">"Jim Jones"</span>;</span><br></pre></td></tr></table></figure>

<p>这条语句检索出的就是和Jim Jones在同一家公司工作的的雇员的信息。</p>
<h2 id="外联结"><a href="#外联结" class="headerlink" title="外联结"></a>外联结</h2><p>内连接是将一个表中的行与另一个表中的行相关联，但有时候需要关联没有关联行的那些行。例如可能需要使用联结完成以下工作：<br>－　对每一个顾客下的订单数进行计数，包括那些至今尚未下订单的顾客；<br>－　列出所有产品以及订购数量，包括没有人订购的产品；<br>－　计算平均销售规模，包括那些至今尚未下订单的顾客。<br>在上述例子中，联结包含了那些在相关表中没有关联行的行。这种联结称为<strong>外联结</strong>。如下的例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id,Orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id;</span><br></pre></td></tr></table></figure>

<p>这条SELECT语句使用了关键字<code>OUTER JOIN</code>来指定了联结类型。与内连接关联两个表中的行不同，外联结还包括没有关联的行。在使用<code>OUTER JOIN</code>语法时，必须使用RIGHT或者LEFT关键字指定包括其所有行的表(<code>RIGHT</code>指出的是<code>OUTER JOIN</code>右边的表，而<code>LEFT</code>指出的是<code>OUTER JOIN</code>左边的表)，上面的例子使用<code>LEFT OUTER JOIN</code>从<code>FROM</code>子句左边的表(Customers)中选择所有行。为了从右边的表中选择所有的行，需要使用<code>RIGHT OUTER JOIN</code>,如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id,Orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers　<span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id;</span><br></pre></td></tr></table></figure>

<h2 id="使用带聚集函数的联结"><a href="#使用带聚集函数的联结" class="headerlink" title="使用带聚集函数的联结"></a>使用带聚集函数的联结</h2><p>如下，按照顾客的id分组，查询每个顾客的订单数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id,</span><br><span class="line">    <span class="keyword">COUNT</span>(Orders.order_num) <span class="keyword">AS</span> num_ord</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Orders </span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Customers.cust_id;</span><br></pre></td></tr></table></figure>

<p>这里使用的是内联结，所以不会包含没有下订单的顾客分组。如果要包含他们就需要使用<code>LEFT OUTER JOIN</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2018/03/09/limiting-use/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/09/limiting-use/" itemprop="url">限制资源访问</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-09T13:01:25+08:00">
                2018-03-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Nginx/" itemprop="url" rel="index">
                    <span itemprop="name">Nginx</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>昨天爬了一下小幸运，爬取了大约4000条左右的愿望信息。爬取的过程中我没有设置代理和设置延迟，任由代码迅速的发送请求。爬取的过程相当顺利。这说明小幸运的服务端没有做限制来访IP请求频率的处理。这很容易引发DDOS(分布式拒绝服务)攻击。基于此，我研究了一下对客户端请求限制的方法。收获记录如下!</p>
<p>NGINX有多个内建的模块可以帮助我们控制客户端对应用的使用。比如:限制连接数，限制请求和响应的速率，限制带宽等。</p>
<h2 id="限制连接"><a href="#限制连接" class="headerlink" title="限制连接"></a>限制连接</h2><p>我们可以通过某一个预定义的变量来限制某一客户端的连接数，通常这个预定义的变量是客户端的IP地址。我们可以构建一个共享内存的域来存储连接指标，然后使用<strong>limit_conn</strong>指令来限制打开的连接数，具体的配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    <span class="attribute">limit_conn_zone</span> <span class="variable">$binary_remote_addr</span> zone=limitbyaddr:<span class="number">10m</span>;</span><br><span class="line">    <span class="attribute">limit_conn_status</span> <span class="number">429</span>;</span><br><span class="line">    ...</span><br><span class="line">    server&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="attribute">limit_conn</span> limitbyaddr <span class="number">40</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述配置文件创建了一个共享内存区域(zone)并命名为limitbyaddr。使用的预定义的变量是<strong>$binary_remote_addr</strong>,也就是客户端的IP地址的二进制形式。共享内存区域的大小被设置为了10MB.<strong>limit_conn</strong>指令需要两个参数：一个是<strong>limit_conn_zone</strong>的名字，第二个是允许的最大连接数。<strong>limit_conn_status</strong>指令设置连接数超过指定值之后的服务器响应,默认的响应是503(service unavailable)，在上述配置中如果同一个客户端同时打开的连接数超过40,那么就会收到429响应(too many requests)。<strong>limit_conn_zone</strong>只在http指令块中可用，<strong>limit_conn</strong>和<strong>limit_conn_status</strong>在http,server,location指令块中都可用。</p>
<h2 id="限制请求速率"><a href="#限制请求速率" class="headerlink" title="限制请求速率"></a>限制请求速率</h2><p>通过预定义的变量可以来限制请求的速率，通常这个预定义的变量也是客户端的IP地址。利用rate-limiting模块来限制请求的速率。配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    <span class="attribute">limit_req_zone</span> <span class="variable">$binary_remote_addr</span> zone=limitbyaddr:<span class="number">10m</span> rate=1r/s;</span><br><span class="line">    <span class="attribute">limit_req_status</span> <span class="number">429</span>;</span><br><span class="line">    ...</span><br><span class="line">    server&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="attribute">limit_req</span> zone=limitbyaddr burst=<span class="number">10</span> nodelay;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个参数:设置使用哪个配置区域来做限制，与上面limit_req_zone 里的name对应<br>第二个参数：burst=5，重点说明一下这个配置，burst爆发的意思，这个配置的意思是设置一个大小为5的缓冲区，当有大量请求（爆发）过来时，超过了访问频次限制的请求可以先放到这个缓冲区内<br>第三个参数：nodelay，如果设置，超过访问频次而且缓冲区也满了的时候就会直接返回<strong>limit_req_status</strong>的值，如果没有设置，则所有请求会等待排队</p>
<p>上述配置创建了一个共享内存的区域(zone)并将其命名为limitbyaddr.预定义的键是客户端的IP地址的二进制形式。共享内存区域的大小被设置成了10MB,这个共享内存区域还设置了rate的关键字参数，用来指定允许客户端请求的频率上限。<strong>limit_req</strong>指令需要两个可选的关键字参数：zone,burst。zone指明了使用的共享内存区域。当某一个共享内存区域的请求速率达到了之后，请求就会被延迟处理，直到达到burst值。burst值默认为0.<strong>limit_req</strong>的第三个可选参数是:<strong>nodelay</strong>,此参数使客户端在受限制之前无延迟地使用其突发。</p>
<h2 id="限制带宽"><a href="#限制带宽" class="headerlink" title="限制带宽"></a>限制带宽</h2><p>如果你需要限制每个客户端的下载带宽，你可以使用NGINX的<strong>limit_rate</strong>和<strong>limit_rate_after</strong>指令来实现:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /download/ &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attribute">limit_rate_after</span> <span class="number">10m</span>;</span><br><span class="line">    <span class="attribute">limit_rate</span> <span class="number">1m</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的配置指明了对于/download/开头的URL的请求，在成功返回10MB的数据之后，开始以每秒1MB的速率传输数据至客户端。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2018/03/04/build-a-blog-with-hexo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/04/build-a-blog-with-hexo/" itemprop="url">木犀后端分享--hexo博客搭建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-04T09:06:23+08:00">
                2018-03-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hexo/" itemprop="url" rel="index">
                    <span itemprop="name">Hexo</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>用hexo搭建一个博客的简要步骤.</p>
<h1 id="原料"><a href="#原料" class="headerlink" title="原料"></a>原料</h1><ul>
<li>github账号</li>
<li>git</li>
<li>nodeJS和npm</li>
</ul>
<h1 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h1><p>1.通过<a href="https://www.jianshu.com/p/8671e439a811" target="_blank" rel="noopener">下载nvm</a>来下载和管理node和npm(推荐)<br>2.在github上新建一个名为“&lt;你的github用户名&gt;.github.io”的仓库<br>3.在系统某处依次运行下列命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>这时，你如果访问<a href="http://127.0.0.1:4000" target="_blank" rel="noopener">http://127.0.0.1:4000</a> 就可以发现你的博客已经在本地跑起来了。<br>4.修改博客根目录下<strong>_config.yml</strong>配置文件,改动两个地方:url,deploy</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https://hexo.io/docs/configuration.html</span><br><span class="line">## Source: https://github.com/hexojs/hexo/</span><br><span class="line"></span><br><span class="line"># Site</span><br><span class="line">title: Hexo</span><br><span class="line">subtitle:</span><br><span class="line">description:</span><br><span class="line">author: John Doe</span><br><span class="line">language:</span><br><span class="line">timezone:</span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: http://yoursite.com   #比如，改成我的配置 url: http://andrewpqc.github.io</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line"># Directory</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link: true # Open external links in new tab</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace:</span><br><span class="line">  </span><br><span class="line"># Home page setting</span><br><span class="line"># path: Root path for your blogs index page. (default = &apos;&apos;)</span><br><span class="line"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><span class="line"># order_by: Posts order. (Order by date descending by default)</span><br><span class="line">index_generator:</span><br><span class="line">  path: &apos;&apos;</span><br><span class="line">  per_page: 10</span><br><span class="line">  order_by: -date</span><br><span class="line">  </span><br><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"># Date / Time format</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: landscape</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type:</span><br><span class="line"></span><br><span class="line">#上面的deploy的配置改成我的就是下面的这样:</span><br><span class="line">#deploy: </span><br><span class="line">#  type: git</span><br><span class="line">#  repo: https://github.com/Andrewpqc/Andrewpqc.github.io.git</span><br><span class="line">#  branch: master</span><br></pre></td></tr></table></figure>

<p>5.下载git部署插件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>6.部署</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d -g <span class="comment">#生成并部署</span></span><br></pre></td></tr></table></figure>

<p>此时打开浏览器，输入https://&lt;你的github用户名&gt;.github.io就会发现你的博客已经远端部署成功了。</p>
<h1 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ hexo n <span class="string">"我的博客"</span> == hexo new <span class="string">"我的博客"</span> <span class="comment">#新建文章</span></span><br><span class="line">$ hexo p == hexo publish</span><br><span class="line">$ hexo g == hexo generate               <span class="comment">#生成</span></span><br><span class="line">$ hexo s == hexo server                 <span class="comment">#启动服务预览</span></span><br><span class="line">$ hexo d == hexo deploy                 <span class="comment">#部署</span></span><br><span class="line">$ hexo server                           <span class="comment">#Hexo 会监视文件变动并自动更新，无须重启服务器。</span></span><br><span class="line">$ hexo server -s                        <span class="comment">#静态模式</span></span><br><span class="line">$ hexo server -p 5000                   <span class="comment">#更改端口</span></span><br><span class="line">$ hexo server -i 192.168.1.1            <span class="comment">#自定义IP</span></span><br><span class="line">$ hexo clean                            <span class="comment">#清除缓存，网页正常情况下可以忽略此条命令</span></span><br></pre></td></tr></table></figure>

<p>更多具体命令请看-&gt;<a href="https://segmentfault.com/a/1190000002632530" target="_blank" rel="noopener">这儿</a></p>
<h1 id="hexo主题"><a href="#hexo主题" class="headerlink" title="hexo主题"></a>hexo主题</h1><p>hexo有很多的<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题</a>可以使用，使用起来也非常简单。<strong>hexo init</strong>之后，博客文件夹中默认安装了landscape主题。如果我们还想要使用其他的主题可以直接到github上把该主题的仓库克隆到landscape所在的目录。然后更改博客根目录下的_config.yml中的theme配置选项即可实现主题的切换。</p>
<p>hexo主题的页面布局、配色、功能等方面一般都给了用户较大的自定义权限，用户可以通过修改主题文件夹下的_config.yml配置文件和下载插件的形式来实现自定义。<a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">1</a><br>接下来，就开始探索你的博客吧!</p>
<h1 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h1><p>1.备份很重要。<br>2.hexo消失了怎么办。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://baoyuzhang.github.io/2017/05/12/【Hexo搭建独立博客全纪录】（三）使用Hexo搭建博客/" target="_blank" rel="noopener">使用Hexo搭建博客</a><br><a href="http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa" target="_blank" rel="noopener">使用hexo+github搭建免费个人博客详细教程</a><br><a href="http://tengj.github.io/2016/02/26/hexo2/" target="_blank" rel="noopener">hexo主题下载及配置</a><br><a href="https://pengbinlee.github.io/NexT-主题的安装及个性化设置/" target="_blank" rel="noopener">NexT主题个性化配置</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2018/02/23/go-concurrency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/23/go-concurrency/" itemprop="url">go语言并发编程——goroutine和通道</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-23T16:05:26+08:00">
                2018-02-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GO/" itemprop="url" rel="index">
                    <span itemprop="name">GO</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/images/go.jpeg" alt="go"><br>Go语言有两种并发编程的风格：一种是goroutine和通道，它们支持通信顺序进程(Communicating Sequential Process,CSP),CSP是一种并发的模式，可以在不同的执行体(goroutine)之间传递值，但是变量本身局限于单一的执行体。另一种是共享内存多线程的传统模型，它们和在其他的主流语言中使用的线程类似。在这里主要介绍goroutine和通道。</p>
<h1 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h1><h2 id="概念及本质"><a href="#概念及本质" class="headerlink" title="概念及本质"></a>概念及本质</h2><p>在Go语言中每一个并发执行的活动称为goroutine.这一概念初看上去和线程有些相似，但实际上<strong>goroutine并不是线程，它只是对线程的多路复用</strong>。一个goroutine在<strong>启动时只需要一个非常小的栈</strong>，并且这个栈可以按需扩展和缩小(在GO1.4中，goroutine启动时的栈大小仅为2KB)。正是因为<strong>goroutine的轻量级</strong>，所以<strong>goroutine的数量可以比线程的数量多得多</strong>。当一个goroutine被阻塞时，它也会阻塞所复用的操作系统线程，而运行时环境(runtime)则会把位于被阻塞线程上的其他goroutine移动到其他未阻塞的线程上继续运行。</p>
<h2 id="使用goroutine"><a href="#使用goroutine" class="headerlink" title="使用goroutine"></a>使用goroutine</h2><p>goroutine的用法非常简单:只要把go关键字添加到任意一个具名函数或者匿名函数的前面，该函数就会成为一个goroutine。特殊的，当一个程序启动时，有一个goroutine来调用main函数，称它为主goroutine。其他的新的goroutine都是通过go语句进行创建。go语句本身的执行立即完成，并不会阻塞程序继续向下执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f()   <span class="comment">//调用f();等待它返回</span></span><br><span class="line"><span class="keyword">go</span> f()<span class="comment">//新建一个调用f()的goroutine,不用等待</span></span><br></pre></td></tr></table></figure>

<p>下面是一个使用goroutine的例子:主goroutine中新建了一个goroutine用于指示程序仍然在运行，而主goroutine本身仍然在进行求45个斐波那契数的计算。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> spinner(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">    fmt.Println(fib(<span class="number">45</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spinner</span><span class="params">(delay time.Duration)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, d := <span class="keyword">range</span> <span class="string">`-\|/`</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"\r%"</span>, d)</span><br><span class="line">            time.Sleep(delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fib(a<span class="number">-1</span>) + fib(a<span class="number">-2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过运行该程序我们可以发现，提示符在运行的那一刻起就开始了，与此同时程序在进行着计算，几秒钟之后程序打印出第45个斐波那契数，然后主goroutine退出，我们发现主goroutine创建的goroutine也被暴力的直接终结了。</p>
<h2 id="等待goroutine"><a href="#等待goroutine" class="headerlink" title="等待goroutine"></a>等待goroutine</h2><p>我们来看下面这个并发程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNumbers</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d "</span>,i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printLetters</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="string">'A'</span>;i&lt;<span class="number">10</span>+<span class="string">'A'</span>;i++&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"% "</span>,i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">go</span> printNumbers()</span><br><span class="line">    <span class="keyword">go</span> printLetters()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们运行程序，发现程序并没有产生任何输出！这是因为在该用例中，主goroutine在它的两个goroutine能够产生输出之前就已经结束了，结束之前还暴力的终结了刚刚创建的两个goroutine。显然，我们需要一种机制使程序可以在确保所有goroutine都已经执行完毕的情况下，再执行下一项工作。</p>
<p>为此，GO语言在<strong>sync</strong>包中提供了一种名为<strong>等待组</strong>(WaitGroup)的机制，它的运作方式非常简单直接:</p>
<ul>
<li>声明一个等待组；</li>
<li>使用<strong>Add</strong>方法为等待组的计时器设置值;</li>
<li>当一个goroutine完成它的工作时，使用<strong>Done</strong>方法对等待组的计时器执行减一操作；</li>
<li>调用<strong>Wait</strong>方法，该方法将一直阻塞，直达等待组计数器的值变为0.</li>
</ul>
<p>下面是添加等待的版本:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNumbers</span><span class="params">(wg *sync.WaitGroup)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d "</span>,i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printLetters</span><span class="params">(wg *sync.WaitGroup)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="string">'A'</span>;i&lt;<span class="number">10</span>+<span class="string">'A'</span>;i++&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"% "</span>,i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    g.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> printNumbers(&amp;wg)</span><br><span class="line">    <span class="keyword">go</span> printLetters(&amp;wg)</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出(您的输出可能有所不同):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A B C D E F G H I J </span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<p>如上，程序产生了我们期望的输出:&gt;)</p>
<h1 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h1><p>在上面我们已经知道怎样通过go关键字将普通函数转换成goroutine以便让其独立运行，还知道可以设置等待组来同步独立运行的多个goroutine。下面我们将要学习如何使用通道在多个不同的goroutine之间通信。</p>
<h2 id="基本语法及性质"><a href="#基本语法及性质" class="headerlink" title="基本语法及性质"></a>基本语法及性质</h2><p>通道是一种带有类型的值，它可以让不同的goroutine互相通信。通道用make函数创建，该函数在被调用之后将返回一个指向底层数据结构的引用作为结果值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unbufferedChannel:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">bufferChannel:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>如上，我们创建了两个可以容纳int类型值的通道，一个是<strong>无缓冲通道</strong>，一个是<strong>有缓冲通道</strong>。如果用户在创建通道的时候，向make函数提供了可选的第三个参数，那么make函数将创建出一个带有给定大小缓冲区的缓冲通道;未给定可选参数或者可选参数给定的为0,创建的都是无缓冲通道，也叫做<strong>同步通道</strong>。</p>
<p>像map一样，通道是一个使用make创建的数据结构的引用，当复制或者作为参数传递到一个函数时，复制的是引用，这样调用者和被调用者都引用同一份数据结构。</p>
<p>通道有两个主要操作，发送和接收，发送语句从一个goroutine传输一个值到另一个在执行接收表达式的goroutine。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- x <span class="comment">//把x发送到通道ch</span></span><br><span class="line">a:= &lt;-ch <span class="comment">//从通道ch取值赋给变量a</span></span><br><span class="line">&lt;-ch    <span class="comment">//从通道ch取一个值，并丢弃。</span></span><br></pre></td></tr></table></figure>

<p>通道还支持第三个操作：关闭。关闭操作设置一个标志位来指示值当前已经发送完毕，这个通道后面没有值了。针对关闭后的通道的发送操作将导致宕机。在一个已经关闭的通道上进行接收操作，将获取所有已经发送的值，直到通道为空，这时任何接收操作会立即完成，同时获取到一个通道元素对应的零值。关闭通道使用内置的close函数完成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>

<h2 id="无缓冲通道"><a href="#无缓冲通道" class="headerlink" title="无缓冲通道"></a>无缓冲通道</h2><p>无缓冲通道上的发送操作将会阻塞，直到另一个goroutine在对应的通道上执行接收操作，这时值传送完成，两个goroutine都可以继续执行。相反，如果接收操作先执行，接收方goroutine将阻塞，直到另一个goroutine在通道上发送一个值。</p>
<p>使用无缓冲通道进行通信导致发送和接收goroutine同步化，因此，无缓冲通道才被称为同步通道。</p>
<p>利用无缓冲通道的同步化特点，我们也可以也可以实现上面等待组实现的功能:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNumbers</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d "</span>,i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    ch&lt;<span class="number">-1</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printLetters</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="string">'A'</span>;i&lt;<span class="number">10</span>+<span class="string">'A'</span>;i++&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"% "</span>,i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    ch&lt;<span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ch1,ch2:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> printNumbers(ch1)</span><br><span class="line">    <span class="keyword">go</span> printLetters(ch2)</span><br><span class="line">    &lt;-ch1</span><br><span class="line">    &lt;-ch2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓冲通道"><a href="#缓冲通道" class="headerlink" title="缓冲通道"></a>缓冲通道</h2><p>缓冲通道有一个元素队列，队列的最大长度在创建的时候通过make的容量参数来设置，如下可以创建一个可以容纳三个字符串的缓冲通道:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>缓冲通道上的发送操作在队列的尾部插入一个元素，接收操作从队列的头部移除一个元素。如果通道满了，发送操作将会阻塞所在goroutine直到另一个goroutine对它进行接收操作来留出可用的空间。反过来，如果通道是空的，执行接收操作的goroutine阻塞，直到另一个goroutine在通道上发送数据。</p>
<p>通道既不满也不空时，接收操作和发送操作都不会阻塞，通过这种方式，通道的缓冲区将发送和接收操作进行了解耦。</p>
<p>有时，程序需要知道缓冲通道的缓冲区的容量或者当前存储的元素个数，可以通过内置的<strong>cap</strong>,<strong>len</strong>函数求得：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n:=<span class="built_in">cap</span>(ch)<span class="comment">//求缓冲通道的容量</span></span><br><span class="line">m:=<span class="built_in">len</span>(ch)<span class="comment">//求缓冲通道当前元素个数</span></span><br></pre></td></tr></table></figure>

<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>通道可以用来连接goroutine,这样一个输出是另一个的输入。这种情形叫<strong>管道</strong>(pipeline)。下面的程序由三个goroutine组成，它们被两个通道连接起来，从而形成了一个三级管道。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    squares := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//counter</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> x:=<span class="number">0</span>;;x++&#123;</span><br><span class="line">            naturals&lt;-x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//squarer</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>&#123;</span><br><span class="line">            x:=&lt;-naturals</span><br><span class="line">            squares&lt;-x*x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printer(在主goroutine中)</span></span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d "</span>,&lt;-squares)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>counter产生连续的自然数，通过管道传输到squarer进行平方，平方后的结果又通过管道传输到printer打印出来。正如我们所预料的那样，程序输出了无限的平方序列0,1,4,9，…</p>
<p>如果我们想生成有限的数字怎么办呢？<br>如果发送方知道没有更多的数据需要发送了，告诉接受者所在goroutine可以停止等待是很有用的，这可以通过调用内置的close函数来关闭通道：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>

<p>在通道关闭后，任何后续的发送操作将会导致应用崩溃。当被关闭的通道被读完(就是最后一个发送值被接收)后，所有后续的接收操作顺畅进行，只是获取的是对应通道元素类型的零值。</p>
<p>没有一个直接的方式来判断是否通道已经关闭，但是这里有接收操作的一个变种，它产生两个结果：一个是接收到的通道值，另一个是一个布尔值(通常称之为ok),它为true时代表接收成功，为false代表当前的接收操作在一个关闭并且读完的通道上。利用这一特性我们可以修改squarer:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sqarer</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>&#123;</span><br><span class="line">        x,ok:=&lt;-naturals</span><br><span class="line">        <span class="keyword">if</span> !ok&#123;<span class="comment">//naturals通道已经关闭，并且值接收完成</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        squares&lt;-x*x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(squares)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的语法比较笨拙，而模式比较通用，所以go语言提供了range循环语法以在通道上迭代。这个语法更方便接收在通道上所有发送值，接受完最后一个值后关闭循环。下面是利用这一特性改写之后的程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    squares := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//counter</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> x:=<span class="number">0</span>;x&lt;<span class="number">10</span>;x++&#123;</span><br><span class="line">            naturals&lt;-x</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(naturals)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//squarer</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> x:=<span class="keyword">range</span> naturals&#123;</span><br><span class="line">            squares&lt;-x*x</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(squares)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printer(在主goroutine中)</span></span><br><span class="line">    <span class="keyword">for</span> m:=<span class="keyword">range</span> squares&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d "</span>,m)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结束时关闭每一个通道并不是必需的，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。</p>
<h2 id="缓冲与无缓冲的选择"><a href="#缓冲与无缓冲的选择" class="headerlink" title="缓冲与无缓冲的选择"></a>缓冲与无缓冲的选择</h2><p>缓冲通道和无缓冲通道的选择、缓冲通道容量的选择都会对程序的正确性产生影响。无缓冲通道提供强同步保障，因为每一次发送都需要和对应的接收同步；对于缓冲通道，这些操作则是解耦的。在通常情况下，如果我们知道要发送的值数量的上限，我们会创建一个容量为此上限的缓冲通道，在接收第一个值之前就完成所有的发送。</p>
<h1 id="goroutine和通道应用技巧"><a href="#goroutine和通道应用技巧" class="headerlink" title="goroutine和通道应用技巧"></a>goroutine和通道应用技巧</h1><h2 id="通用的并行循环模式"><a href="#通用的并行循环模式" class="headerlink" title="通用的并行循环模式"></a>通用的并行循环模式</h2><p>我们来看看一些通用的并行模式，来并行执行所有的循环迭代。考虑一个生成全尺寸图片缩略图的程序，下面的程序在每一个图像文件名字列表上进行循环，然后给每一个图像产生一副缩略图:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeThumbnails</span><span class="params">(filenames []<span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> _,f:=<span class="keyword">range</span> filenames&#123;</span><br><span class="line">        <span class="keyword">if</span> _,err:=thumbnail.ImageFile(f);err!=<span class="literal">nil</span>&#123;</span><br><span class="line">            log.Println(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然，处理文件的顺序没有关系，因为每一个缩放操作和其他的操作独立。像这样由一些完全独立的子问题组成的问题称为<strong>高度并行</strong>。高度并行的问题是最容易实现并行的，有许多并行机制来实现线性扩展。如下，我们给每一个任务一个go关键字:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeThumbnails2</span><span class="params">(filenames []<span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> _,f:=<span class="keyword">range</span> filenames&#123;</span><br><span class="line">        <span class="keyword">go</span> thumbnail.ImageFile(f)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让这些任务并行去执行。如果我们运行这个函数，会发现它运行的实在是太快了，快的让人不敢相信，并且它也没有按照我们的预期生成缩略图。原因是函数在没有完成想要完成的事情之前就已经返回了。它启动了所有的goroutine,每一个文件一个，但是没有等他们执行完毕。</p>
<p>要想解决上面的问题，方法就是使用上文中已经提到的<strong>同步通道</strong>或<strong>等待组</strong>。用这两种方法的示例代码如下:<br><strong>使用同步通道</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeThumbnails3</span><span class="params">(filenames []<span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    ch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    for_,f:=<span class="keyword">range</span> filenames&#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(f <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">            thumbnail.ImageFile(f)</span><br><span class="line">            ch&lt;-<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;(f)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> filenames&#123;</span><br><span class="line">        &lt;-ch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用等待组</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeThumbnails3</span><span class="params">(filenames []<span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    for_,f:=<span class="keyword">range</span> filenames&#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(f <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            thumbnail.ImageFile(f)</span><br><span class="line">        &#125;(f)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="限制并发数量"><a href="#限制并发数量" class="headerlink" title="限制并发数量"></a>限制并发数量</h2><p>我们来看一个简单的网络爬虫,它以广度优先的顺序来探索网页的链接：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">crawl</span><span class="params">(url <span class="keyword">string</span>)</span>[]<span class="title">string</span></span>&#123;</span><br><span class="line">    fmt.Println(url)</span><br><span class="line">    list,err:=links.Extract(url)</span><br><span class="line">    <span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    worklist:=<span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;worklist&lt;-os.Args[<span class="number">1</span>:]&#125;()</span><br><span class="line"></span><br><span class="line">    seen:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> list:=<span class="keyword">range</span> worklist&#123;</span><br><span class="line">        <span class="keyword">for</span> _,url:=<span class="keyword">range</span> list&#123;</span><br><span class="line">            <span class="keyword">if</span> !seen[url]&#123;</span><br><span class="line">                seen[url]=<span class="literal">true</span></span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(u <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">                    worklist&lt;-crawl(url)</span><br><span class="line">                &#125;(url)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序首先从命令行收集起始的url，然后并发的爬取这些页面并且从中提取出页面的新url,如果是之前已经爬取的页面则不再爬取，并且将这些新的url发送至通道中，供程序继续爬取。可见我们是通过对crawl的独立调用从而充分的利用了Web上的I/O并行机制。</p>
<p>这个爬虫高度并发，但是它有两个问题。一个是程序的并行度太高，一下子会创建太多的网络连接，超过程序能打开文件的限制。第二是这个程序永远不会结束。</p>
<p>无限制的并行通常不是一个好主意，因为系统中总有限制因素。例如对于计算型应用CPU核数，对于磁盘I/O操作磁头和磁盘的个数，下载流所使用的网络带宽，或者Web服务本身的容量等等。解决高并行的方法就是根据资源的可用情况限制并发的个数，以匹配合适的并行度。对于上面的程序我们有一个简单的方法就是确保对于_links.Extract()_的同时调用不超过n个。我们可以使用容量为n的缓冲通道来建立一个并发原语，称为<strong><em>计数信号量</em></strong>。概念上，对于缓冲通道中的n个空闲槽，每一个代表一个令牌，持有者可以执行，通过发送一个值到通道中领取令牌，从通道中接受一个值来释放令牌，创建一个新的空闲槽。这保证了在没有接收操作的时候，最多同时有n个发送。因为通道元素的类型在这里并不重要，所以我们使用struct{},它所占用的空间的大小为0.</p>
<p>同时，为了让程序终止，当任务列表为空且爬取goroutine都结束以后，需要从主循环退出。基于以上两点我们可以做出如下的改进:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tokens = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;,<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">crawl</span><span class="params">(url <span class="keyword">string</span>)</span>[]<span class="title">string</span></span>&#123;</span><br><span class="line">    fmt.Println(url)</span><br><span class="line">    tokens&lt;-<span class="keyword">struct</span>&#123;&#125;&#123;&#125;<span class="comment">//获取令牌</span></span><br><span class="line">    list,err:=links.Extract(url)</span><br><span class="line">    &lt;-tokens　　　　　　<span class="comment">//释放令牌</span></span><br><span class="line">    <span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    worklist:=<span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">    n ++  <span class="comment">//n用来记录任务列表中的任务个数</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>&#123;worklist&lt;-os.Args[<span class="number">1</span>:]&#125;()</span><br><span class="line">    seen:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> ;n&gt;<span class="number">0</span>;n--&#123;</span><br><span class="line">        list := &lt;-worklist</span><br><span class="line">        <span class="keyword">for</span> _,link:=<span class="keyword">range</span> list&#123;</span><br><span class="line">            <span class="keyword">if</span> !seen[link]&#123;</span><br><span class="line">                seen[link] = <span class="literal">true</span></span><br><span class="line">                n++</span><br><span class="line">                <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(link <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">                    worklist&lt;-crawl(link)</span><br><span class="line">                &#125;(link)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="节拍器"><a href="#节拍器" class="headerlink" title="节拍器"></a>节拍器</h2><p>在go语言的<strong>time包</strong>中内置了节拍器,time.Tick函数返回一个通道，它定期发送事件，像一个节拍器一样。每个事件的值是一个时间戳，一般我们不关心通道里面的内容，而是把它当做执行定时任务的工具:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"Commencing countdown."</span>)</span><br><span class="line">    tick:=time.Tick(<span class="number">1</span>*time.Second)<span class="comment">//时间间隔为１s</span></span><br><span class="line">    <span class="keyword">for</span> countdown:=<span class="number">10</span>;countdown&gt;<span class="number">0</span>;countdown--&#123;</span><br><span class="line">        fmt.Println(countdown)</span><br><span class="line">        &lt;-tick</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，我们利用节拍器实现了一个倒计时的功能，每一次for循环会被阻塞一秒，这样程序就是一秒输出一个数字。</p>
<p>Tick函数很方便使用，但是它仅仅在应用的整个生命周期中都需要时才合适，否则我们就需要使用这个模式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ticker:=time.NewTicker(<span class="number">1</span>*time.Second)</span><br><span class="line">&lt;-ticker.C    <span class="comment">//从ticker的通道里面接收</span></span><br><span class="line">ticker.Stop()　<span class="comment">//当不需要该节拍器之后，可以显式的停止它</span></span><br></pre></td></tr></table></figure>

<h2 id="使用select多路复用"><a href="#使用select多路复用" class="headerlink" title="使用select多路复用"></a>使用select多路复用</h2><p>现在我要给上面的倒计时程序加一个需求，在倒计时的过程中，如果用户按下键盘，则倒计时终止。下面的程序实现了这个需求:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    abort:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        os.Stdin.Read(<span class="built_in">make</span>([]<span class="keyword">byte</span>,<span class="number">1</span>))</span><br><span class="line">        abort&lt;-<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Commencing countdown."</span>)</span><br><span class="line">    tick:=time.Tick(<span class="number">1</span>*time.Second)<span class="comment">//时间间隔为１s</span></span><br><span class="line">    <span class="keyword">for</span> countdown:=<span class="number">10</span>;countdown&gt;<span class="number">0</span>;countdown--&#123;</span><br><span class="line">        fmt.Println(countdown)</span><br><span class="line">        <span class="keyword">select</span>&#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-tick:</span><br><span class="line">            <span class="comment">//什么都不做</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-abort:</span><br><span class="line">            fmt.Println(<span class="string">"abort...!"</span>)</span><br><span class="line">            <span class="keyword">return</span><span class="comment">//返回，终止  </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一次倒计时迭代需要等待事件到达两个通道中的一个：计时器通道(前提是一切顺利，即用户没有按键)，中止事件通道(前提是有异常，即用户按键)。<br>如上，我们使用了一个select语句实现了该功能,下面是select语句的通用形式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">    <span class="comment">//code block 1</span></span><br><span class="line"><span class="keyword">case</span> z:&lt;-ch2:</span><br><span class="line">    <span class="comment">//code block 2</span></span><br><span class="line"><span class="keyword">case</span> ch3&lt;-data:</span><br><span class="line">    <span class="comment">//code block 3</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">//code block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像switch语句一样，它有一系列的情况和一个可选的默认分支，每一个情况指定一次通信(在一些通信上进行发送或者接收操作)，和相关联的一段代码块。接收表达式操作可能出现在它本身，像第一种情况，或者在一个短变量声明中，像第二种情况，第二种形式可以让你引用你所接收的值。</p>
<p>select一直等待，直到一次通信来告知有一些情况可以执行。然后，它进行它进行这次通信，执行此情况所对应的语句；其他的通信将不会发生。对于没有对应情况的select语句，它将会永远等待。当有多个情况同时满足的时候，select随机选择一个，这样保证每一个通道有相同的机会被选中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2018/01/09/binary-search-tree-avl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/09/binary-search-tree-avl/" itemprop="url">平衡二叉树(AVL)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-09T21:31:27+08:00">
                2018-01-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上文中谈到朴素的二叉搜索树在进行插入节点，删除节点等动态操作的时候会影响到树的形态，可能致使树走向低效，影响后续操作的效率。今天就介绍一下二叉搜索树的一个变种——平衡二叉树(AVL)。AVL树是一种自平衡的二叉搜索树，在进行动态操作时可以维持自身形态的平衡，从而保证基本操作的时间复杂度维持在O(logn)。<br>下图为一个低效的二叉查找树的示意图，它已经退化成了链表，完全失去了二叉查找树的优势。<br><img src="/images/loweffective.gif" alt="低效的二叉查找树示意图"></p>
<h1 id="什么是平衡二叉树？"><a href="#什么是平衡二叉树？" class="headerlink" title="什么是平衡二叉树？"></a>什么是平衡二叉树？</h1><p>1962年，Adelson-Velsikii和Landis提出了一种结点在高度上相对平衡的二叉查找树，又称为AVL树。其平均和最坏情况下的查找时间都是O(logn)。同时，插入和删除的时间复杂性也会保持O(logn)。平衡二叉树的定义如下:</p>
<ul>
<li>它或者是一棵空二叉树。</li>
<li>或者是具有如下性质的二叉查找树：其左子树和右子树都是高度平衡的二叉树，且左子树和右子树的高度之差的绝对值不超过1。</li>
</ul>
<p>如果将二叉树上结点的<strong>平衡因子</strong>BF（Balanced Factor）定义为<strong>该结点的左子树与右子树的高度之差</strong>，根据AVL树的定义，AVL树中的任意结点的平衡因子只可能是-1（右子树高于左子树）、0或者1（左子树高于右子树）。</p>
<p>AVL树通过为每个节点设置并维护一个height(当前节点的高度)属性并且在执行动态操作的时候监控平衡因子BF的值，来监控自身的形态变化，从而实现<strong>自平衡</strong>。在动态操作执行后，如果某一个节点的BF值不在正常范围内(-1,0,1)时,AVL树自身可以通过<strong>旋转</strong>来调整子树的高度，使不符合AVL定义的部分重新符合定义。</p>
<h1 id="平衡二叉树的基本操作"><a href="#平衡二叉树的基本操作" class="headerlink" title="平衡二叉树的基本操作"></a>平衡二叉树的基本操作</h1><p>平衡二叉树本质上还是一棵二叉搜索树，所以在大多数的操作上两者是几乎相同的。唯一不同的是平衡二叉树在插入节点和删除节点等动态操作上增加了自平衡的操作(通过旋转)。以免和上一篇文章重复，在这里我们只讨论平衡二叉树的插入和删除操作。</p>
<p>要想实现平衡二叉树的带自平衡功能的插入和删除操作，我们首先要来研究一下AVL实现自平衡的机制－－<strong>旋转</strong>。</p>
<p>首先定义平衡二叉树节点结构体和几个功能宏函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEIGHT(n) (((n) == NULL) ? 0 : (n)-&gt;h)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) ((a) &lt; (b) ? (b) : (a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">avl_node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> h;　<span class="comment">//这里增加了h的属性，用来记录当前节点的高度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">avl_node</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">avl_node</span> *<span class="title">left</span>;</span></span><br><span class="line">&#125; node, *avl_node_ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_bf</span><span class="params">(avl_node_ptr node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> HEIGHT(node-&gt;left)-HEIGHT(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>在AVL树的平衡化操作中，存在两种基本旋转操作，左旋和右旋。在一次平衡化操作中，左旋和右旋这两个基本旋转操作可能被执行一次或多次。并且是从<strong>最小不平衡二叉树</strong>的根节点开始的。(即从离插入节点最近的，平衡因子超过1的祖先节点开始)</p>
<h3 id="单旋转"><a href="#单旋转" class="headerlink" title="单旋转"></a>单旋转</h3><p>1.右旋操作(LL_right_rotate)<br><img src="/images/ll.png" alt="右旋示意图"><br>如上图，新插入了节点1,我们从新插入的节点开始向上寻找它的祖先节点，发现了第一个失衡节点3。也就找到了这里的最小不平衡二叉树就是以3为根节点的那棵树。也就是<strong>新插入的节点出现在失衡节点的左孩子的左子树上</strong>,此时我们需要对他们进行右旋操作(LL_right_rotate)。如上图，将根节点的左孩子2提升为新的根节点,而旧的根节点3则作为新根节点2的右孩子存在。</p>
<p>下面看一个复杂一些的需要右旋的情况：<br><img src="/images/ll2.png" alt="右旋示意图"><br>新插入的节点为1,同样的，我们从1开始依次向上检查其祖先节点，第一个找到了5是不平衡的节点。由于新插入的节点1出现在失衡节点5的左孩子的左子树上，我们需要对其进行右旋操作(LL_right_rotate)。但这种情况似乎与上面那种简单情形不同。具体的旋转细节如下:<br><img src="/images/ll3.png" alt="右旋示意图"><br>我们仍然是将失衡节点5的左孩子3提升为新的根节点，旧的根节点5则作为3的右孩子，所增加的是:还需要将新根节点3原本的右孩子作为旧根节点5的左孩子。</p>
<p>仔细分析发现，复杂情况中所增加的操作在简单情况中就是将NULL挂到NULL上，也就是说上面的简单的情形和复杂的情形的本质是统一的，我们可以将这两种情况总结成下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//root为最小不平衡二叉树的根节点，插入的节点插在root的左孩子的左子树上</span></span><br><span class="line"><span class="comment">//需要将root的左孩子作为新的根节点,右旋</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> avl_node_ptr <span class="title">LL_right_rotate</span><span class="params">(avl_node_ptr root)</span></span>&#123;</span><br><span class="line">    avl_node_ptr new_root = root-&gt;left;</span><br><span class="line">    root-&gt;left = new_root-&gt;right;</span><br><span class="line">    new_root-&gt;right = root;</span><br><span class="line">    new_root-&gt;h = MAX(HEIGHT(new_root-&gt;left), HEIGHT(new_root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    root-&gt;h = MAX(HEIGHT(root-&gt;left), HEIGHT(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> new_root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.左旋操作(RR_left_rotate)<br>左旋和右旋是镜像对称的,当<strong>插入的节点位于离他最近的失衡节点的右孩子的右子树上</strong>时，我们就需要对其进行左旋操作(RR_left_rotate),示意图如下:<br><img src="/images/rr.png" alt="左旋示意图"><br>实现如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入的节点位于root的右孩子的右子树上，root的右孩子作为新的根节点，左旋</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> avl_node_ptr <span class="title">RR_left_rotate</span><span class="params">(avl_node_ptr root)</span></span>&#123;</span><br><span class="line">    avl_node_ptr new_root = root-&gt;right;</span><br><span class="line">    root-&gt;right = new_root-&gt;left;</span><br><span class="line">    new_root-&gt;left = root;</span><br><span class="line">    new_root-&gt;h = MAX(HEIGHT(new_root-&gt;left), HEIGHT(new_root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    root-&gt;h = MAX(HEIGHT(root-&gt;left), HEIGHT(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> new_root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复合旋转"><a href="#复合旋转" class="headerlink" title="复合旋转"></a>复合旋转</h3><p>1.先左旋再右旋(LR_left_right_rotate)<br><img src="/images/lr.png" alt><br>如上图所示，我们在树上插入了节点5,然后从5开始依次向上寻找失衡节点，找到失衡节点8,观察新插入的节点与该失衡节点的位置关系我们可以发现，<strong>新插入的节点位于其最近的失衡节点的左孩子的右子树上</strong>。这不是我们刚才讨论的单旋转中的任何一种情况，我们怎样才能将这种情况的树调整会平衡状态呢?如图，要调整这种情形，我们要<strong>首先将失衡节点的左子树进行左旋，然后对以失衡节点为根节点的树进行右旋</strong><br>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新插入的节点位于root的左孩子rootl的右子树上，</span></span><br><span class="line"><span class="comment">//那么首先需要先对以rootl为根节点的子树进行左旋(RR_left_rotate)</span></span><br><span class="line"><span class="comment">//然后对以root为根节点的子树进行右旋(LL_right_rotate)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> avl_node_ptr <span class="title">LR_left_right_rotate</span><span class="params">(avl_node_ptr root)</span></span>&#123;</span><br><span class="line">    root-&gt;left = RR_left_rotate(root-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> LL_right_rotate(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.先右旋再左旋(RL_right_left_rotate)<br>下面的这种情况是<strong>插入节点出现在离他最近的失衡节点的右孩子的左子树上</strong>,和上面的情况是对称的，这里直接给出代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同上</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> avl_node_ptr <span class="title">RL_right_left_rotate</span><span class="params">(avl_node_ptr root)</span></span>&#123;</span><br><span class="line">    root-&gt;right = LL_right_rotate(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> RR_left_rotate(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="再平衡"><a href="#再平衡" class="headerlink" title="再平衡"></a>再平衡</h2><p>上面在讨论旋转时讨论了四种失衡的场景以及每种场景对应的平衡调整方法，下面我们做个小小的总结:在代码中我们应该如何判定对应的失衡场景，又该如何调整呢？<strong>根据当前破坏平衡的结点的平衡因子，以及其孩子结点的平衡因子来判定，通过旋转来调整。</strong></p>
<p><img src="/images/all_avl.png" alt></p>
<table>
<thead>
<tr>
<th align="center">失衡场景</th>
<th align="center">判定准则</th>
<th align="center">调整方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LL型失衡</td>
<td align="center">current.bf&gt;1 &amp;&amp; current.left.bf&gt;0</td>
<td align="center">LL_right_rotate</td>
</tr>
<tr>
<td align="center">LR型失衡</td>
<td align="center">current.bf&gt;1 &amp;&amp; current.left.bf&lt;0</td>
<td align="center">LR_left_right_rotate</td>
</tr>
<tr>
<td align="center">RR型失衡</td>
<td align="center">current.bf&lt;-1 &amp;&amp; current.right.bf&lt;0</td>
<td align="center">RR_left_rotate</td>
</tr>
<tr>
<td align="center">RL型失衡</td>
<td align="center">current.bf&lt;-1 &amp;&amp; current.right.bf&gt;0</td>
<td align="center">RL_right_left_rotate</td>
</tr>
<tr>
<td align="center">由上，我们可以得出调整失衡的函数如下:</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node为当前失衡节点</span></span><br><span class="line"><span class="function">avl_node_ptr <span class="title">re_balance</span><span class="params">(avl_node_ptr node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node)</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    <span class="keyword">int</span> bf=get_bf(node);</span><br><span class="line">    <span class="keyword">int</span> bf_l=get_bf(node-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> bf_r=get_bf(node-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(bf&gt;<span class="number">1</span> &amp;&amp; bf_l&gt;<span class="number">0</span>)</span><br><span class="line">        node=LL_right_rotate(node);</span><br><span class="line">    <span class="keyword">if</span>(bf&gt;<span class="number">1</span> &amp;&amp; bf_l&lt;<span class="number">0</span>&gt;)</span><br><span class="line">        node=LR_left_right_rotate(node);</span><br><span class="line">    <span class="keyword">if</span>(bf&lt;<span class="number">-1</span> &amp;&amp; bf_r&lt;<span class="number">0</span>)</span><br><span class="line">        node=RR_left_rotate(node);</span><br><span class="line">    <span class="keyword">if</span>(bf&lt;<span class="number">-1</span> &amp;&amp; bf_r&gt;<span class="number">0</span>)</span><br><span class="line">        node=RL_right_left_rotate(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>有了上面的一些工具函数和平衡调整函数并且利用递归我们可以非常容易的实现插入和删除操作。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><iframe width="640" height="360" src="https://www.youtube.com/embed/ygZMI2YIcvk" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">avl_node_ptr <span class="title">avl_insert</span><span class="params">(avl_node_ptr node,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">        node=<span class="keyword">new</span> avl_node;</span><br><span class="line">        node-&gt;key=k;</span><br><span class="line">        node-&gt;height=<span class="number">1</span>;</span><br><span class="line">        node-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">        node-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;node-&gt;key)</span><br><span class="line">        node-&gt;left=avl_insert(node-&gt;left,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;node-&gt;key)</span><br><span class="line">        node-&gt;right=avl_insert(node-&gt;right,k);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"can't insert a key that already esixt!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先调整高度，然后再平衡</span></span><br><span class="line">    node-&gt;height=max(get_height(node-&gt;left),get_height(node-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    node=re_balance(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><iframe width="623" height="374" src="https://www.youtube.com/embed/4zQV3j2X9mU" frameborder="0" gesture="media" allow="encrypted-media" allowfullscreen></iframe>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">avl_node_ptr  <span class="title">avl_delete</span><span class="params">(avl_node_ptr node,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node)</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;node-&gt;key)</span><br><span class="line">        node-&gt;left=avl_delete(node-&gt;left,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;node-&gt;key)</span><br><span class="line">        node-&gt;right=avl_delete(node-&gt;right,k);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//找到需要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left==<span class="literal">NULL</span>||node-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//删除的节点只有一个孩子或者没有孩子</span></span><br><span class="line">            avl_node_ptr temp=(node-&gt;left==<span class="literal">NULL</span>)?node-&gt;right:node-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="comment">//没有孩子的情况</span></span><br><span class="line">                temp=node;</span><br><span class="line">                node=<span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//一个孩子</span></span><br><span class="line">                node=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//删除的节点有两个孩子</span></span><br><span class="line">            avl_node_ptr temp=node-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(temp-&gt;left!=<span class="literal">NULL</span>)<span class="comment">//找到node的右子树的最小关键字节点</span></span><br><span class="line">                temp=temp-&gt;left;</span><br><span class="line">            node-&gt;key=temp-&gt;key;</span><br><span class="line">            node-&gt;right=avl_delete(node-&gt;right,temp-&gt;key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    node-&gt;height=max(get_height(node-&gt;left),get_height(node-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> re_balance(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.geeksforgeeks.org/?p=17679" target="_blank" rel="noopener">GeeksforGeeks</a><br><a href="http://btechsmartclass.com/DS/U5_T2.html" target="_blank" rel="noopener">btechsmartclass</a><br><a href="http://www.cnblogs.com/penghuwan/p/8166133.html" target="_blank" rel="noopener">【算法】论平衡二叉树（AVL）的正确种植方法</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2018/01/07/binary-search-tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/07/binary-search-tree/" itemprop="url">二叉搜索树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-07T15:28:51+08:00">
                2018-01-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>二叉搜索树</code>(binary search tree)支持许多动态集合操作，包括插入节点构建树，查找(最大值，最小值，前驱，后继，指定值)节点，遍历(前中后序遍历)树，删除节点等。在树上进行的操作所花费的时间与树的高度成正比，对于有n的节点的一个完全二叉树，这些操作的最坏运行时间为Θ(lg n).但是如果这棵树是一个n个节点连接而成的线性链，那么同样的操作的最坏运行时间就为Θ(n).为了尽量避免这种低效的二叉树，可以在构造树时采用随机构造的方式。随机构造的二叉树的期望高度O(lg n),因此在这样的一棵二叉树上的操作的平均运行时间就为Θ(lg n).但实际上，随机化的构造树的方式也不能完全杜绝最坏情况的出现，所以还有一些二叉搜索树的变种，如红黑树，B树等，他们可以保证基本操作具有好的最坏情况性能。<br>在本文中，不讨论红黑树和B树，我们只讨论二叉搜索树的各种操作。</p>
<h1 id="什么是二叉搜索树"><a href="#什么是二叉搜索树" class="headerlink" title="什么是二叉搜索树?"></a>什么是二叉搜索树?</h1><p>一棵二叉搜索树就是以一个二叉树来组织的，树上的每一个节点就是一个对象，对象中除了key和卫星数据之外，还有用于维护二叉树结构的三个属性left,right,parent(在c语言中他们是三个指针),他们分别指向节点的左孩子，右孩子和父节点。其中key被称为节点的关键字，它是二叉搜索树中确定节点之间大小关系的关键属性，一般可以设置为整型类型。如果某一个节点的没有左孩子，右孩子或父节点，那么就将对应的属性指针置空即可。该树的根节点是整棵树中唯一一个parent属性为空的节点。这些置空的指针通常被用来确定树的边界。二叉搜索树之所以可以具有灵活高效的操作，是因为它具有如下的性质：</p>
<ul>
<li>如果节点的左子树不空，则左子树上所有结点的值均小于等于它的根结点的值；</li>
<li>如果节点的右子树不空，则右子树上所有结点的值均大于等于它的根结点的值；</li>
<li>任意节点的左、右子树也分别为二叉搜索树</li>
</ul>
<p><img src="/images/bst.png" alt="二叉搜索树示意图"></p>
<h1 id="二叉搜索树的基本操作"><a href="#二叉搜索树的基本操作" class="headerlink" title="二叉搜索树的基本操作"></a>二叉搜索树的基本操作</h1><p>本文重点讨论的就是二叉搜索树上的操作，下面我们来逐一的讨论。首先声明:为了减少讨论的复杂度，<code>假设树上的所有节点的关键字均不相同</code>，下面我的代码也基于此，对于节点关键字有重复的情况，调整代码即可。下面我们先定义节点的数据结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;<span class="comment">//节点数据,同时也是节点的关键字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面的为二叉搜索树的维护数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">parent</span>=<span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">left</span>=<span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">right</span>=<span class="title">NULL</span>;</span></span><br><span class="line">&#125;BST,*BST_p;</span><br></pre></td></tr></table></figure>

<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>我们想要实现在二叉搜索树上的操作，那么首先我们就需要构建出一棵二叉搜索树.我们可以从一个数组中构建二叉搜索树，逐个的从数组中读取数据，然后以插入的方式将数据插入到树中，即我们需要一个将数据插入到树中的操作。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><h4 id="递归插入"><a href="#递归插入" class="headerlink" title="递归插入"></a>递归插入</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归构造搜索二叉树</span></span><br><span class="line"><span class="comment"> * root：指向树的根节点的指针</span></span><br><span class="line"><span class="comment"> * k:待插入的key</span></span><br><span class="line"><span class="comment"> * parent:父节点的指针</span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bst_insert</span><span class="params">(BST_p&amp; root,<span class="keyword">int</span> k,BST_p parent=<span class="literal">NULL</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果当前二叉搜索树为空，则当前的待插入的值就为根节点中存放的值</span></span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        root=<span class="keyword">new</span> BST;</span><br><span class="line">        root-&gt;key=k;</span><br><span class="line">        root-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根节点没有父节点</span></span><br><span class="line">        root-&gt;parent=parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//关键字比root节点中存放的关键字大，那么该节点应该被存放在root节点的右子树</span></span><br><span class="line">        <span class="keyword">if</span>(k&gt;root-&gt;key)</span><br><span class="line">            bst_insert(root-&gt;right,k,root);</span><br><span class="line">        <span class="comment">//关键字比root节点中存放的关键字小，那么该节点应该被存放在root节点的左子树</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            bst_insert(root-&gt;left,k,root); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="非递归插入"><a href="#非递归插入" class="headerlink" title="非递归插入"></a>非递归插入</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归插入操作</span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bst_insert_nonRecur</span><span class="params">(BST_p&amp; root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    BST_p pre=<span class="literal">NULL</span>;<span class="comment">//记录上一个节点</span></span><br><span class="line">    BST_p t=root;<span class="comment">//不能直接使用root操作，这里的root为主函数中的全局root的引用，对他的更改会影响全局的root</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照规则找到key应该插入的位置，并用pre记录该位置的上一个节点</span></span><br><span class="line">    <span class="keyword">while</span>(t != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        pre = t;</span><br><span class="line">        <span class="keyword">if</span>(k &lt; t-&gt;key)&#123;</span><br><span class="line">            t = t-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            t = t-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BST_p node = <span class="keyword">new</span> BST;</span><br><span class="line">    node-&gt;key = k;</span><br><span class="line">    node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;parent = pre;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将node连接到树上</span></span><br><span class="line">    <span class="keyword">if</span>(pre == <span class="literal">NULL</span>)<span class="comment">//若为空树，node即为根节点</span></span><br><span class="line">        root = node;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//树非空，则判断node应该被连接到pre的左子树还是右子树</span></span><br><span class="line">        <span class="keyword">if</span>(k &lt; pre-&gt;key)&#123;</span><br><span class="line">            pre-&gt;left = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pre-&gt;right = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建二叉查找树"><a href="#构建二叉查找树" class="headerlink" title="构建二叉查找树"></a>构建二叉查找树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_bst</span><span class="params">(BST_p&amp; root,<span class="keyword">int</span> * a ,<span class="keyword">size_t</span> size)</span></span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        <span class="comment">// bst_insert(root,a[i]);</span></span><br><span class="line">        bst_insert_nonRecur(root,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了上面的这几个函数，我们就可以像下面这样来构建一个二叉搜索树：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    BST_p root=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">4</span>]=&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    init_bst(root,a,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//some operating</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>二叉搜索树的性质允许我们通过一个简单的递归算法来按序输出二叉搜索树中的所有关键字，这种算法称之为<strong>中序遍历</strong>(inorder walk tree),这样命名的原因是输出的子树根的关键字位于其左子树的递归调用语句和右子树的递归调用语句之间。类似的<strong>先序遍历</strong>，<strong>后续遍历</strong>也是根据关键字输出语句与其左右子树递归调用语句之间的先后关系确定的。<br>下面是三种遍历的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历二叉搜索树</span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder_tree_walk</span><span class="params">(BST_p root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        inorder_tree_walk(root-&gt;left);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;key&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        inorder_tree_walk(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历二叉树</span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder_tree_walk</span><span class="params">(BST_p root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;key&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        preorder_tree_walk(root-&gt;left);</span><br><span class="line">        preorder_tree_walk(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历二叉树</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder_tree_walk</span><span class="params">(BST_p root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        postorder_tree_walk(root-&gt;left);</span><br><span class="line">        postorder_tree_walk(root-&gt;right);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;key&lt;&lt;<span class="string">" "</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中的中序遍历可以按照从小到大的顺序依次输出树中所有节点的关键字。</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>在二叉查找树中可以快速的查找元素，下面我们就来看看在二叉查找树中各种查找操作都是如何进行的。</p>
<h3 id="查找最大值与最小值"><a href="#查找最大值与最小值" class="headerlink" title="查找最大值与最小值"></a>查找最大值与最小值</h3><p>找具有最值关键字的节点在二叉查找树中非常的直接。比如要找具有最小关键字的节点，我们可以从根节点一直向左查找，如果一个节点具有左孩子，那么它的左孩子的关键字一定比它本身的关键字小，这时就可以迭代的去查看其左孩子，直到某一节点的左孩子为空，这样就是找到了树中最左边的节点，也就具有最小关键字的节点。上述寻找最小值的代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找最小值，一直向左找，直到找到最左边的一个节点</span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="function">BST_p <span class="title">minimum</span><span class="params">(BST_p&amp; root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"该树为空，没有最小值!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        BST_p t=root;<span class="comment">//不能用root直接操作</span></span><br><span class="line">        <span class="comment">//找到最左边的那个节点</span></span><br><span class="line">        <span class="keyword">while</span>(t-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">            t=t-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>同理，找最大值的代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找最大值,一直向右找，直到找到最右边的一个节点</span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="function">BST_p <span class="title">maximum</span><span class="params">(BST_p&amp; root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"该树为空，没有最大值"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        BST_p t=root;<span class="comment">//不能用root直接操作</span></span><br><span class="line">        <span class="comment">//找到最右边的那个节点</span></span><br><span class="line">        <span class="keyword">while</span>(t-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">            t=t-&gt;right;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找前驱与后继"><a href="#查找前驱与后继" class="headerlink" title="查找前驱与后继"></a>查找前驱与后继</h3><p>给定一棵二叉搜索树中的节点，有时需要按照<strong>中序遍历</strong>的次序(从小到大)查找它的<strong>后继</strong>(successor)或<strong>前驱</strong>(predecessor)。找前驱和后继在逻辑上是对称的，我们这里以找一个节点的后继节点作为例子讲解。按照定义我们可以知道，找节点a的后继节点就是找树中关键字比a的关键字大的所有节点中的最小关键字节点(虽然很绕，但就是这个道理:)。如何才能找到它呢？我们需要分两种情况讨论:</p>
<ul>
<li><p>给定的节点a具有右孩子<br>在这种情况下，a的后继节点必定存在于a的右子树中，并且为右子树中的关键字最小节点。</p>
</li>
<li><p>给定的节点a没有右孩子<br>在这种情况下，a的后继节点在哪里呢？为了找到a的后继节点，我们就要从a节点开始追根溯源，向上找它的祖先，直到找到第一个这样的祖先s:s的左孩子s’也是ａ的祖先，那么节点s就是这种情况下a的后继节点。</p>
</li>
</ul>
<p>下面是上述两种找后继节点的示意图。声明:<code>这两张图片借自别人的博客</code>(读书人的东西怎么能叫偷呢:)!<br><img src="/images/bst_successor1.gif" alt="找后继1"><br><img src="/images/bst_successor2.gif" alt="找后继2"></p>
<p>下面是找后继节点的代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BST_p <span class="title">successor</span><span class="params">(BST_p node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">    <span class="comment">//有右孩子，直接返回指向右子树的最小关键字节点的指针</span></span><br><span class="line">        <span class="keyword">return</span> minimum(node-&gt;right);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//没有右孩子</span></span><br><span class="line">        BST_p p=node-&gt;parent;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;node!=p-&gt;left)&#123;</span><br><span class="line">            node=node-&gt;parent;</span><br><span class="line">            p=p-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找前驱节点的代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BST_p <span class="title">perdecessor</span><span class="params">(BST_p node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> maximum(node-&gt;left);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        BST_p p=node-&gt;parent;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;node!=p-&gt;right)&#123;</span><br><span class="line">            node=node-&gt;parent;</span><br><span class="line">            p=p-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找具有指定关键字的节点"><a href="#查找具有指定关键字的节点" class="headerlink" title="查找具有指定关键字的节点"></a>查找具有指定关键字的节点</h3><p>给定一个节点和一个关键字的值，找到树中关键字的值与给定值相等的节点。这个可以用递归和非递归两种方式实现。</p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找包含关键字k的节点，并返回指向该节点的指针</span></span><br><span class="line"><span class="comment"> * 这里假设树中的key不重复</span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="function">BST_p <span class="title">bst_search</span><span class="params">(BST_p&amp; root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span> || k==root-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;root-&gt;key)</span><br><span class="line">            <span class="keyword">return</span> bst_search(root-&gt;left,k);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> bst_search(root-&gt;right,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非递归查找</span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="function">BST_p <span class="title">bst_search_nonRecur</span><span class="params">(BST_p&amp; root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="comment">//为空时，直接返回NULL</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">//不为空</span></span><br><span class="line">    BST_p t=root;</span><br><span class="line">    <span class="keyword">while</span>(k!=t-&gt;key)&#123;<span class="comment">//依次遍历，直到k与t指向的key相等</span></span><br><span class="line">        <span class="keyword">if</span>(k&lt;t-&gt;key)<span class="comment">//如果k小于当前节点的key，那么就需要到当前节点的左子树中去找</span></span><br><span class="line">            t=t-&gt;left;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//如果k大于当前节点的key，那么就需要到当前节点的右子树中去找</span></span><br><span class="line">            t=t-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>给定一个树中的节点a，要求删除该节点并且保持二叉搜索树的结构。删除这一操作根据给定节点a的情况的不同，可分成一下三种情况讨论:</p>
<ul>
<li>节点a没有孩子节点<br>对于节点a没有孩子节点的情况，我们只需要做以下操作：通过比较a节点的关键字与其父结点的关键字大小从而确定a节点是其父结点的左孩子还是右孩子，然后将a的父节点的对应指针置空，并且释放a所指向节点所占用的内存。<br><img src="/images/delete0.gif" alt="示意图"></li>
<li>节点a只有一个孩子节点<br>对这种情况，首先要确定a是其父结点的左孩子还是右孩子，然后根据此信息将a的父节点的对应指针指向a的那个唯一的孩子节点，并且将a的孩子节点的父指针指向a的父节点，最后释放a所指向的节点占用的内存。<br><img src="/images/delete1.gif" alt="示意图"></li>
<li>节点a有两个孩子节点<br>首先找到节点a的后继节点b，然后根据b是否是a的右孩子分两种情况讨论：</li>
</ul>
<p>1.b是a的右孩子<br>如果b是a的右孩子，将b提升到a节点的位置，并且将原来a节点的左子树，连接到b节点的左支上(b节点的左支初始时为空)，最后释放a所指向的节点的内存。<br><img src="/images/delete21.gif" alt="示意图"><br>2.b不是a的右孩子<br>首先将b节点的右孩子提升到b的位置，即将b的右孩子连接到b的父节点的左支上(想一想为什么一定是左支上呢?因为b是a的后继节点，而且现在的讨论又是在b不是a的右孩子的基础上)。然后将原来a节点的左子树连接到b节点的左支上(该支初始时为空)，最后将b提升到a的位置，并且释放a节点占用的内存。<br><img src="/images/delete22.gif" alt="示意图"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉查找树删除node指向的节点</span></span><br><span class="line"><span class="comment"> **/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bst_delete</span><span class="params">(BST_p node)</span></span>&#123;</span><br><span class="line">    <span class="comment">//node没有孩子节点</span></span><br><span class="line">    <span class="keyword">if</span>(node-&gt;left==<span class="literal">NULL</span>&amp;&amp;node-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        BST_p p=node-&gt;parent;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;key&lt;p-&gt;key)<span class="comment">//这里说明node节点是其父节点的左节点</span></span><br><span class="line">            p-&gt;left=<span class="literal">NULL</span>;<span class="comment">//置空左指针</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p-&gt;right=<span class="literal">NULL</span>;<span class="comment">//置空右指针</span></span><br><span class="line">        <span class="comment">//释放node指向的内存块的内存</span></span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//node只有一个孩子节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;left==<span class="literal">NULL</span> || node-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        BST_p p=node-&gt;parent;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;key&gt;p-&gt;key)&#123;<span class="comment">//node是p的右孩子</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                p-&gt;right=node-&gt;left;</span><br><span class="line">                node-&gt;left-&gt;parent=p;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p-&gt;right=node-&gt;right;</span><br><span class="line">                node-&gt;right-&gt;parent=p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                p-&gt;left=node-&gt;left;</span><br><span class="line">                node-&gt;left-&gt;parent=p;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                p-&gt;left=node-&gt;right;</span><br><span class="line">                node-&gt;right-&gt;parent=p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//node有两个孩子节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;left!=<span class="literal">NULL</span>&amp;&amp; node-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        BST_p left=node-&gt;left;<span class="comment">//左子树的根节点</span></span><br><span class="line">        BST_p right=node-&gt;right;<span class="comment">//右子树的根节点</span></span><br><span class="line">        BST_p parent=node-&gt;parent;<span class="comment">//父节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//node节点的后继节点,由于存在右子树，所以这里直接使用了求右子树的最小节点的函数</span></span><br><span class="line">        BST_p successor=minimum(right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后继节点就是node的右孩子，这里假设树中不存在key值相同的节点</span></span><br><span class="line">        <span class="keyword">if</span>(successor-&gt;key==right-&gt;key)&#123;</span><br><span class="line">            <span class="comment">//将node的左支连接到后继节点的左孩子上(初始时该节点为空)</span></span><br><span class="line">            successor-&gt;left=left;</span><br><span class="line">            left-&gt;parent=successor;</span><br><span class="line">            <span class="comment">//将后继节点提升到node的位置</span></span><br><span class="line">            <span class="comment">//这里首先需要判断node是其父节点的左孩子还是右孩子</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;key&gt;parent-&gt;key)&#123;</span><br><span class="line">                <span class="comment">//node是其父节点的右节点</span></span><br><span class="line">                parent-&gt;right=successor;</span><br><span class="line">                successor-&gt;parent=parent;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="comment">//node是其父节点的左节点</span></span><br><span class="line">                parent-&gt;left=successor;</span><br><span class="line">                successor-&gt;parent=parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//后继节点successor不是node的右孩子</span></span><br><span class="line">            <span class="comment">//首先将successor的右节点提升到successor的位置，然后将node的左支连接到</span></span><br><span class="line">            <span class="comment">//successor的左支上(初始为空支)，然后将successor提升到node的位置</span></span><br><span class="line"></span><br><span class="line">            BST_p succ_parent=successor-&gt;parent;<span class="comment">//后继节点的父节点</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//这里后继节点一定位于其父节点的左支，所以直接将后继节点的右节点连接到</span></span><br><span class="line">            <span class="comment">//后继节点的父节点的左支上</span></span><br><span class="line">            succ_parent-&gt;left=successor-&gt;right;</span><br><span class="line">            successor-&gt;right-&gt;parent=succ_parent;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将node的左子树连接到后继节点的左支上(该支初始时为空)</span></span><br><span class="line">            successor-&gt;left=left;</span><br><span class="line">            left-&gt;parent=successor;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将successor提升到node的位置，同样的需要判断node位于其父结点的左还是右</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;key&gt;parent-&gt;key)&#123;</span><br><span class="line">                <span class="comment">//node是其父节点的右节点</span></span><br><span class="line">                parent-&gt;right=successor;</span><br><span class="line">                successor-&gt;parent=parent;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="comment">//node是其父节点的左节点</span></span><br><span class="line">                parent-&gt;left=successor;</span><br><span class="line">                successor-&gt;parent=parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="随机构建"><a href="#随机构建" class="headerlink" title="随机构建"></a>随机构建</h1><p>在文章开头介绍了，如果一棵二叉树是一个n个节点连接而成的线性链，那么该二叉树的效率就极其的低下，它就与链表无异了，无法发挥出搜索二叉树的威力。就拿我们上面的<code>init_bst</code>函数为例吧，我们是以用户提供的数组来初始化我们的二叉搜索树的，假如用户提供了这样的一个数组{1,2,3,4,5},或者是这样的{9,8,6,4,3,2}，大家想想我们给构造出来的是一什么样的二叉树呢？第一个数组构造出来的二叉搜索树的每个节点只有右孩子没有左孩子，而第二个构造出来的二叉搜索树的每个节点则只有左孩子没有右孩子。这就是极其低效的二叉树。怎样去避免这样的问题呢？</p>
<p>显然，我们不应该对用户的输入做任何限制，那么我们就只能改变自己来适应用户了:)。我们可以在用户提供的数组中通过不重复无遗漏的随机取元素的方法来构造一个随机序列，然后用该序列来构造一个随机二叉搜索树。代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span>  </span>&#123;  </span><br><span class="line">	<span class="keyword">int</span> tmp = a;  </span><br><span class="line">	a = b;  </span><br><span class="line">	b = tmp;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">random_init_bst</span><span class="params">(BST_p&amp; root,<span class="keyword">int</span> * a ,<span class="keyword">size_t</span> size)</span></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=size<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = rand() % (i+<span class="number">1</span>);	</span><br><span class="line">        bst_insert_nonRecur(root,a[j]);<span class="comment">//插入</span></span><br><span class="line">        swap(arr[j], arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述随机构建二叉搜索树的方法，在初始化构建树的时候，确实可以降低因用户给定的数组有序而创建低效二叉搜索树的情况，但是它无法做出保证。并且我们在对二叉搜索树这一动态集合进行插入删除等动态操作时，搜索二叉树的形态仍然可能走向低效。前面的动态操作会降低后面操作的效率。怎么办呢?这就要看其他的一些二叉搜索树的变体了！</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>Introduction to Algorithm (Third Edition)<br><a href="https://lufficc.com/blog/binary-search-tree" target="_blank" rel="noopener">多动态图详细讲解二叉搜索树聪聪的个人网站</a><br><a href="https://songlee24.github.io/2015/01/13/binary-search-tree/" target="_blank" rel="noopener">二叉查找树（BST） | 神奕的博客</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2017/11/26/Web-Crawler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/26/Web-Crawler/" itemprop="url">木犀后端分享——网络爬虫</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-26T12:58:51+08:00">
                2017-11-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="网络基础知识"><a href="#网络基础知识" class="headerlink" title="网络基础知识"></a>网络基础知识</h1><h2 id="先来两张图撑场子！"><a href="#先来两张图撑场子！" class="headerlink" title="先来两张图撑场子！"></a>先来两张图撑场子！</h2><p><img src="/images/%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="计算机网络体系结构"></p>
<p><img src="/images/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="信息处理流程"></p>
<p>计算机网络体系结构是分层的，分层的目的就是为了各司其职，每一层协议就负责处理好自己的工作，而不用去担心别人的事情。</p>
<h2 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h2><blockquote>
<p>从字面意义上讲，有人可能会认为TCP/IP是指TCP和IP两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。具体来说，IP或ICMP、TCP或UDP、TELNET或FTP、以及HTTP等都属于TCP/IP协议。他们与TCP或IP的关系紧密，是互联网必不可少的组成部分。TCP/IP 一词泛指这些协议，因此，有时也称 TCP/IP为网际协议群。</p>
</blockquote>
<p>就我本人的理解，TCP/IP就代表着一大堆的协议，这些协议就是具体负责网络中信息的传递。他们确保了数据可以被准确无误的传输到目的地。既传的远又传的准。也就是说，TCP/IP就帮你<strong>完美的解决了数据传输的问题</strong>，其他的协议就不需要再考虑数据传不远，传不到的问题了。</p>
<p>更多详细的内容看－&gt;<a href="http://www.jianshu.com/p/9f3e879a4c9c" target="_blank" rel="noopener">TCP/IP协议</a>，上面的引用也出自此处。</p>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><blockquote>
<p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。<br>HTTP是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。在Internet上的Web服务器上存放的都是超文本信息，客户机需要通过HTTP协议传输所要访问的超文本信息。HTTP包含命令和传输信息，不仅可用于Web访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。</p>
</blockquote>
<p>HTTP协议是构建在TCP/IP协议之上的应用层的协议，它不必再关心数据的是否可以准确无误的到达目的地的问题，它关心和解决的是<strong>在什么时候传什么数据给谁</strong>的问题。</p>
<p>更多详细内容请看－&gt;<a href="http://www.jianshu.com/p/6e9e4156ece3" target="_blank" rel="noopener">HTTP协议</a>,上面的引用也出自此处。</p>
<h1 id="网络爬虫简介"><a href="#网络爬虫简介" class="headerlink" title="网络爬虫简介"></a>网络爬虫简介</h1><p><strong>网络爬虫</strong>:又被称为网页蜘蛛，网络机器人等。是一种按照一定的规则，<strong>自动</strong>地抓取万维网信息的程序或者脚本。大家可以理解为在网络上爬行的一只蜘蛛。互联网就比作一张大网，而爬虫便是在这张网上爬来爬去的蜘蛛，如果它遇到资源，那么它就会抓取下来。想抓取什么？这个由你来控制它。爬虫技术是数据挖掘,测试技术的重要组成部分，是搜索引擎技术的核心。</p>
<p>说白了,爬虫技术就是一种<strong>自动化</strong>去请求下载并处理网络信息资源(html页面,css,js,pdf,word,excel，图片，音视频等)的技术。在实际中处理的比较多的网络信息资源是html页面，然后获取页面中有价值的文字信息。</p>
<p>要学好网络爬虫我们就需要解决两个问题:怎样下载？怎样处理？</p>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><h2 id="去哪里下载？"><a href="#去哪里下载？" class="headerlink" title="去哪里下载？"></a>去哪里下载？</h2><p>网络信息资源分布在服务提供者的服务器上，我们要去下载它，第一个要解决的问题就是要知道它在哪里。</p>
<h3 id="URL-URI-URN是什么鬼？"><a href="#URL-URI-URN是什么鬼？" class="headerlink" title="URL,URI,URN是什么鬼？"></a>URL,URI,URN是什么鬼？</h3><p><strong>URL</strong>:(Uniform Resource Locator,统一资源定位符)是一个Web地址，用来在Web上定位一个文档，或者调用一个CGI程序来为客户端生成一个文档。<br><strong>URI</strong>:(Uniform Resource Identifier,统一资源标识符)是URL的超集，可以应对将来可能出现的标识符命名约定。一个URL是一个简单的URI,它使用已有的协议或方案(http,ftp等)作为地址的一部分。<br><strong>URN</strong>:(Uniform Resource Name,统一资源名称)URN用来描述非URL的URI,只作为可能会用到的XML标识符。</p>
<p><code>URI = URL + URN</code><br>现在唯一使用的URI只有URL,而很少听到URI和URN.</p>
<p>我们在浏览器的地址栏里输入的网站地址就是URL。就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。当你在浏览器的地址框中输入一个URL或是单击一个超级链接时，URL就确定了要浏览的地址。浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。</p>
<h3 id="URL的组成"><a href="#URL的组成" class="headerlink" title="URL的组成"></a>URL的组成</h3><p>URL使用这种格式：<br><code>protocol_schema://net_location/path;params?query#frag</code></p>
<table>
<thead>
<tr>
<th align="center">URL组件</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">protocol_schema</td>
<td align="center">网络协议或下载方案</td>
</tr>
<tr>
<td align="center">net_location</td>
<td align="center">服务器所在地(也许含有用户信息)</td>
</tr>
<tr>
<td align="center">path</td>
<td align="center">使用’/‘分割的文件的路径或CGI应用的路径</td>
</tr>
<tr>
<td align="center">params</td>
<td align="center">可选参数</td>
</tr>
<tr>
<td align="center">query</td>
<td align="center">连接符’&amp;’分割的一系列键值对</td>
</tr>
<tr>
<td align="center">frag</td>
<td align="center">指定文档内特定锚的部分</td>
</tr>
</tbody></table>
<p>net_location可以进一步拆分成多个组件:<br><code>user:password@host:port</code></p>
<table>
<thead>
<tr>
<th align="center">net_location组件</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">user</td>
<td align="center">用户名</td>
</tr>
<tr>
<td align="center">password</td>
<td align="center">用户密码</td>
</tr>
<tr>
<td align="center">host</td>
<td align="center">运行web服务器的节点地址(必须的)</td>
</tr>
<tr>
<td align="center">port</td>
<td align="center">端口号(如果没有则默认为80)</td>
</tr>
</tbody></table>
<p>在net_location的四个组件中host最为重要，port只有在web服务器运行其他非默认端口号时才会使用，用户名和密码只有在使用FTP连接是才有可能用到，而即便是FTP，大多数的连接都是匿名的，这时不需要用户名和密码。</p>
<h2 id="用什么下载？"><a href="#用什么下载？" class="headerlink" title="用什么下载？"></a>用什么下载？</h2><h3 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h3><p>urllib是python标准库提供的一个高级的Web通信库，支持基本的Web协议，如Http,Ftp,Gopher,同时也支持对本地文件的访问。具体来说urllib模块的功能就是利用这些协议从因特网，局域网，本地主机上下载数据。</p>
<h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="comment">#下面的这种导入是错误的：</span></span><br><span class="line"><span class="comment">#import urllib</span></span><br></pre></td></tr></table></figure>

<h4 id="下载并保存你的第一个网页"><a href="#下载并保存你的第一个网页" class="headerlink" title="下载并保存你的第一个网页"></a>下载并保存你的第一个网页</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line">file=request.urlopen(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">myfirstpage=file.read()</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"myfirstpage.html"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(myfirstpage)</span><br></pre></td></tr></table></figure>

<p>urlopen()传入一个URL string,会打开这个string所指向的url,下载对应的网页，返回该网页的文件对象(这里我把它赋值给了file变量)。如果没有给定协议或者下载方案，或者传入‘file’方案，urlopen()会打开一个本地文件。</p>
<p>urlopen()返回的文件对象(即上面代码中的file)还有一些实用方法：</p>
<table>
<thead>
<tr>
<th align="center">urlopen()返回的对象的方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">file.read([bytes])</td>
<td align="center">从file中读出所有或者bytes个字节，以字符串返回</td>
</tr>
<tr>
<td align="center">file.readline()</td>
<td align="center">从file中读取一行，以字符串返回</td>
</tr>
<tr>
<td align="center">file.readlines()</td>
<td align="center">从file中读出所有行，以列表返回，每一行作为列表中的一项</td>
</tr>
<tr>
<td align="center">file.close()</td>
<td align="center">关闭file的url连接</td>
</tr>
<tr>
<td align="center">file.fileno()</td>
<td align="center">返回file的文件句柄</td>
</tr>
<tr>
<td align="center">file.info()</td>
<td align="center">获得file的MIME头文件</td>
</tr>
<tr>
<td align="center">file.geturl()</td>
<td align="center">返回当前请求的url</td>
</tr>
<tr>
<td align="center">file.getcode()</td>
<td align="center">返回响应的状态码</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line">f=request.urlopen(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">print(f.fileno())</span><br><span class="line">print(f.getcode())</span><br><span class="line">print(f.geturl())</span><br><span class="line">print(f.info())</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">200</span><br><span class="line">http://www.baidu.com</span><br><span class="line">Date: Wed, 29 Nov 2017 03:58:52 GMT</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: Close</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Set-Cookie: BAIDUID=B06CDC6F062BA8B6D50F401E830F6B5A:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com</span><br><span class="line">Set-Cookie: BIDUPSID=B06CDC6F062BA8B6D50F401E830F6B5A; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com</span><br><span class="line">Set-Cookie: PSTM=1511927932; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com</span><br><span class="line">Set-Cookie: BDSVRTM=0; path=/</span><br><span class="line">Set-Cookie: BD_HOME=0; path=/</span><br><span class="line">Set-Cookie: H_PS_PSSID=1440_19036_21116_18560_17001_25178_25145_22157; path=/; domain=.baidu.com</span><br><span class="line">P3P: CP=&quot; OTI DSP COR IVA OUR IND COM &quot;</span><br><span class="line">Cache-Control: private</span><br><span class="line">Cxy_all: baidu+14ee1d71cc2cf84997fda3c20bcc1684</span><br><span class="line">Expires: Wed, 29 Nov 2017 03:58:18 GMT</span><br><span class="line">X-Powered-By: HPHP</span><br><span class="line">Server: BWS/1.1</span><br><span class="line">X-UA-Compatible: IE=Edge,chrome=1</span><br><span class="line">BDPAGETYPE: 1</span><br><span class="line">BDQID: 0xe0db52f000003afc</span><br><span class="line">BDUSERID: 0</span><br></pre></td></tr></table></figure>

<h4 id="更优雅的下载并保存"><a href="#更优雅的下载并保存" class="headerlink" title="更优雅的下载并保存"></a>更优雅的下载并保存</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="comment">#下载并保存</span></span><br><span class="line">filename,mime_hdrs=request.urlretrieve(url=<span class="string">'http://www.douban.com'</span>,filename=<span class="string">"mysecondpage.html"</span>)</span><br><span class="line"><span class="comment">#清除缓存</span></span><br><span class="line">request.urlcleanup()</span><br></pre></td></tr></table></figure>

<p>urlretrieve()函数只需要传入资源对应的url和要将其保存在本地的位置，就可以实现下载并保存。这个方法不仅可以实现html页面的下载保存，对于所有网络信息资源都可以，包括图片，视音频等。</p>
<p>urlretrieve()执行的过程中会产生一些缓存，如果我们想要清除这些缓存信息，可以使用urlcleanup()进行清除。</p>
<h4 id="url的编码"><a href="#url的编码" class="headerlink" title="url的编码"></a>url的编码</h4><p>一般来说，必须要对某些不能打印的或者不被web服务器作为有效URL接收的特殊字符串进行转换。在一个URL中，逗号，下划线，句号，斜线，字母，数字这类符号不需要转化，其他的均需要转化。转换过程中那些url不能使用的字符前面会被加上%,同时转换成16进制，例如”=”将被转换成’%3d’,’3d’就是’=’的ASCLL码的16进制。urllib.request中提供的url转换的api就三个<code>quote()</code>,<code>unquote()</code>,<code>unquote_to_bytes()</code>，后两个做相反的工作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line">sourceUrl=<span class="string">"http://www.baidu.com/?key1=hhh&amp;key2=a b"</span></span><br><span class="line">quoteUrl=request.quote(sourceUrl)</span><br><span class="line"><span class="comment"># http%3A//www.baidu.com/%3Fkey1%3Dhhh%26key2%3Da%20b</span></span><br><span class="line">unquoteUrl=request.unquote(quoteUrl)</span><br><span class="line"><span class="comment"># http://www.baidu.com/?key1=hhh&amp;key2=a b</span></span><br><span class="line">unquotetobyte=request.unquote_to_bytes(quoteUrl)</span><br><span class="line"><span class="comment"># b'http://www.baidu.com/?key1=hhh&amp;key2=a b'</span></span><br></pre></td></tr></table></figure>

<p>Tips：如果你在写爬虫时遇到类似下面的保错：<br>UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position 14-15: ordinal not in range(128)<br>基本上就说明你的url需要转换了。如果你的url有中文，那就一定错了。一般来说，我们在浏览器地址栏中复制url时，浏览器就已经帮你做好转换了，所以一般不会遇到这种问题。但是，在自己构造url时就需要注意了。</p>
<h4 id="url参数的编码"><a href="#url参数的编码" class="headerlink" title="url参数的编码"></a>url参数的编码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line">d=&#123;<span class="string">'a'</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="string">"h?h"</span>,<span class="string">'c'</span>:<span class="string">"哈哈"</span>&#125;</span><br><span class="line">print(urlencode(d))</span><br><span class="line"><span class="comment">#输出　c=%E5%93%88%E5%93%88&amp;a=1&amp;b=h%3Fh</span></span><br></pre></td></tr></table></figure>

<p>urllib.parse.urlencode()可以从一个字典构造出查询字符串，并且自动做了url编码。</p>
<h4 id="urllib请求头的添加"><a href="#urllib请求头的添加" class="headerlink" title="urllib请求头的添加"></a>urllib请求头的添加</h4><p>在urllib中添加请求头有两种方式，使用<code>build_opener()</code>,使用<code>add_header()</code><br>1.使用build_opener()</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line">headers=[(<span class="string">"Accept"</span>,<span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8"</span>),</span><br><span class="line">    (<span class="string">"User-Agent"</span>,<span class="string">"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.89 Safari/537.36"</span>)]</span><br><span class="line">opener=request.build_opener()</span><br><span class="line">opener.addheader=headers</span><br><span class="line">data=opener.open(<span class="string">"http://www.baidu.com"</span>).read()</span><br></pre></td></tr></table></figure>

<p>2.使用add_header()</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line">headers=[(<span class="string">"Accept"</span>,<span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8"</span>),</span><br><span class="line">    (<span class="string">"User-Agent"</span>,<span class="string">"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.89 Safari/537.36"</span>)]</span><br><span class="line">req=request.Request(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">req.add_header(headers)</span><br><span class="line">data=request.urlopen(req).read()</span><br></pre></td></tr></table></figure>

<h4 id="代理服务器的设置"><a href="#代理服务器的设置" class="headerlink" title="代理服务器的设置"></a>代理服务器的设置</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line">proxy=request.ProxyHandler(&#123;<span class="string">"http"</span>:<span class="string">"localhost:9999"</span>&#125;)</span><br><span class="line">opener=request.build_opener(proxy,request.HTTPHandler)</span><br><span class="line">request.install_opener(opener)</span><br><span class="line">data=request.urlopen(<span class="string">"http://www.baidu.com"</span>).read()</span><br></pre></td></tr></table></figure>

<h3 id="神器——urllib3"><a href="#神器——urllib3" class="headerlink" title="神器——urllib3"></a>神器——urllib3</h3><p><a href="https://urllib3.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">urllib3</a></p>
<blockquote>
<p>urllib3 is a powerful, sanity-friendly HTTP client for Python. Much of the Python ecosystem already uses urllib3 and you should too. urllib3 brings many critical features that are missing from the Python standard libraries:</p>
</blockquote>
<ul>
<li>Thread safety.</li>
<li>Connection pooling.</li>
<li>Client-side SSL/TLS verification.</li>
<li>File uploads with multipart encoding.</li>
<li>Helpers for retrying requests and dealing with HTTP redirects.</li>
<li>Support for gzip and deflate encoding.</li>
<li>Proxy support for HTTP and SOCKS.</li>
<li>100% test coverage.</li>
</ul>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="第一个urllib3例子"><a href="#第一个urllib3例子" class="headerlink" title="第一个urllib3例子"></a>第一个urllib3例子</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">http=urllib3.PoolManager()</span><br><span class="line">response=http.request(<span class="string">'GET'</span>,<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">print(response.headers)</span><br><span class="line">print(response.status)</span><br><span class="line">print(response.data.decode(<span class="string">"utf-8"</span>))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTPHeaderDict(&#123;&apos;Set-Cookie&apos;: &apos;BAIDUID=DAB4C909697193545FA8395524CF0963:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com, BIDUPSID=DAB4C909697193545FA8395524CF0963; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com, PSTM=1511944442; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com&apos;, &apos;Server&apos;: &apos;BWS/1.1&apos;, &apos;Cache-control&apos;: &apos;no-cache&apos;, &apos;Last-Modified&apos;: &apos;Wed, 22 Nov 2017 02:22:00 GMT&apos;, &apos;P3P&apos;: &apos;CP=&quot; OTI DSP COR IVA OUR IND COM &quot;&apos;, &apos;Accept-Ranges&apos;: &apos;bytes&apos;, &apos;Date&apos;: &apos;Wed, 29 Nov 2017 08:34:02 GMT&apos;, &apos;Content-Type&apos;: &apos;text/html&apos;, &apos;X-UA-Compatible&apos;: &apos;IE=Edge,chrome=1&apos;, &apos;Connection&apos;: &apos;Keep-Alive&apos;, &apos;Content-Length&apos;: &apos;14613&apos;, &apos;Pragma&apos;: &apos;no-cache&apos;, &apos;Vary&apos;: &apos;Accept-Encoding&apos;&#125;)</span><br><span class="line">200</span><br><span class="line">&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">......此处省略部分输出</span><br></pre></td></tr></table></figure>

<h5 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h5><p>如上面的例子所示，你需要通过一个PoolManager实例来发起请求，这个实例对象会处理所有的和连接池，线程安全有关的细节。然后在这个PoolManager对象上调用request()方法，就可以发起请求。request()方法返回一个HttpResponse对象。通过该对象可以获取响应的内容。</p>
<h5 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h5><p>request()方法返回的HttpResponse对象有status,data和headers三个属性，分别来获取响应的状态码，响应的数据，和响应头。其中data属性获取的是bytes类型的数据，我们要使用它就要先对它进行解码(decode).</p>
<h5 id="请求头的设置"><a href="#请求头的设置" class="headerlink" title="请求头的设置"></a>请求头的设置</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">http=urllib3.PoolManager()</span><br><span class="line">response=http.request(<span class="string">'GET'</span>,<span class="string">"http://www.baidu.com"</span>,headers=&#123;<span class="string">'X-Something'</span>: <span class="string">'value'</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>请求头的信息在request()方法的headers参数中设置。</p>
<h5 id="查询参数的设置"><a href="#查询参数的设置" class="headerlink" title="查询参数的设置"></a>查询参数的设置</h5><p>对于GET,HEAD,DELETE请求，你可以直接将参数作为一个字典传个request()的fields参数，就像下面这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">http=urllib3.PoolManager()</span><br><span class="line">response=http.request(<span class="string">'GET'</span>,<span class="string">"http://www.baidu.com"</span>,fields=&#123;<span class="string">'arg'</span>: <span class="string">'value'</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>但对于POST和PUT请求，你需要手动的编码查询参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line">http=urllib3.PoolManager()</span><br><span class="line">encoded_args = urlencode(&#123;<span class="string">'arg'</span>: <span class="string">'value'</span>&#125;)</span><br><span class="line">url = <span class="string">'http://httpbin.org/post?'</span> + encoded_args</span><br><span class="line">response = http.request(<span class="string">'POST'</span>, url)</span><br></pre></td></tr></table></figure>

<h5 id="提交表单数据"><a href="#提交表单数据" class="headerlink" title="提交表单数据"></a>提交表单数据</h5><p>就表单数据而言，主要使用的是POST,PUT两种提交方式，urllib3会自动的编码fields参数提供的字典。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">response = http.request(<span class="string">'POST'</span>,<span class="string">'http://httpbin.org/post'</span>,fields=&#123;<span class="string">'field'</span>: <span class="string">'value'</span>&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="发送JSON给服务器"><a href="#发送JSON给服务器" class="headerlink" title="发送JSON给服务器"></a>发送JSON给服务器</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">http=urllib3.PoolManager()</span><br><span class="line">data = &#123;<span class="string">'attribute'</span>: <span class="string">'value'</span>&#125;</span><br><span class="line">encoded_data = json.dumps(data).encode(<span class="string">'utf-8'</span>)</span><br><span class="line">r = http.request(<span class="string">'POST'</span>,<span class="string">'http://httpbin.org/post'</span>,body=encoded_data,headers=&#123;<span class="string">'Content-Type'</span>:<span class="string">'application/json'</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>将需要发送给服务器的json数据编码后传递给request()的body参数，然后在请求头中设置Content-Type字段为application/json.</p>
<h5 id="发送文件或二进制数据"><a href="#发送文件或二进制数据" class="headerlink" title="发送文件或二进制数据"></a>发送文件或二进制数据</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'example.txt'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    file_data = fp.read()</span><br><span class="line">r = http.request(<span class="string">'POST'</span>,<span class="string">'http://httpbin.org/post'</span>,fields=&#123;<span class="string">'filefield'</span>: (<span class="string">'example.txt'</span>, file_data,<span class="string">'text/plain'</span>)&#125;)</span><br></pre></td></tr></table></figure>

<p>在fields中的filefield对应的元组中，文件名的指定并不是严格必须的。为了匹配浏览器的行为，强烈建议在这个元组中传递第三个参数来指明文件的MIME类型。</p>
<p>对于原始二进制数据(raw binary data)的发送可以简单的指定body参数。同样为了匹配浏览器的行为，建议要设置请求头中的Content-Type字段。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'example.jpg'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">     binary_data = fp.read()</span><br><span class="line">r = http.request(<span class="string">'POST'</span>,<span class="string">'http://httpbin.org/post'</span>,body=binary_data,headers=&#123;<span class="string">'Content-Type'</span>: <span class="string">'image/jpeg'</span>&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="设置证书验证"><a href="#设置证书验证" class="headerlink" title="设置证书验证"></a>设置证书验证</h5><p>官方强烈建议我们总是使用<a href="https://zh.wikipedia.org/wiki/傳輸層安全性協定" target="_blank" rel="noopener">SSL</a>证书验证。这样能够保证我们与服务器之间的通信的安全。默认情况下，urllib3不验证HTTPS请求。<br>为了启用验证你需要一些根证书。最简单和最可靠的方法是使用<strong>certifi</strong>包。这个包提供了Mozilla的根证书包。在使用之前需要安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip3 install certifi</span><br></pre></td></tr></table></figure>

<p>如果你在安装urllib3时使用了下面的命令，那么你的系统中就已经安装了certifi:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip3 install urllib3[secure]</span><br></pre></td></tr></table></figure>

<p>这条命令在安装urllib3的同时会安装certifi.<br>如果你使用的是python2可能会需要其他的一些包。</p>
<p>一旦你安装了证书验证所需要的依赖，你在创建PoolManager对象的时候，就可以传入相应的参数，在请求的时候来启用证书验证。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> certifi</span><br><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">http=urllib3.PoolManager(cert_reqs=<span class="string">"CERT_REQUIRED"</span>,ca_certs=certifi.where())</span><br><span class="line"><span class="comment">#下面请求https://google.com</span></span><br><span class="line">http.request(<span class="string">"GET"</span>,<span class="string">'https://google.com'</span>)<span class="comment">#没有任何错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面请求https://expired.badssl.com</span></span><br><span class="line">http.request(<span class="string">"GET"</span>,<span class="string">'https://expired.badssl.com'</span>)</span><br><span class="line"><span class="comment">#抛出urllib3.exceptions.SSLError：[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:645)的错误，说明该网站没有配置安全证书。</span></span><br></pre></td></tr></table></figure>

<p>在实例化PoolManager对象时做出上述配置后，PoolManager对象就会自动处理证书验证，如果验证失败就会抛出urllib3.exceptions.SSLError的异常。</p>
<p>如果需要的话，你也可以使用操作系统提供的证书，只需要将上述的ca_certs参数的值指定为你的系统中安全证书包所在的绝对路径即可。例如，在大多数的Linux操作系统中，安全证书存储在<code>/etc/ssl/certs/ca-certificates.crt</code>中。其他的操作系统可能会有些许不同。上述验证改为使用操作系统提供的证书后如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> certifi</span><br><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">http=urllib3.PoolManager(cert_reqs=<span class="string">"CERT_REQUIRED"</span>,ca_certs=<span class="string">"/etc/ssl/certs/ca-certificates.crt"</span></span><br><span class="line"><span class="comment">#下面请求https://google.com</span></span><br><span class="line">http.request(<span class="string">"GET"</span>,<span class="string">'https://google.com'</span>)<span class="comment">#没有任何错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面请求https://expired.badssl.com</span></span><br><span class="line">http.request(<span class="string">"GET"</span>,<span class="string">'https://expired.badssl.com'</span>)</span><br><span class="line"><span class="comment">#抛出urllib3.exceptions.SSLError：[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:645)的错误，说明该网站没有配置安全证书。</span></span><br></pre></td></tr></table></figure>

<p><a href="https://urllib3.readthedocs.io/en/latest/user-guide.html#certificate-verification" target="_blank" rel="noopener">在python2中为urllib3应用添加证书验证功能</a></p>
<h5 id="设置超时时间"><a href="#设置超时时间" class="headerlink" title="设置超时时间"></a>设置超时时间</h5><p>设置超时时间可以让你控制你的请求最长等待的时间，超过你设置的时间服务器还没有响应，那么就抛出异常。<br>简单的,你可以给PoolManager对象的request()方法的timeout参数制定一个浮点数来制定本次请求的超时时间。就像下面这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">http=urllib3.PoolManager()</span><br><span class="line">http.request(<span class="string">"GET"</span>,<span class="string">"http://www.baidu.com"</span>,timeout=<span class="number">2.5</span>)</span><br></pre></td></tr></table></figure>

<p>如果你需要更加细粒度的控制超时时间，你可以使用一个TimeOut实例来分别指定连接超时和读取超时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">http=urllib3.PoolManager()</span><br><span class="line"><span class="comment">#只限制连接超时时间为2.0秒，对读取时间不做限制</span></span><br><span class="line">http.request(<span class="string">"GET"</span>,<span class="string">"http://www.google.com"</span>,</span><br><span class="line">        timeout=urllib3.Timeout(connect=<span class="number">2.0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#限制连接超时时间为1.0秒，读取超时时间为2.0秒</span></span><br><span class="line">http.request(<span class="string">"GET"</span>,<span class="string">"http://www.baidu.com"</span>,</span><br><span class="line">        timeout=urllib3.Timeout(connect=<span class="number">1.0</span>,read=<span class="number">2.0</span>))</span><br></pre></td></tr></table></figure>

<p>如果你需要对所有的请求做同样的超时设置，那么你可以直接在PoolManager的层面上做配置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">http1=urllib3.PoolManager(timeout=<span class="number">3.0</span>)</span><br><span class="line">http2=urllib3.PoolManager(timeout=</span><br><span class="line">    urllib3.Timeout(connect=<span class="number">1.0</span>,read=<span class="number">2.0</span>))</span><br></pre></td></tr></table></figure>

<p>这样某一个PoolManager对象的所有的request()使用的默认超时设置就是它的PoolManager的超时设置。<strong>当然你仍然可以在request()方法中重载这个配置。</strong></p>
<h5 id="设置重试次数"><a href="#设置重试次数" class="headerlink" title="设置重试次数"></a>设置重试次数</h5><p>urllib3在默认情况下，再一次请求中，能够自动的重试３次，自动跟进３次重定向。你通过request()方法的retries参数控制重试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#下面的情况是重试次数为１０，最多跟进３次重定向</span></span><br><span class="line">http.request(<span class="string">"GET"</span>,<span class="string">"http://www.bidu.com"</span>,retries=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>如果你要禁用重试<strong>和</strong>重定向跟进的功能的话，只需要将retries指定为False:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#禁用重定向跟进和重试功能</span></span><br><span class="line">http.request(<span class="string">"GET"</span>,<span class="string">"http://www.google.com"</span>,retries=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>如果你要禁用重定向跟进，但是保留默认的３次重试的话，你只需要将request()的redirect参数指定为False：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#禁用重定向的跟进功能，保留了３次的重试功能</span></span><br><span class="line">http.request(<span class="string">"GET"</span>,<span class="string">"http://www.baidu.com"</span>,redirect=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>同设置超时时间一样，如果你需要对重试次数和重定向跟进次数做更加细粒度的控制的话，你需要使用一个Retry实例，例如下面的例子就是最多做三次重试，两次重定向跟进：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.request(<span class="string">"GET"</span>,<span class="string">"http://www.google.com"</span>,retires=</span><br><span class="line">    urllib3.Retry(<span class="number">3</span>,redirect=<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>你可以通过下面的配置，来禁掉应重定向次数过多而造成的抛出错误这一行为，转而返回302的状态码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r=http.request(<span class="string">"GET"</span>,<span class="string">"http://www.baidu.com"</span>,</span><br><span class="line">    retries=urllib3.Retry(redirect=<span class="number">2</span>,raise_on_redirect=<span class="literal">False</span>))</span><br><span class="line">print(r.status)</span><br><span class="line"><span class="comment">#这里如果重定向到次数超过两次的话，程序不会抛出错误，而是状态码返回302</span></span><br></pre></td></tr></table></figure>

<p>同样的，如果你想要为某一个PoolManager对象的所有request()配置同样的重试次数和重定向跟进次数的话，你可以在PoolManager层面上做配置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http1=urllib3.PoolManager(retries=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">http2=urllib3.PoolManager(retries=urllib3.Retry(<span class="number">5</span>,redirect=<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>这样某一个PoolManager对象的所有的request()使用的默认重试次数和重定向跟进次数就是它的PoolManager的重定向次数和重定向跟进次数。<strong>当然你仍然可以在request()方法中重载这个配置。</strong></p>
<h5 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    http.request(<span class="string">"GET"</span>,<span class="string">"http://www.google.com"</span>,retries=<span class="literal">False</span>)</span><br><span class="line"><span class="keyword">except</span> urllib3.exceptions.NewConnectorError <span class="keyword">as</span> f:</span><br><span class="line">    print(<span class="string">"Connection failed!"</span>,f)</span><br></pre></td></tr></table></figure>

<p>异常处理在爬虫中非常重要!更多关于urllib3中的异常可以查看其源码或者<a href="https://urllib3.readthedocs.io/en/latest/reference/index.html#module-urllib3.exceptions" target="_blank" rel="noopener">看这里</a></p>
<h5 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h5><p>依靠标准库的logging,可以实现日志的记录：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.getLogger(<span class="string">"urllib3"</span>).setLevel(logging.WARNING)</span><br></pre></td></tr></table></figure>

<h4 id="进阶话题"><a href="#进阶话题" class="headerlink" title="进阶话题"></a>进阶话题</h4><h5 id="自定义池行为"><a href="#自定义池行为" class="headerlink" title="自定义池行为"></a>自定义池行为</h5><p>PoolManager类自动帮你管理着ConnectionPool类的实例创建工作，一个ConnectionPool管理着发送给一个host的所有请求。默认情况下一个PoolManager最多管理10个ConnectionPool.如果在你的程序中需要向不止10个host同时发送请求的话，你可以更改以适量增加一个PoolManager最多可以管理的ConnectionPool数目，这样做可以提高urllib3的性能。但是同时这也会带来更多的内存和套接字消耗。更改的方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">http=urllib3.PoolManager(num_pools=<span class="number">50</span>)</span><br></pre></td></tr></table></figure>

<p>这样就把一个PoolManager实例最多可以管理的ConnectionPool数目从默认的10改为了50。</p>
<p>同样的，一个ConnectionPool类管理着一个由多个HttpConnection实例组成的http连接池，每一个HttpConnection实例将会用于一个请求。当请求完成之后，连接就会返回到连接池中。默认情况下只有一个连接将会被保存以重用。如果你需要同时向一个host发送很多请求的话，你可以更改以适量增加一个连接池中将会被保存以重用的连接数目，这样有助于提高性能。更改的方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">http=urllib3.PoolManager(maxsize=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者,使用下面这种方式单独实例化一个对goole.com这一host的连</span></span><br><span class="line"><span class="comment">#接池,并且限定连接池中保存以重用的连接数为１０</span></span><br><span class="line">http=urllib3.HttpCoonnectionPool(<span class="string">"google.com"</span>,maxsize=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>默认情况下，对某一个host的一个新的请求发起了，如果此时这个host所对应的连接池中没有可用的连接，那么就会创建一个新的连接。然而如果此时连接池中被保存以重用的连接的数目不小于maxsize设定的值的话，这个新创建的连接将不会被保存以重用。也就是说，maxsize指定的数字不是决定一个连接池中最多可以存在的连接数目的多少，它仅仅指定了这个连接池中被保存以重用的连接数的最大值。但是，如果你指定了参数block=True的话，那么maxsize的值就也限制了某个host所对应的连接池中的最大连接个数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http = urllib3.PoolManager(maxsize=<span class="number">10</span>, block=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># Alternatively</span></span><br><span class="line">http = urllib3.HTTPConnectionPool(<span class="string">'google.com'</span>, maxsize=<span class="number">10</span>, block=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>这样的话，每一个新的请求将会被阻塞直到对应连接池中有一个连接可用为止。这样可以有效防止在多线程应用中，请求某一host的连接过于泛滥(多)的问题。</p>
<h5 id="流式处理大额响应"><a href="#流式处理大额响应" class="headerlink" title="流式处理大额响应"></a>流式处理大额响应</h5><p>当我们请求的是一个大文件，比方说是一部电影的数据的话，我们就需要对响应的内容做流式处理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">http=urllib3.PoolManager()</span><br><span class="line">r=http.request(<span class="string">"GET"</span>,<span class="string">"http://httpbin.org/bytes/1024"</span>,</span><br><span class="line">    preload_content=<span class="literal">False</span>)</span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> r.stream(<span class="number">32</span>):</span><br><span class="line">    print(chunk)</span><br><span class="line">r.release_conn()</span><br></pre></td></tr></table></figure>

<p>在request()方法中，将preload_content参数设为False意味着urllib3将会流式处理响应的内容。request()方法返回的HTTPResponse对象的stream()方法可以让你对响应的内容做迭代。</p>
<p>当你使用了<code>preload_content=False</code>这一选项时，你最后应该调用HTTPResponse对象的release_conn()方法来释放本次连接，让其返回连接池以重用。</p>
<p>你也可以把这个HTTPResponse对象当做一个类文件对象，这允许你做缓冲处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r = http.request(</span><br><span class="line">     <span class="string">'GET'</span>,</span><br><span class="line">     <span class="string">'http://httpbin.org/bytes/1024'</span>,</span><br><span class="line">     preload_content=<span class="literal">False</span>)</span><br><span class="line">r.read(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>直接对read()方法的调用将会阻塞，直到有更多的响应内容可用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line">reader=io.BufferedReader(r,<span class="number">8</span>)</span><br><span class="line">reader.read(<span class="number">4</span>)</span><br><span class="line">r.release_conn()</span><br></pre></td></tr></table></figure>

<p>你可以利用这个类文件对象来做一些事情，比如用codecs来解码响应内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> codecs,json</span><br><span class="line">reader=codecs.getreader(<span class="string">"utf-8"</span>)</span><br><span class="line">r=http.request(<span class="string">"GET"</span>,<span class="string">"http://httpbin.org/ip"</span>,preload_content=<span class="literal">False</span>)</span><br><span class="line">data=json.load(reader(r))</span><br><span class="line">r.release_conn()</span><br></pre></td></tr></table></figure>

<h5 id="设置网络代理"><a href="#设置网络代理" class="headerlink" title="设置网络代理"></a>设置网络代理</h5><p>你可以使用ProxyManager通过HTTP代理来传输你的请求：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line">proxy=urllib3.ProxyManager(<span class="string">"http://localhost:3128"</span>)</span><br><span class="line">proxy.request(<span class="string">"GET"</span>,<span class="string">"http://google.com/"</span>)</span><br></pre></td></tr></table></figure>

<p>ProxyManager的用法和PoolManager是一样的</p>
<p>你也可以使用SOCKSProxyManager来连接到SOCK4或者SOCKS5代理。为了启用SOCKS代理，你需要安装<a href="https://pypi.python.org/pypi/PySocks" target="_blank" rel="noopener">PySocks</a>或者安装urllib3的socks扩展:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pip3 install PySocks</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">$ pip3 install urllib3[socks]</span><br></pre></td></tr></table></figure>

<p>一旦你安装了PySocks，你就可以在你的代码中使用SOCKSProxyManager:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib3.contrib.socks <span class="keyword">import</span> SOCKSProxyManager</span><br><span class="line">proxy=SOCKSProxyManager(<span class="string">'socks5://localhost:8889/'</span>)</span><br><span class="line">proxy.request(<span class="string">'GET'</span>, <span class="string">'http://google.com/'</span>)</span><br></pre></td></tr></table></figure>

<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>剩下几个主题可能大家不会遇到，这里就不再介绍了，丢个<a href="https://urllib3.readthedocs.io/en/latest/advanced-usage.html#custom-ssl-certificates-and-client-certificates" target="_blank" rel="noopener">链接</a></p>
<h3 id="神器－－requests"><a href="#神器－－requests" class="headerlink" title="神器－－requests"></a>神器－－requests</h3><p><a href="http://www.python-requests.org/en/master/" target="_blank" rel="noopener">requests</a>: HTTP for Humans<br>requests是另外一个HTTP客户端编程的神器，它构建在urllib3的基础之上，不仅继承了urllib3的优秀特质，并且全面自动的支持HTTP/1.1请求，带持久 Cookie和Session等,对我们用户来讲，它还拥有更加人性化的API设计。</p>
<p><a href="http://docs.python-requests.org/zh_CN/latest/user/quickstart.html#cookie" target="_blank" rel="noopener">Cookie处理</a></p>
<h2 id="反爬虫者与反反爬虫者之间的恩怨情仇"><a href="#反爬虫者与反反爬虫者之间的恩怨情仇" class="headerlink" title="反爬虫者与反反爬虫者之间的恩怨情仇"></a>反爬虫者与反反爬虫者之间的恩怨情仇</h2><p>爬虫对于网站拥有者来说并不是一个令人高兴的存在，因为爬虫的肆意横行意味着自己的网站资料泄露，资源消耗，甚至是自己刻意隐藏在网站的隐私的内容也会泄露。面对这样的状况，作为网站的维护者或者拥有者，要么抵御爬虫，通过各种反爬虫的手段阻挡爬虫，要么顺从爬虫，自动提供可供爬虫使用的接口。事实上，大多数的网站既会采取一些必要的反爬虫措施，也会提供一些开放的api供开发者获取数据。但是绝大多数的开放平台所提供的api都有各种各样的限制：无法完全满足你的需求，需要收费等。所以很多人更愿意自己到网站上去爬取数据，在这种情况之下伟大的反爬虫运动与反反爬虫运动之间的斗争就开始了。</p>
<h3 id="各种反爬虫手段及因对措施"><a href="#各种反爬虫手段及因对措施" class="headerlink" title="各种反爬虫手段及因对措施"></a>各种反爬虫手段及因对措施</h3><h4 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h4><p><code>原理</code>：对于比较简陋的爬虫程序来讲一般没有设置请求头，而浏览器等客户端工具一般会自动帮我们加上请求头，那么服务器就可以检查客户端发来的请求的请求头中的某些字段是否存在从而识别出客户端是爬虫程序。一般情况下，服务器会检查请求头的User-Agent字段。</p>
<p><code>应对</code>：这个应对的方法比较简单，我们只需要为请求添加请求头即可(主要是添加User-Agent字段)。这个过程在爬虫中叫做<strong>浏览器伪装</strong>。在这里给大家推荐一个简单实用的python包<a href="https://pypi.python.org/pypi/fake-useragent" target="_blank" rel="noopener">fake-useragent</a>，它可以方便的帮你生成User-Agent信息，这样你就不需要自己到处去复制了。</p>
<h4 id="IP限制"><a href="#IP限制" class="headerlink" title="IP限制"></a>IP限制</h4><p><code>原理</code>：如果是个人编写的爬虫，没做特殊处理的话，IP是固定的，那么服务器发现某个IP请求的频率超过了某一阈值，就可以判断这个客户端是爬虫程序了，网站的管理或者运维人员，一般的处理方式就是暂时封掉该IP,那么也就是说这个IP发出的请求在短时间(一般是数小时)内不能再访问这个网站了，也就暂时挡住了爬虫。</p>
<p><code>应对</code>：对于这种手段我们一般采取两种处理方式：设置延时和使用网络代理。<strong>设置延时</strong>很简单，就是让请求与请求之间停留一小段时间，让请求的频率降下来，这样就达不到请求频率的阈值，也就不会触发服务器的封IP行为了。使用<strong>HTTP代理</strong>之后，在服务器上显示的就是你的代理服务器的IP地址了，即使是封掉了IP封掉的也是代理服务器的地址，这时你换一个代理服务器就OK了。在实际中，我们会先准备大量的可用IP,从而建立一个IP池，每次请求都从IP池中任意选取一个IP去访问。<br>代理IP从<a href="http://www.xicidaili.com/wn/" target="_blank" rel="noopener">这儿</a>找,在选的时候大家尽量选择验证时间比较短，反应速度比较快的ip.</p>
<h4 id="Ajax动态加载"><a href="#Ajax动态加载" class="headerlink" title="Ajax动态加载"></a>Ajax动态加载</h4><p><code>原理</code>：对于网站来说，使用Ajax动态加载技术可以提高网站的工作效率，提升用户体验，在用户需要某个数据时(某一特定条件发生时)才发送这些数据到客户端，然后通过js在不刷新整个页面的情况下将这些数据渲染到页面上。但对于数据采集者来说，这却带来了巨大的麻烦。使用传统的请求工具无法得到想要的完整的数据。下面给大家看几个动态加载页面的例子：<a href="http://pythonscraping.com/pages/javascript/ajaxDemo.html" target="_blank" rel="noopener">特定时间后页面变化</a>，<a href="https://www.zhihu.com/#signin" target="_blank" rel="noopener">用户点击后页面变化</a></p>
<p><code>应对</code>：对于动态加载页面的爬取最好的处理方式是：<strong>PhantomJs+Selenium</strong>,这个在下面的高级主题中介绍。</p>
<h4 id="验证码反爬虫"><a href="#验证码反爬虫" class="headerlink" title="验证码反爬虫"></a>验证码反爬虫</h4><p><code>原理</code>：有些网站会对站内特殊的数据做额外的保护，你只有正确填写验证码之后才能访问到该网页，在这种情况下爬取的难度就非常大了。但是也不是不能爬取，主要要看它使用的是何种验证方式。<br><code>应对</code>：如果是普通的填写它给出的图片上的字符，那么可以使用图像识别的技术来处理，但其实现在的验证码往往都加了许多的干扰线，噪点之类的，连人类有时候都有可能识别错误，何况是机器呢！更厉害的是像12306的那种请点击以下所有包含海洋的图片，或者知乎的请点击下图中所有倒立的汉字等等，我只能说遇到类似这样的爬虫任务的话，你就只能认命了！</p>
<h1 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h1><p>在上面的一部分中，我们讨论了如何下载，下面要讨论的则是下载到网页之后我们怎样从网页中提取数据的问题了。</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>在计算机的世界中很多东西归根结底都可以归结到字符串的处理上，其中在某一字符串中提取另一种模式的字符串又是其中的重要组成部分。正则表达式解决的就是模式的描述的问题。python中的re模块提供了许多优秀的API,使Python语言拥有全部的正则表达式功能。详情参考<a href="http://cuiqingcai.com/977.html" target="_blank" rel="noopener">这里</a></p>
<h2 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h2><p><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" target="_blank" rel="noopener">BeautifulSoup</a></p>
<h2 id="Xpath"><a href="#Xpath" class="headerlink" title="Xpath"></a>Xpath</h2><p><a href="http://lxml.de/" target="_blank" rel="noopener">Xpath</a></p>
<h1 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h1><h2 id="动态页面的爬取"><a href="#动态页面的爬取" class="headerlink" title="动态页面的爬取"></a>动态页面的爬取</h2><p>先看两个例子:<a href>自动登录发表文章</a>，<a href>搜索并下载歌曲</a>。体会下phantomjs+selenium可以做啥！</p>
<h3 id="phantomJS"><a href="#phantomJS" class="headerlink" title="phantomJS"></a>phantomJS</h3><p><a href="http://phantomjs.org/quick-start.html" target="_blank" rel="noopener">phantomjs</a>是一个无界面的,可脚本编程的WebKit浏览器引擎。它原生支持多种web标准：DOM操作，CSS选择器，JSON，Canvas 以及SVG。可以帮助我们像浏览器一样渲染JS处理的页面。</p>
<p>这么使用phantomjs呢？看－&gt;<a href="http://javascript.ruanyifeng.com/tool/phantomjs.html" target="_blank" rel="noopener">这里</a>或<a href="http://cuiqingcai.com/2577.html" target="_blank" rel="noopener">这里</a>.</p>
<h3 id="selenium-python-bindings"><a href="#selenium-python-bindings" class="headerlink" title="selenium python bindings"></a>selenium python bindings</h3><p>首先推荐一个<a href="https://huilansame.github.io/huilansame.github.io/page3/" target="_blank" rel="noopener">博客</a>,这个人的博客写的全是selenium python的内容。</p>
<p><a href="http://selenium-python.readthedocs.io/" target="_blank" rel="noopener">selenium</a>是一个web测试自动化的工具。Selenium Python bindings 提供了一个简单的API，让你使用Selenium WebDriver来编写功能/校验测试。通过Selenium Python的API，你可以非常直观的使用Selenium WebDriver的所有功能。Selenium Python bindings 使用非常简洁方便的API让你去使用像Firefox, IE, Chrome, Remote等等这样的Selenium WebDrivers（Selenium web驱动器）。在生产环境中我们一般使用phantomjs这样的轻量级浏览器作为selenium web驱动。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>可以从PyPI的官方库中下载该selenium支持库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip3 install selenium</span><br></pre></td></tr></table></figure>

<h4 id="你的第一个selenium应用"><a href="#你的第一个selenium应用" class="headerlink" title="你的第一个selenium应用"></a>你的第一个selenium应用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"></span><br><span class="line">driver = webdriver.PhantomJS(executable_path=<span class="string">'/usr/local/bin/phantomjs'</span>)</span><br><span class="line">driver.get(<span class="string">"http://www.python.org"</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="string">"Python"</span> <span class="keyword">in</span> driver.title</span><br><span class="line">elem = driver.find_element_by_name(<span class="string">"q"</span>)</span><br><span class="line">elem.clear()</span><br><span class="line">elem.send_keys(<span class="string">"pycon"</span>)</span><br><span class="line">elem.send_keys(Keys.RETURN)</span><br><span class="line"><span class="keyword">assert</span> <span class="string">"No results found."</span> <span class="keyword">not</span> <span class="keyword">in</span> driver.page_source</span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure>

<h4 id="使用普通浏览器"><a href="#使用普通浏览器" class="headerlink" title="使用普通浏览器"></a>使用普通浏览器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"><span class="comment"># driver = webdriver.FireFox()</span></span><br><span class="line"><span class="comment"># driver =webdriver.IE()</span></span><br><span class="line">driver.get(<span class="string">"http://www.python.org"</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="string">"Python"</span> <span class="keyword">in</span> driver.title</span><br><span class="line">elem = driver.find_element_by_name(<span class="string">"q"</span>)</span><br><span class="line">elem.clear()</span><br><span class="line">elem.send_keys(<span class="string">"pycon"</span>)</span><br><span class="line">elem.send_keys(Keys.RETURN)</span><br><span class="line"><span class="keyword">assert</span> <span class="string">"No results found."</span> <span class="keyword">not</span> <span class="keyword">in</span> driver.page_source</span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure>

<p>使用普通的浏览器需要安装浏览器驱动程序，并且保证这些驱动程序在你的环境变量中。常见的浏览器及其驱动下载地址如下：</p>
<table>
<thead>
<tr>
<th align="center">浏览器</th>
<th align="center">驱动下载地址</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Chrome</td>
<td align="center"><a href="https://sites.google.com/a/chromium.org/chromedriver/downloads" target="_blank" rel="noopener">https://sites.google.com/a/chromium.org/chromedriver/downloads</a></td>
</tr>
<tr>
<td align="center">Edge</td>
<td align="center"><a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/" target="_blank" rel="noopener">https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/</a></td>
</tr>
<tr>
<td align="center">Firefox</td>
<td align="center"><a href="https://github.com/mozilla/geckodriver/releases" target="_blank" rel="noopener">https://github.com/mozilla/geckodriver/releases</a></td>
</tr>
<tr>
<td align="center">Safari</td>
<td align="center"><a href="https://webkit.org/blog/6900/webdriver-support-in-safari-10/" target="_blank" rel="noopener">https://webkit.org/blog/6900/webdriver-support-in-safari-10/</a></td>
</tr>
<tr>
<td align="center">#### 打开一个页面</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">你想做的第一件事也许是使用WebDriver打开一个链接。常规的方法是调用get方法:</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.get(<span class="string">"http://www.google.com"</span>)</span><br></pre></td></tr></table></figure></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>WebDriver 将等待，直到页面完全加载完毕（其实是等到 onload 方法执行完毕）， 然后返回继续执行你的脚本.</p>
<h4 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h4><p>selenium with python给我们提供了大量的用于在页面中定位元素的API，有了这些API，你可以在页面上找到任何你需要的元素。详细内容看－&gt;<a href="https://selenium-python-zh.readthedocs.io/en/latest/locating-elements.html" target="_blank" rel="noopener">这里</a></p>
<h4 id="页面交互"><a href="#页面交互" class="headerlink" title="页面交互"></a>页面交互</h4><h5 id="填写表单"><a href="#填写表单" class="headerlink" title="填写表单"></a>填写表单</h5><p>首先找到表单元素对象，然后对表单元素对象调用send_keys(data)方法就可以把data填写到input框中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">driver.get(<span class="string">"http://auth.muxixyz.com/login/"</span>)</span><br><span class="line">username_elem=driver.find_element_by_id(<span class="string">"username"</span>)</span><br><span class="line">username_elem.send_keys(<span class="string">"阿超"</span>)</span><br><span class="line">password_elem=driver.find_element_by_id(<span class="string">"password"</span>)</span><br><span class="line">password_elem.send_keys(<span class="string">"this is my pwd"</span>)</span><br><span class="line">driver.find_element_by_id(<span class="string">"submit"</span>).click()</span><br><span class="line">WebDriverWait(driver,<span class="number">3</span>).until(<span class="keyword">lambda</span> x:x.find_element_by_xpath(<span class="string">"//a[@href='http://share.muxixyz.com/']"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#截取当前页面的图片</span></span><br><span class="line">driver.driver.get_screenshot_as_file(<span class="string">"1.png"</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"1.html"</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment">#获取当前页面的源码</span></span><br><span class="line">    f.write(driver.page_source)</span><br></pre></td></tr></table></figure>

<p>上述代码就是以我的账号密码登录木犀内网，然后将跳转之后的页面的图截下来保存为1.png，将当前页面的源码保存为1.html.</p>
<h4 id="键盘模拟"><a href="#键盘模拟" class="headerlink" title="键盘模拟"></a>键盘模拟</h4><p><a href="http://selenium-python-zh.readthedocs.io/en/latest/api.html#module-selenium.webdriver.common.keys" target="_blank" rel="noopener">键盘模拟</a><br>当调用一个元素对象的send_keys()方法的时候，不光可以向这个元素传递数据，也可以传递selenium.webdriver.common.keys．Keys的实例来模拟键盘的操作<br>，这可以用来测试网站的快捷键设置是否正确。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line">driver.get(<span class="string">"http://www.douban.com"</span>)</span><br><span class="line">driver.get_screenshot_as_file(<span class="string">"douban.png"</span>)</span><br><span class="line">username = driver.find_element_by_name(<span class="string">"form_email"</span>)</span><br><span class="line">password = driver.find_element_by_name(<span class="string">"form_password"</span>)</span><br><span class="line">submit=driver.find_element_by_class_name(<span class="string">"bn-submit"</span>)</span><br><span class="line">username.send_keys(<span class="string">"13636038496"</span>)</span><br><span class="line">password.send_keys(<span class="string">"this is my pwd"</span>)</span><br><span class="line">submit.click()</span><br><span class="line"></span><br><span class="line"><span class="comment">#上面的三行代码也可以写成下面这样</span></span><br><span class="line"><span class="comment"># username.send_keys("13636038496")</span></span><br><span class="line"><span class="comment"># password.send_keys("this is my pwd"，Keys.RETURN)</span></span><br></pre></td></tr></table></figure>

<p>一般网站的表单填写完了之后，都可以直接通过按下回车键提交表单,上面注释的代码就是模拟了这个过程。</p>
<h4 id="窗口切换"><a href="#窗口切换" class="headerlink" title="窗口切换"></a>窗口切换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">currentWin = driver.current_window_handle</span><br><span class="line"><span class="comment">#跳转到另一个新页面</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//p[@id='nv']/a[3]"</span>).click()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#获取所有窗口的句柄</span></span><br><span class="line">handles = driver.window_handles</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> handles:</span><br><span class="line">    <span class="keyword">if</span> currentWin == i:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#将driver与新的页面绑定起来</span></span><br><span class="line">        driver = driver.switch_to_window(i)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver.switch_to_window(<span class="string">"windowName"</span>)</span><br><span class="line">driver.switch_to_frame(<span class="string">"frameName"</span>)</span><br><span class="line">alert = driver.switch_to_alert()</span><br></pre></td></tr></table></figure>

<h4 id="历史记录和定位"><a href="#历史记录和定位" class="headerlink" title="历史记录和定位"></a>历史记录和定位</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.forward()</span><br><span class="line">driver.back()</span><br></pre></td></tr></table></figure>

<h4 id="cookie处理"><a href="#cookie处理" class="headerlink" title="cookie处理"></a>cookie处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置cookie</span></span><br><span class="line">cookie = &#123;<span class="string">'name'</span>:<span class="string">'foo'</span>,<span class="string">'value'</span>:<span class="string">'bar'</span>&#125;</span><br><span class="line">driver.add_cookie(cookie)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出当前url下可用的cookie</span></span><br><span class="line">driver.get_cookies()</span><br></pre></td></tr></table></figure>

<h4 id="设置等待"><a href="#设置等待" class="headerlink" title="设置等待"></a>设置等待</h4><p>现在的app有许多都在使用ajax(Asynchronous Javascript And XML)技术,这使得在一个页面中的元素的出现时间会产生差异，这给元素的定位带来了不小的困难。如果一个元素还没有出现在DOM中，那么你用一个定位函数去定位这个元素的时候就会产生<code>ElementNotVisibleException</code>的错误。使用等待可以解决这个问题。Selenium Webdriver提供了两种等待：显式等待(Explicit Waits)和隐式等待(Implicit Waits).</p>
<h5 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a>隐式等待</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.implicitly_wait(<span class="number">30</span>)  <span class="comment"># 隐性等待，最长等30秒</span></span><br><span class="line">driver.get(<span class="string">'https://huilansame.github.io'</span>)</span><br><span class="line"></span><br><span class="line">print(driver.current_url)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<p>隐形等待是设置了一个最长等待时间，如果在规定时间内网页加载完成，则执行下一步，否则一直等到时间截止，然后执行下一步。注意这里有一个弊端，那就是程序会一直等待整个页面加载完成，也就是一般情况下你看到浏览器标签栏那个小圈不再转，才会执行下一步，但有时候页面想要的元素早就在加载完成了，但是因为个别js之类的东西特别慢，我仍得等到页面全部完成才能执行下一步，我想等我要的元素出来之后就下一步怎么办？有办法，这就要看selenium提供的另一种等待方式——显性等待wait了。<br>Tip:隐性等待对整个driver的周期都起作用，所以只要设置一次即可</p>
<h5 id="显式等待"><a href="#显式等待" class="headerlink" title="显式等待"></a>显式等待</h5><p>显示等待是你在你的代码中设置的等待某一个条件发生之后才继续向下执行的等待。selenium提供了一些方便的方法来帮助你设置你的等待，并且可以让等待只花所需要的时间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">"http://somedomain/url_that_delays_loading"</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    element = WebDriverWait(driver, <span class="number">10</span>).until(</span><br><span class="line">        EC.presence_of_element_located((By.ID, <span class="string">"myDynamicElement"</span>))</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    driver.quit()</span><br></pre></td></tr></table></figure>

<p>上面的例子中的意思是通过id来获取”myDynamicElement”元素，如果当前DOM中没有这个元素，那么就等待，最长等待的时间是10秒，如果十秒钟之后该元素仍然没有出现，则抛出<code>TimeoutException</code>错误。如果在等待的过程中该元素加载出来了，那么该函数就立即返回，停止等待。默认情况下，selenium webdriver每500毫秒，检查一下预期条件。</p>
<p>selenium with python提供了许多的常用的期望条件来帮助你操控你的浏览器。常用的预期条件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">selenium.webdriver.support.expected_conditions（模块）</span><br><span class="line"></span><br><span class="line">这两个条件类验证title，验证传入的参数title是否等于或包含于driver.title</span><br><span class="line">title_is</span><br><span class="line">title_contains</span><br><span class="line"></span><br><span class="line">这两个人条件验证元素是否出现，传入的参数都是元组类型的locator，如(By.ID, &apos;kw&apos;)</span><br><span class="line">顾名思义，一个只要一个符合条件的元素加载出来就通过；另一个必须所有符合条件的元素都加载出来才行</span><br><span class="line">presence_of_element_located</span><br><span class="line">presence_of_all_elements_located</span><br><span class="line"></span><br><span class="line">这三个条件验证元素是否可见，前两个传入参数是元组类型的locator，第三个传入WebElement</span><br><span class="line">第一个和第三个其实质是一样的</span><br><span class="line">visibility_of_element_located</span><br><span class="line">invisibility_of_element_located</span><br><span class="line">visibility_of</span><br><span class="line"></span><br><span class="line">这两个人条件判断某段文本是否出现在某元素中，一个判断元素的text，一个判断元素的value</span><br><span class="line">text_to_be_present_in_element</span><br><span class="line">text_to_be_present_in_element_value</span><br><span class="line"></span><br><span class="line">这个条件判断frame是否可切入，可传入locator元组或者直接传入定位方式：id、name、index或WebElement</span><br><span class="line">frame_to_be_available_and_switch_to_it</span><br><span class="line"></span><br><span class="line">这个条件判断是否有alert出现</span><br><span class="line">alert_is_present</span><br><span class="line"></span><br><span class="line">这个条件判断元素是否可点击，传入locator</span><br><span class="line">element_to_be_clickable</span><br><span class="line"></span><br><span class="line">这四个条件判断元素是否被选中，第一个条件传入WebElement对象，第二个传入locator元组</span><br><span class="line">第三个传入WebElement对象以及状态，相等返回True，否则返回False</span><br><span class="line">第四个传入locator以及状态，相等返回True，否则返回False</span><br><span class="line">element_to_be_selected</span><br><span class="line">element_located_to_be_selected</span><br><span class="line">element_selection_state_to_be</span><br><span class="line">element_located_selection_state_to_be</span><br><span class="line"></span><br><span class="line">最后一个条件判断一个元素是否仍在DOM中，传入WebElement对象，可以判断页面是否刷新了</span><br><span class="line">staleness_of</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line">wait = WebDriverWait(driver, <span class="number">10</span>)</span><br><span class="line">element = wait.until(EC.element_to_be_clickable((By.ID, <span class="string">'someid'</span>)))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)  <span class="comment"># 隐性等待和显性等待可以同时用，但要注意：等待的最长时间取两者之中的大者</span></span><br><span class="line">driver.get(<span class="string">'https://huilansame.github.io'</span>)</span><br><span class="line">locator = (By.LINK_TEXT, <span class="string">'CSDN'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    WebDriverWait(driver, <span class="number">20</span>, <span class="number">0.2</span>).until(EC.presence_of_element_located(locator))</span><br><span class="line">    print(driver.find_element_by_link_text(<span class="string">'CSDN'</span>).get_attribute(<span class="string">'href'</span>))</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    driver.close()</span><br></pre></td></tr></table></figure>

<p>如果上述提供的期待条件没有满足你的需求，你也可以自定义期望条件：可以通过一个实现了<code>__call__()</code>方法的类来自定义一个等待的期望条件。这个<code>__call__()</code>方法在不匹配的情况下，返回False即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">element_has_css_class</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="string">"""An expectation for checking that an element has a particular css class.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  locator - used to find the element</span></span><br><span class="line"><span class="string">  returns the WebElement once it has the particular css class</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, locator, css_class)</span>:</span></span><br><span class="line">    self.locator = locator</span><br><span class="line">    self.css_class = css_class</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, driver)</span>:</span></span><br><span class="line">    element = driver.find_element(*self.locator)   <span class="comment"># Finding the referenced element</span></span><br><span class="line">    <span class="keyword">if</span> self.css_class <span class="keyword">in</span> element.get_attribute(<span class="string">"class"</span>):</span><br><span class="line">        <span class="keyword">return</span> element</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Wait until an element with id='myNewInput' has class 'myCSSClass'</span></span><br><span class="line">wait = WebDriverWait(driver, <span class="number">10</span>)</span><br><span class="line">element = wait.until(element_has_css_class((By.ID, <span class="string">'myNewInput'</span>), <span class="string">"myCSSClass"</span>))</span><br></pre></td></tr></table></figure>

<p>除了上面介绍的几种等待的方式，使用<code>time.sleep()</code>也可以实现等待的效果，但是这种方法比较low,推荐不要使用。</p>
<h4 id="PhantomJS请求配置"><a href="#PhantomJS请求配置" class="headerlink" title="PhantomJS请求配置"></a>PhantomJS请求配置</h4><p>一般来讲，如果是做爬虫的话，使用的web driver都是PhantomJS，相较于大家桌面上的浏览器的话，它更轻量级，所以速度更快。在使用PhantomJS时，可以对其进行一些配置,比如设置请求头，设置网络代理等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.desired_capabilities <span class="keyword">import</span> DesiredCapabilities</span><br><span class="line">ua = UserAgent()</span><br><span class="line"><span class="comment">#配置对象DesiredCapabilities</span></span><br><span class="line">dcap = dict(DesiredCapabilities.PHANTOMJS)</span><br><span class="line"><span class="comment">#从USER_AGENTS列表中随机选一个浏览器头，伪装浏览器</span></span><br><span class="line">dcap[<span class="string">"phantomjs.page.settings.userAgent"</span>] = ua.random</span><br><span class="line"><span class="comment"># 不载入图片，爬页面速度会快很多</span></span><br><span class="line">dcap[<span class="string">"phantomjs.page.settings.loadImages"</span>] = <span class="literal">True</span></span><br><span class="line"><span class="comment"># 设置代理</span></span><br><span class="line">service_args = [<span class="string">'--proxy=127.0.0.1:9999'</span>,<span class="string">'--proxy-type=socks5'</span>]</span><br><span class="line"><span class="comment">#打开带配置信息的phantomJS浏览器</span></span><br><span class="line">driver = webdriver.PhantomJS(phantomjs_driver_path, desired_capabilities=dcap,service_args=service_args)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 隐式等待5秒，可以自己调节</span></span><br><span class="line">driver.implicitly_wait(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 设置10秒页面超时返回，类似于requests.get()的timeout选项，driver.get()没有timeout选项</span></span><br><span class="line"><span class="comment"># 以前遇到过driver.get(url)一直不返回，但也不报错的问题，这时程序会卡住，设置超时选项能解决这个问题。</span></span><br><span class="line">driver.set_page_load_timeout(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 设置10秒脚本超时时间</span></span><br><span class="line">driver.set_script_timeout(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">driver.get(<span class="string">"http://www.baidu.com"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="道德问题"><a href="#道德问题" class="headerlink" title="道德问题"></a>道德问题</h2><p>在互联网这个复杂的环境中，搜索引擎本身的爬虫，出于个人目的的爬虫，商业爬虫肆意横行，肆意掠夺网上的或者公共或者私人的资源。显然数据的收集并不是为所欲为，有一些协议或者原则还是需要每一个人注意。</p>
<h3 id="robots协议"><a href="#robots协议" class="headerlink" title="robots协议"></a>robots协议</h3><p>一般情况下网站的根目录下存在着一个robots.txt的文件，用于告诉爬虫那些文件夹或者哪些文件是网站的拥有者或者管理员不希望被搜索引擎和爬虫浏览的，或者是不希望被非人类的东西查看的。但是不仅仅如此，在这个文件中，有时候还会指明sitemap的位置，爬虫可以直接寻找sitemap而不用费力去爬取网站。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2017/11/22/Sort-Algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/22/Sort-Algorithm/" itemprop="url">排序算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-22T10:14:30+08:00">
                2017-11-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><h2 id="排序的分类"><a href="#排序的分类" class="headerlink" title="排序的分类"></a>排序的分类</h2><h3 id="按是否涉及数据的内外存交换分"><a href="#按是否涉及数据的内外存交换分" class="headerlink" title="按是否涉及数据的内外存交换分"></a>按是否涉及数据的内外存交换分</h3><p>在排序过程中，若整个文件都是放在内存中处理，排序时不涉及数据的内、外存交换，则称之为<strong>内部排序</strong>(简称内排序)；反之，若排序过程中要进行数据的内、外存交换，则称之为<strong>外部排序</strong>。<code>本文的内容均基于内部排序。</code></p>
<h3 id="在内排序基础上按策略分"><a href="#在内排序基础上按策略分" class="headerlink" title="在内排序基础上按策略分"></a>在内排序基础上按策略分</h3><p>可以分为五类：插入排序、选择排序、交换排序、归并排序和分配排序。</p>
<p><img src="/images/paixu.png" alt="排序"></p>
<h2 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h2><p>当待排序记录的关键字均不相同时，排序结果是惟一的，否则排序结果不唯一。</p>
<p>在待排序的文件中，若存在多个关键字相同的记录，经过排序后这些具有相同关键字的记录之间的相对次序保持不变，该排序方法是稳定的；若具有相同关键字的记录之间的相对次序发生变化，则称这种排序方法是不稳定的。</p>
<p>注意： 排序算法的稳定性是针对所有输入实例而言的。即在所有可能的输入实例中，只要有一个实例使得算法不满足稳定性要求，则该排序算法就是不稳定的。</p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子文件中的适当位置，直到全部记录插入完成为止。</p>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>待排序序列被人为的分为两部分：有序区和无序区。起始时刻第一个元素自成一个有序区，其他的n-1个元素组成无序区(n为待排序数据个数)。每趟循环从无序区取出一个元素，然后插入到有序区中，并且插入后仍然保持有序区的有序。这样的话，每次循环过后，有序曲的数据量加一，无序区的数据量减一，经过<code>n-1</code>次循环后，有序曲的数据量为n,无序区的数据量为０，排序也就完成了。</p>
<p>插入排序与打扑克时整理手上的牌非常类似。摸来的第 1 张牌无须整理，此后每次从桌上的牌(无序区)中摸最上面的 1 张并插入左手的牌(有序区)中正确的位置上。为了找到这个正确的位置，须自左向右(或自右向左)将摸来的牌与左手中已有的牌逐一比较。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>就将一个数组a按照从小到大排列作为例子吧！首先，取无序区的第一个数据作为待插入的数据(由于是起始时刻，这里取得是a[1])，然后找到该数据在无序区中该插入的位置，进行插入即可。这里可以充分利用有序曲的数据已经有序的特点：如果取到的待插入的数据比有序区的最右边的数据大(这里即为有序曲中最大的数据)，则该数据当前所在的位置即为它该插入的位置，也就是说，此时什么也不用做，直接取下一个数据；如果取到的待插入数据比有序曲的最右边的那个数据小，则说明该数据的插入位置在它当前位置的左边，此时就需要找到这个位置。怎么找呢？我们可以首先把有序曲的最右边的数据(即最大的那个数据)右移一位(在右移之前要先用一个辅助变量保存我们的待插入数据，以防右移时覆盖了它)，然后比较有序区右边第二个数据与待插入数据的大小，如果这个数仍然大于待插入数据，则依然将这个数右移一位。重复上述过程，直到出现了下面两种情况之一：在有序区中找到了一个小于等于待插入数据的数据或者找到头都没有找到这么一个数据。待插入数据的位置也就找到了。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>未引入哨兵：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a[<span class="number">9</span>]=&#123;<span class="number">100</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">65</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">1</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span> length=<span class="number">9</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//变量temp用于保存取到的数据，防止后面的移动而被覆盖</span></span><br><span class="line">       <span class="keyword">int</span> temp=a[i];<span class="comment">//待插入的数据(无序区左边的第一个元素)</span></span><br><span class="line">       <span class="keyword">int</span> j=i<span class="number">-1</span>;<span class="comment">//有序取右边的第一个元素</span></span><br><span class="line">       <span class="keyword">if</span>(a[j]&gt;temp)&#123;</span><br><span class="line">           <span class="comment">//如果a[j]&lt;=temp则说明temp插入的位置就是当前所在的位置，直接取下一个数，进入下一轮循环.</span></span><br><span class="line">           <span class="comment">//这里a[j]&gt;temp,说明temp插入的位置不在当前位置，而在更低位，下面就是要寻找这样的位置</span></span><br><span class="line">           <span class="keyword">do</span>&#123;</span><br><span class="line">               a[j+<span class="number">1</span>]=a[j];</span><br><span class="line">               j--;</span><br><span class="line">           &#125;<span class="keyword">while</span>(a[j]&gt;temp&amp;&amp;j&gt;=<span class="number">0</span>);</span><br><span class="line">           <span class="comment">//找到了头或者找到了一个小于等于temp的位置</span></span><br><span class="line">           <span class="comment">//找到了temp该插入的位置，插入temp</span></span><br><span class="line">           a[j+<span class="number">1</span>]=temp;</span><br><span class="line">       &#125;   </span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//打印输出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">9</span>;k++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[k]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入哨兵:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lnsertSort</span><span class="params">(SeqList R)</span>  </span></span><br><span class="line"><span class="function"> </span>&#123; <span class="comment">//对顺序表R中的记录R[1..n]按递增序进行插入排序  </span></span><br><span class="line">  <span class="keyword">int</span> i，j；  </span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n；i++)&#123; <span class="comment">//依次插入R[2]，…，R[n]  </span></span><br><span class="line">    <span class="keyword">if</span>(R[i].key&lt;R[i<span class="number">-1</span>].key)&#123;<span class="comment">//若R[i].key大于等于有序区中所有的keys，则R[i]  </span></span><br><span class="line">                            <span class="comment">//应在原有位置上  </span></span><br><span class="line">      R[<span class="number">0</span>]=R[i];j=i<span class="number">-1</span>; <span class="comment">//R[0]是哨兵，且是R[i]的副本  </span></span><br><span class="line">      <span class="keyword">do</span>&#123; <span class="comment">//从右向左在有序区R[1．．i-1]中查找R[i]的插入位置  </span></span><br><span class="line">       R[j+<span class="number">1</span>]=R[j]； <span class="comment">//将关键字大于R[i].key的记录后移  </span></span><br><span class="line">       j-- ；  </span><br><span class="line">       &#125;<span class="keyword">while</span>(R[<span class="number">0</span>].key&lt;R[j].key)； <span class="comment">//有了哨兵，这里无需判断数组越界</span></span><br><span class="line">      R[j+<span class="number">1</span>]=R[<span class="number">0</span>]； <span class="comment">//R[i]插入到正确的位置上  </span></span><br><span class="line">     &#125;<span class="comment">//endif  </span></span><br><span class="line"> &#125;<span class="comment">//endfor</span></span><br><span class="line"> &#125;<span class="comment">//InsertSort</span></span><br></pre></td></tr></table></figure>

<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><h4 id="关于哨兵"><a href="#关于哨兵" class="headerlink" title="关于哨兵"></a>关于哨兵</h4><p>2．哨兵的作用<br>算法中引进的附加记录 R[0]称监视哨或哨兵(Sentinel)。相比于未引入哨兵的代码，引入哨兵的代码中<code>do-while</code>循环中不需要检查每次j是否越界，这对于程序速度的提升作用巨大，特别是在数据量很大的情况之下。<br>这里哨兵有两个作用：</p>
<ul>
<li>进入查找(插入位置)循环之前，它保存了 R[i]的副本，使不致于因记录后移而丢失 R[i]的内容；</li>
<li>它的主要作用是：在查找循环中”监视”下标变量j是否越界。一旦越界(即 j=0)，因为 R[0].key和自己比较，循环判定条件不成立使得查找循环结束，从而避免了在该循环内的每一次均要检测j是否越界(即省略了循环判定条件”j&gt;=1”)</li>
</ul>
<h4 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h4><p>时间复杂度：O(n)-O(n^2)<br>空间复杂度：O(n)<br>辅助空间复杂度：O(1)<br>是一个就地排序，稳定的排序方法</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序(Shell Sort)是插入排序的一种。因 D.L.Shell 于 1959 年提出而得名.相对直接排序有较大的改进。希尔排序又叫缩小增量排序</p>
<h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h3><ul>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj(i&lt;j)，tk=1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m的子序列，分别对各子序列进行直接插入排序。仅增量因子为1时，整个序列作为一个序列来处理，序列长度即为整个序列的长度</li>
</ul>
<p>我们简单处理增量序列：增量序列d = {n/2 ,n/4, n/8 …..1} n为要排序数的个数<br>即：先将要排序的一组记录按某个增量d（n/2,n为要排序数的个数）分成若干组子序列，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。继续不断缩小增量直至为1，最后使用直接插入排序完成排序。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n ,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i &lt;&lt;”:”;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt;<span class="number">8</span>; j++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[j] &lt;&lt;” “;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    直接插入排序的一般形式</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">    @param int dk 缩小增量，如果是直接插入排序，dk=1</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellInsertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> dk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= dk; i&lt;n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; a[i-dk])&#123; <span class="comment">//若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入</span></span><br><span class="line">            <span class="keyword">int</span> j = i-dk;</span><br><span class="line">            <span class="keyword">int</span> x = a[i]; <span class="comment">//复制为哨兵，即存储待排序元素</span></span><br><span class="line">            a[i] = a[i-dk]; <span class="comment">//首先后移一个元素</span></span><br><span class="line">            <span class="keyword">while</span>(x &lt; a[j])&#123; <span class="comment">//查找在有序表的插入位置</span></span><br><span class="line">                a[j+dk] = a[j];</span><br><span class="line">                j -= dk; <span class="comment">//元素后移</span></span><br><span class="line">            &#125;</span><br><span class="line">            a[j+dk] = x; <span class="comment">//插入到正确位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        print(a, n,i );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    先按增量d（n/2,n为要排序数的个数进行希尔排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dk = n/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>( dk &gt;= <span class="number">1</span> )&#123;</span><br><span class="line">        ShellInsertSort(a, n, dk);</span><br><span class="line">        dk = dk/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="comment">//ShellInsertSort(a,8,1); //直接插入排序</span></span><br><span class="line">    shellSort(a,<span class="number">8</span>); <span class="comment">//希尔插入排序</span></span><br><span class="line">    print(a,<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><p>希尔排序时效分析很难，关键码的比较次数与记录移动次数依赖于增量因子序列d的选取，特定情况下可以准确估算出关键码的比较次数和记录的移动次数。目前还没有人给出选取最好的增量因子序列的方法。增量因子序列可以有各种取法，有取奇数的，也有取质数的，但需要注意：增量因子中除1 外没有公因子，且最后一个增量因子必须为1。希尔排序方法是一个不稳定的排序方法</p>
<h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><p>两两比较待排序记录的关键字，发现两个记录的次序相反时即进行交换，直到没有反序的记录为止。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>将被排序的记录数组 R[1..n]垂直排列，每个记录 R[i]看作是重量为 R[i].key 的气泡。根据轻气泡不能在重气泡之下的原则，从下往上扫描数组 R：凡扫描到违反本原则的轻气泡，就使其向上”飘浮”。如此反复进行，直到最后任何两个气泡都是轻者在上，重者在下为止。</p>
<h3 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h3><p>假如现在需要对长度为n的数组a从小到大排序，从右向左两两比较，遇到不符合规则的就交换。这样经过一次扫描之后，最小的数就一定到了最前面，经过第二次扫描之后第二小的数就一定到了第二的位置，以此类推，经过n-1次扫描之后，排序就完成了。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>改进前：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> length=<span class="number">10</span>;</span><br><span class="line">    <span class="comment">//外循环控制扫描的次数，只需要扫描n-1次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=length<span class="number">-1</span>;j&gt;=i;j--)&#123;<span class="comment">//从底部扫描起，有不符合规则的则交换</span></span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[j<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=a[j];</span><br><span class="line">                a[j]=a[j<span class="number">-1</span>];</span><br><span class="line">                a[j<span class="number">-1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;length;k++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[k]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在经过n-1次外层循环之后，我们就保证一定可以达到序列有序的目标。但是，序列也有可能在中间的某层循环中就已经达到了有序，这时后面的剩下的循环就是做无用功。一个比较极端的例子，我们需要排序的数组已经就是从小到大排列的，那么会发生什么呢？这时里层循环中的判断条件<code>a[j]&lt;a[j-1]</code>永远不会成立，if语句内的内容永远不会执行。也就是说，在这种情况下，一次外层循环过后，就应该停止。我们可以基于这一点来做优化。</p>
<p>改进后：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> length=<span class="number">10</span>;</span><br><span class="line">    <span class="comment">//外循环控制扫描的次数，只需要扫描n-1次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=length<span class="number">-1</span>;j&gt;=i;j--)&#123;<span class="comment">//从底部扫描起，有不符合规则的则交换</span></span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[j<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=a[j];</span><br><span class="line">                a[j]=a[j<span class="number">-1</span>];</span><br><span class="line">                a[j<span class="number">-1</span>]=temp;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            <span class="comment">//说明此时数据已经有序，不必继续循环了。</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;length;k++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[k]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li><p>算法的最好时间复杂度<br>若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数C和记录移动次数M均达到最小值：<br>Cmin=n-1<br>Mmin=0。<br>冒泡排序最好的时间复杂度为 O(n)。</p>
</li>
<li><p>算法的最坏时间复杂度<br>若初始文件是反序的，需要进行 n-1 趟排序。每趟排序要进行 n-i 次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：<br>Cmax=n(n-1)/2=O(n^2)<br>Mmax=3n(n-1)/2=O(n^2)<br>冒泡排序的最坏时间复杂度为 O(n^2)。</p>
</li>
<li><p>算法的平均时间复杂度为 O(n2)<br>虽然冒泡排序不一定要进行 n-1 趟，但由于它的记录移动次数较多，故平均时间性能比直接插入排序要差得多。</p>
</li>
<li><p>算法稳定性<br>冒泡排序是就地排序，且它是稳定的。</p>
</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是 C.R.A.Hoare 于 1962 年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。</p>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>就以将序列按从小到大排列为例，任意取序列中的某一元素为基准元素，然后把比基准元素小的元素全放到基准元素的左边，把比基准元素大的元素全放到基准元素的右边。这样基准元素就归位了。基准元素左右两边分别得到了两个新的无序序列，我们可以对这两个无序序列做同样的操作，就这样递归下去，直到所有的元素都归位为止。</p>
<h3 id="具体实现-3"><a href="#具体实现-3" class="headerlink" title="具体实现"></a>具体实现</h3><p><img src="/images/qs1.png" alt="qs1"><br>假如我们以将上图的序列按照从小到大排列为例。由于基准元素的选取具有随机性，我在这里每次就直接以序列最左边的那个数作为基准元素(这里的基准元素就是６)。我们设定两个哨兵：ｉ和ｊ，分别指向序列的第一个元素和最后一个元素。然后将j向左移动(一定是ｊ先开始移动)，去找一个比６小的数，找到之后就停下。然后让ｉ向右移动，找到一个比６大的元素，找到之后也停下来。这时两个哨兵就可以交换两者的元素了。如下图：<br><img src="/images/qs2.png" alt="qs1"></p>
<p>交换后：<br><img src="/images/qs3.png" alt="qs1"></p>
<p>同样的这时仍然是j先开始向左移动，去找比６小的元素，找到后停下来。i开始向右移动，找到一个比6大的元素。然后交换。<br><img src="/images/qs4.png" alt="qs1"><br>交换后：<br><img src="/images/qs5.png" alt="qs1"></p>
<p>重复上面的j,i移动过程，但是这一次好像出现了一定小问题，i和j碰头了！<br><img src="/images/qs6.png" alt="qs1"><br>这时就需要把我们的基准元素和当前i,j共同指向的元素交换位置即可。<br><img src="/images/qs7.png" alt="qs1"><br>交换后：<br><img src="/images/qs8.png" alt="qs1"><br>至此，我们的基准元素就归位了，基准元素的两边的又得到了两个新的无序序列，我们只需要对他们使用同样的方法处理即可。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>快速排序可以使用两种方式实现，分别是递归法和迭代法。</p>
<h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">101</span>],n;<span class="comment">//定义全局变量，这两个变量需要在子函数中使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,t,temp;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">                                    </span><br><span class="line">    temp=a[left]; <span class="comment">//temp中存的就是基准数</span></span><br><span class="line">    i=left;</span><br><span class="line">    j=right;</span><br><span class="line">    <span class="keyword">while</span>(i!=j)</span><br><span class="line">    &#123;</span><br><span class="line">                   <span class="comment">//顺序很重要，要先从右边开始找</span></span><br><span class="line">                   <span class="keyword">while</span>(a[j]&gt;=temp &amp;&amp; i&lt;j)</span><br><span class="line">                            j--;</span><br><span class="line">                   <span class="comment">//再找右边的</span></span><br><span class="line">                   <span class="keyword">while</span>(a[i]&lt;=temp &amp;&amp; i&lt;j)</span><br><span class="line">                            i++;</span><br><span class="line">                   <span class="comment">//交换两个数在数组中的位置</span></span><br><span class="line">                   <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">                   &#123;</span><br><span class="line">                            t=a[i];</span><br><span class="line">                            a[i]=a[j];</span><br><span class="line">                            a[j]=t;</span><br><span class="line">                   &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最终将基准数归位</span></span><br><span class="line">    a[left]=a[i];</span><br><span class="line">    a[i]=temp;</span><br><span class="line">                                 </span><br><span class="line">    quicksort(left,i<span class="number">-1</span>);<span class="comment">//继续处理左边的，这里是一个递归的过程</span></span><br><span class="line">    quicksort(i+<span class="number">1</span>,right);<span class="comment">//继续处理右边的 ，这里是一个递归的过程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,t;</span><br><span class="line">    <span class="comment">//读入数据</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    quicksort(<span class="number">1</span>,n); <span class="comment">//快速排序调用</span></span><br><span class="line">                                 </span><br><span class="line">    <span class="comment">//输出排序后的结果</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line">    <span class="keyword">int</span> max;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max, <span class="keyword">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = a[min];</span><br><span class="line">    <span class="keyword">int</span> i = min;</span><br><span class="line">    <span class="keyword">int</span> j = max;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">myStack</span>[100];</span></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">    myStack[top].min = min;</span><br><span class="line">    myStack[top].max = max;</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//min max 记录当前处理的这个区间的左极限和有极限</span></span><br><span class="line">        i = min = myStack[top].min;</span><br><span class="line">        j = max = myStack[top].max;</span><br><span class="line">        top--;</span><br><span class="line">        key = a[min];</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> ((i &lt; j) &amp;&amp; (key &lt;= a[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = temp;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ((i &lt; j) &amp;&amp; (key &gt;= a[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                temp = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = temp;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">//处理一次即将比绑定值小的全部放左边 比绑定值大的放右边</span></span><br><span class="line">        <span class="keyword">if</span> (min &lt; i - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            top++;</span><br><span class="line">            myStack[top].min = min;</span><br><span class="line">            myStack[top].max = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max &gt; i + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            top++;</span><br><span class="line">            myStack[top].min = i + <span class="number">1</span>;</span><br><span class="line">            myStack[top].max = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">14</span>] = &#123;<span class="number">20</span>,<span class="number">2</span>,<span class="number">52</span>,<span class="number">23</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d "</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    quickSort(<span class="number">0</span>, <span class="number">13</span>, a);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d "</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><p>在数据量很大的情况下，快速排序是在时间和空间综合方面做的非常好的排序方法之一。<br>最坏时间复杂度：O(n^2)<br>最好时间复杂度：O(nlogn)<br>快速排序是不稳定的。</p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>依然以将序列从小到大排列为例，选择排序的思想是这样的：既然排序之后第一位一定是放着最小的元素，第二位是放着第二小的元素……那么我们就可以在序列中先找到最小的元素放在第一位，然后从第二位开始找余下的数据的最小值并且放在第二位，然后从第三位找余下的数据的最小值并且放在第三位，以此类推，直达排序完成。</p>
<h3 id="具体实现-4"><a href="#具体实现-4" class="headerlink" title="具体实现"></a>具体实现</h3><p>以数组a为例，外层循环从a[0]开始，里层循环从a[1]开始，如果a[1]小于a[0]则交换之，接着分别比较a[2],a[3],a[4]……和a[0]的大小，谁更小谁就去坐a[0]的位置。就这样经过一轮的循环，就选择出来了最小的元素放在了a[0]的位置，接下来外层循环从a[1]开始(看看剩下的元素中谁最小，谁就可以坐a[1]这个位置)，里层循环从a[2]开始，依次类推。</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Select Sort</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">8</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">27</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;<span class="number">10</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[j])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=a[i];</span><br><span class="line">                a[i]=a[j];</span><br><span class="line">                a[j]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[k]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="直接选择排序的改进"><a href="#直接选择排序的改进" class="headerlink" title="直接选择排序的改进"></a>直接选择排序的改进</h3><p>简单选择排序的改进——二元选择排序<br>简单选择排序，每趟循环只能确定一个元素排序后的定位。我们可以考虑改进为每趟循环确定两个元素（当前趟最大和最小记录）的位置,从而减少排序所需的循环次数。改进后对n个数据进行排序，最多只需进行[n/2]趟循环即可。具体实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> r[],<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i ,j , min ,max, tmp;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span> ;i &lt;= n/<span class="number">2</span>;i++) &#123;</span><br><span class="line">        <span class="comment">// 做不超过n/2趟选择排序</span></span><br><span class="line">        min = i; max = i ; <span class="comment">//分别记录最大和最小关键字记录位置</span></span><br><span class="line">        <span class="keyword">for</span> (j= i+<span class="number">1</span>; j&lt;= n-i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (r[j] &gt; r[max]) &#123;</span><br><span class="line">                max = j ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r[j]&lt; r[min]) &#123;</span><br><span class="line">                min = j ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//该交换操作还可分情况讨论以提高效率</span></span><br><span class="line">    tmp = r[i<span class="number">-1</span>]; r[i<span class="number">-1</span>] = r[min]; r[min] = tmp;</span><br><span class="line">    tmp = r[n-i]; r[n-i] = r[max]; r[max] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li>关键字比较次数<br>无论文件初始状态如何，在第 i 趟排序中选出最小关键字的记录，需做 n-i 次比较，因此，总的比较次数为： n(n-1)/2=O(n2)</li>
<li>记录的移动次数<br>当初始文件为正序时，移动次数为 0<br>文件初态为反序时，每趟排序均要执行交换操作，总的移动次数取最大值 3(n-1)。<br>直接选择排序的平均时间复杂度为 O(n2)。<br>直接选择排序是一个就地排序</li>
<li>稳定性分析<br>直接选择排序是不稳定的</li>
</ul>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序是一种树形选择排序，是对直接选择排序的有效改进。</p>
<h3 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h3><p>堆的定义如下：具有n个元素的序列（k1,k2,…,kn),当且仅当满足下面的条件时称之为堆。<br><img src="/images/defineheap.jpg" alt="堆定义"><br>由堆的定义可以看出，堆顶元素（即第一个元素）必为最小项（小顶堆)或最大项(大顶堆)。<br>若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的。如：<br>(a）大顶堆序列：（96, 83,27,38,11,09)<br>(b) 小顶堆序列：（12，36，24，85，47，30，53，91）</p>
<p><img src="/images/heap3.jpg" alt="heap3"><br>初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树）， 调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大)的元素。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。<br>因此，实现堆排序需解决两个问题：</p>
<ul>
<li>如何将n 个待排序的数建成堆；</li>
<li>输出堆顶元素后，怎样调整剩余n-1个元素，使其成为一个新堆。</li>
</ul>
<p>首先讨论第二个问题：输出堆顶元素后，对剩余n-1元素重新建成堆的调整过程。<br>调整小顶堆的方法：<br>1）设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶（（最后一个元素与堆顶进行交换），堆被破坏，其原因仅是根结点不满足堆的性质。<br>2）将根结点与左、右子树中较小元素的进行交换。<br>3）若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法 （2）.<br>4）若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法 （2）.<br>5）继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。<br>称这个自根结点到叶子结点的调整过程为筛选。如图：<br><img src="/images/heap2.jpg" alt="heap"></p>
<p>再讨论对n 个元素初始建堆的过程。<br>建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。<br>1）n 个结点的完全二叉树，则最后一个结点是第个结点的子树。<br>2）筛选从第个结点为根的子树开始，该子树成为堆。<br>3）之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。<br>如图建堆初始过程：无序序列：（49，38，65，97，76，13，27，49）<br><img src="/images/heapsort.jpg" alt="堆排序"><br><img src="/images/heaptail.jpg" alt="detail"><br>算法的实现：<br>从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。</p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[j] &lt;&lt;” “;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    已知H[s…m]除了H[s] 外均满足堆的定义</span></span><br><span class="line"><span class="comment">    调整H[s],使其成为大顶堆.即将对第s个结点为根的子树筛选,</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">    @param H是待调整的堆数组</span></span><br><span class="line"><span class="comment">    @param s是待调整的数组元素的位置</span></span><br><span class="line"><span class="comment">    @param length是数组的长度</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> H[],<span class="keyword">int</span> s, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = H[s];</span><br><span class="line">    <span class="keyword">int</span> child = <span class="number">2</span>*s+<span class="number">1</span>; <span class="comment">//左孩子结点的位置。(i+1 为当前调整结点的右孩子结点的位置)</span></span><br><span class="line">    <span class="keyword">while</span> (child &lt; length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(child+<span class="number">1</span> &lt;length &amp;&amp; H[child]&lt;H[child+<span class="number">1</span>])&#123; <span class="comment">// 如果右孩子大于左孩子(找到比当前待调整结点大的孩子结点)</span></span><br><span class="line">            ++child ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(H[s]&lt;H[child]) &#123; <span class="comment">// 如果较大的子结点大于父结点</span></span><br><span class="line">            H[s] = H[child]; <span class="comment">// 那么把较大的子结点往上移动，替换它的父结点</span></span><br><span class="line">            s = child; <span class="comment">// 重新设置s ,即待调整的下一个结点的位置</span></span><br><span class="line">            child = <span class="number">2</span>*s+<span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 如果当前待调整结点大于它的左右孩子，则不需要调整，直接退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        H[s] = tmp; <span class="comment">// 当前待调整的结点放到比其大的孩子结点位置上</span></span><br><span class="line">    &#125;</span><br><span class="line">    print(H,length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    初始堆进行调整</span></span><br><span class="line"><span class="comment">    将H[0..length-1]建成堆</span></span><br><span class="line"><span class="comment">    调整完之后第一个元素是序列的最小的元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildingHeap</span><span class="params">(<span class="keyword">int</span> H[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//最后一个有孩子的节点的位置 i= (length -1) / 2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (length <span class="number">-1</span>) / <span class="number">2</span> ; i &gt;= <span class="number">0</span>; –i)</span><br><span class="line">        HeapAdjust(H,i,length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    堆排序算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> H[],<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始堆</span></span><br><span class="line">    BuildingHeap(H, length);</span><br><span class="line">    <span class="comment">//从最后一个元素开始对序列进行调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; –i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//交换堆顶元素H[0]和堆中最后一个元素</span></span><br><span class="line">        <span class="keyword">int</span> temp = H[i]; </span><br><span class="line">        H[i] = H[<span class="number">0</span>];</span><br><span class="line">        H[<span class="number">0</span>] = temp;</span><br><span class="line">        <span class="comment">//每次交换堆顶元素和堆中最后一个元素之后，都要对堆进行调整</span></span><br><span class="line">        HeapAdjust(H,<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> H[<span class="number">10</span>] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;”初始值：”;</span><br><span class="line">    print(H,<span class="number">10</span>);</span><br><span class="line">    HeapSort(H,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//selectSort(a, 8);</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;”结果：”;</span><br><span class="line">    print(H,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h3><p>设树深度为k,(k=(log<sub>2</sub>n)+1)。从根到叶的筛选，元素比较次数至多2(k-1)次，交换记录至多k 次。所以，在建好堆后，排序过程中的筛选次数不超过下式：<br>2[(log<sub>2</sub>(n-1))+(log<sub>2</sub>(n-2))+……+log<sub>2</sub>2] &lt; 2nlog<sub>2</sub>n<br>而建堆时的比较次数不超过4n次，因此堆排序最坏情况下，时间复杂度也为：O(nlogn)</p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h2><p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。<br>归并排序示例：<br><img src="/images/mergesort.jpg" alt="mergesort"> </p>
<h2 id="具体实现-5"><a href="#具体实现-5" class="headerlink" title="具体实现"></a>具体实现</h2><p>设r[i…n]由两个有序子表r[i…m]和r[m+1…n]组成，两个子表长度分别为n-i+1、n-m。</p>
<ol>
<li>j=m+1；k=i；i=i; //置两个子表的起始下标及辅助数组的起始下标</li>
<li>若i&gt;m 或j&gt;n，转⑷ //其中一个子表已合并完，比较选取结束</li>
<li>//选取r[i]和r[j]较小的存入辅助数组rf<br>如果r[i]&lt;r[j]，rf[k]=r[i]； i++； k++； 转⑵<br>否则，rf[k]=r[j]； j++； k++； 转⑵</li>
<li>//将尚未处理完的子表中元素存入rf<br>如果i&lt;=m,将r[i…m]存入rf[k…n] //前一子表非空<br>如果j&lt;=n,将r[j…n] 存入rf[k…n] //后一子表非空</li>
<li>合并结束。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//将r[i…m]和r[m +1 …n]归并到辅助数组rf[i…n]  </span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElemType *r,ElemType *rf, <span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">     <span class="keyword">int</span> j,k;  </span><br><span class="line">     <span class="keyword">for</span>(j=m+<span class="number">1</span>,k=i; i&lt;=m &amp;&amp; j &lt;=n ; ++k)&#123;  </span><br><span class="line">         <span class="keyword">if</span>(r[j] &lt; r[i]) </span><br><span class="line">            rf[k] = r[j++];  </span><br><span class="line">         <span class="keyword">else</span> </span><br><span class="line">            rf[k] = r[i++];  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">while</span>(i &lt;= m)  rf[k++] = r[i++];  </span><br><span class="line">     <span class="keyword">while</span>(j &lt;= n)  rf[k++] = r[j++];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><h3 id="归并的迭代算法"><a href="#归并的迭代算法" class="headerlink" title="归并的迭代算法"></a>归并的迭代算法</h3><p>1个元素的表总是有序的。所以对n个元素的待排序列，每个元素可看成1个有序子表。对子表两两合并生成n/2个子表，所得子表除最后一个子表长度可能为1外，其余子表长度均为2。再进行两两合并，直到生成n个元素按关键码有序的表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j&lt;n; j++)&#123;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[j] &lt;&lt;<span class="string">"  "</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//将r[i…m]和r[m +1 …n]归并到辅助数组rf[i…n]  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElemType *r,ElemType *rf, <span class="keyword">int</span> i, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> j,k;  </span><br><span class="line">    <span class="keyword">for</span>(j=m+<span class="number">1</span>,k=i; i&lt;=m &amp;&amp; j &lt;=n ; ++k)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(r[j] &lt; r[i]) rf[k] = r[j++];  </span><br><span class="line">        <span class="keyword">else</span> rf[k] = r[i++];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= m)  rf[k++] = r[i++];  </span><br><span class="line">    <span class="keyword">while</span>(j &lt;= n)  rf[k++] = r[j++];  </span><br><span class="line">    print(rf,n+<span class="number">1</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(ElemType *r, ElemType *rf, <span class="keyword">int</span> lenght)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;  </span><br><span class="line">    ElemType *q = r ;  </span><br><span class="line">    ElemType *tmp ;  </span><br><span class="line">    <span class="keyword">while</span>(len &lt; lenght) &#123;  </span><br><span class="line">        <span class="keyword">int</span> s = len;  </span><br><span class="line">        len = <span class="number">2</span> * s ;  </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">while</span>(i+ len &lt;lenght)&#123;  </span><br><span class="line">            Merge(q, rf,  i, i+ s<span class="number">-1</span>, i+ len<span class="number">-1</span> ); <span class="comment">//对等长的两个子表合并  </span></span><br><span class="line">            i = i+ len;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(i + s &lt; lenght)&#123;  </span><br><span class="line">            Merge(q, rf,  i, i+ s <span class="number">-1</span>, lenght <span class="number">-1</span>); <span class="comment">//对不等长的两个子表合并  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        tmp = q; q = rf; rf = tmp; <span class="comment">//交换q,rf，以保证下一趟归并时，仍从q 归并到rf  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">8</span>&#125;;  </span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">10</span>];  </span><br><span class="line">    MergeSort(a, b, <span class="number">10</span>);  </span><br><span class="line">    print(b,<span class="number">10</span>);  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"结果："</span>;  </span><br><span class="line">    print(a,<span class="number">10</span>);  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="两路归并的递归算法"><a href="#两路归并的递归算法" class="headerlink" title="两路归并的递归算法"></a>两路归并的递归算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MSort</span><span class="params">(ElemType *r, ElemType *rf,<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    ElemType *rf2;  </span><br><span class="line">    <span class="keyword">if</span>(s==t)</span><br><span class="line">        r[s] = rf[s];  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">int</span> m=(s+t)/<span class="number">2</span>;          <span class="comment">//平分p表 </span></span><br><span class="line">        MSort(r, rf2, s, m);        <span class="comment">//递归地将p[s…m]归并为有序的p2[s…m]  </span></span><br><span class="line">        MSort(r, rf2, m+<span class="number">1</span>, t);      <span class="comment">//递归地将p[m+1…t]归并为有序的p2[m+1…t]  </span></span><br><span class="line">        Merge(rf2, rf, s, m+<span class="number">1</span>,t);   <span class="comment">//将p2[s…m]和p2[m+1…t]归并到p1[s…t]  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort_recursive</span><span class="params">(ElemType *r, ElemType *rf, <span class="keyword">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//对顺序表*p 作归并排序</span></span><br><span class="line">    MSort(r, rf,<span class="number">0</span>, n<span class="number">-1</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分配排序"><a href="#分配排序" class="headerlink" title="分配排序"></a>分配排序</h1><p>分配排序的基本思想：排序过程无须比较关键字，而是通过”分配”和”收集”过程来实现排序.它们的时间复杂度可达到线性阶：O(n)。</p>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><h3 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h3><p>设置若干个桶，依次扫描待排序的记录R[0]，R[1]，…，R[n-1]，把关键字等于k的记录全都装入到第k个箱子里(分配)，然后按序号依次将各非空的箱子首尾连接起来(收集)。这样就可以实现不经过比较，而经过分配和收集就排序成功。</p>
<p>例如：要将一副混洗的 52 张扑克牌按点数 A&lt;2&lt;…&lt;J&lt;Q&lt;K 排序，需设置 13 个”箱子”，排序时依次将每张牌按点数放入相应的箱子里，然后依次将这些箱子首尾相接，就得到了按点数递增序排列的一副牌。<br>又例如要对大小为[1..1000]范围内的n个整数A[1..n]排序：</p>
<ul>
<li>首先,可以把桶设为大小为10的范围，具体而言，设集合B[1]存储<code>[1..10]</code>的整数，集合B[2]存储<code>(10..20]</code>的整数，……集合B[i]存储<code>((i-1)*10,   i*10]</code>的整数，i=1,2,..100。总共有100个桶。  </li>
<li>然后，对A[1..n]从头到尾扫描一遍，把每个A[i]放入对应的桶B[j]中。再对这100个桶中每个桶里的数字排序，这时可用冒泡，选择，乃至快排，一般来说任何排序法都可以。</li>
<li>最后，依次输出每个桶里面的数字，且每个桶中的数字从小到大输出，这样就得到所有数字排好序的一个序列了。  </li>
</ul>
<p>假设有n个数字，有m个桶，如果数字是平均分布的，则每个桶里面平均有n/m个数字。如果对每个桶中的数字采用快速排序，那么整个算法的复杂度是<br><code>O(n+m*n/m*log(n/m))=O(n+nlogn-nlogm)</code><br>从上式看出，当m接近n的时候，桶排序复杂度接近O(n)<br>当然，以上复杂度的计算是基于输入的n个数字是平均分布这个假设的。这个假设是很强的,实际应用中效果并没有这么好。如果所有的数字都落在同一个桶中，那就退化成一般的排序了。  </p>
<p>前面说的几大排序算法,大部分时间复杂度都是O(n^2),也有部分排序算法时间复杂度是O(nlogn)。而桶式排序却能实现O(n)的时间复杂度。但桶排序的缺点是：</p>
<ul>
<li>首先是空间复杂度比较高，需要的额外开销大。排序有两个数组的空间开销，一个存放待排序数组，一个就是所谓的桶，比如待排序值是从0到m-1，那就需要m个桶，这个桶数组就要至少m个空间。</li>
<li>其次待排序的元素都要在一定的范围内等等。</li>
</ul>
<p>桶式排序是一种分配排序。分配排序的特定是不需要进行关键码的比较，但前提是要知道待排序列的一些具体情况。桶子的类型一般设为链表为宜。</p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="多关键码排序实例"><a href="#多关键码排序实例" class="headerlink" title="多关键码排序实例:"></a>多关键码排序实例:</h3><p>扑克牌中52张牌，可按花色和面值分成两个字段，其大小关系为：<br>花色： 梅花&lt; 方块&lt; 红心&lt; 黑心 <img src="/images/p1.jpg" alt="p1"><br>面值： 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; 10 &lt; J &lt; Q &lt; K &lt; A<br>若对扑克牌按花色、面值进行升序排序，得到如下序列：<br><img src="/images/p2.jpg" alt="p2"><br><img src="/images/p3.jpg" alt="p3"><br>即两张牌，若花色不同，不论面值怎样，花色低的那张牌小于花色高的，只有在同花色情况下，大小关系才由面值的大小确定。这就是多关键码排序。</p>
<p>为得到排序结果，我们讨论两种排序方法。</p>
<ul>
<li>方法1：先对花色排序，将其分为4 个组，即梅花组、方块组、红心组、黑心组。再对每个组分别按面值进行排序，最后，将4 个组连接起来即可。</li>
<li>方法2：先按13个面值给出13个编号组(2 号，3 号，…，A 号),将牌按面值依次放入对应的编号组,分成13堆。再按花色给出4个编号组(梅花、方块、红心、黑心)，将2号组中牌取出分别放入对应花色组,再将3号组中牌取出分别放入对应花色组，……，这样，4个花色组中均按面值有序，然后，将4个花色组依次连接起来即可。</li>
</ul>
<p>设n个元素的待排序列包含d个关键码{k1，k2，…，kd}，则称序列对关键码{k1，k2，…，kd}有序是指：对于序列中任两个记录r[i]和r<a href="1≤i≤j≤n">j</a>都满足下列有序关系：<br>(K<sub>i</sub><sup>1</sup>,K<sub>i</sub><sup>2</sup>,……,K<sub>i</sub><sup>d</sup>) &lt; (K<sub>j</sub><sup>1</sup>,K<sub>j</sub><sup>2</sup>,……,K<sub>i</sub><sup>d</sup>)<br>其中k1 称为最主位关键码，kd称为最次位关键码。</p>
<h3 id="两种多关键码排序方法："><a href="#两种多关键码排序方法：" class="headerlink" title="两种多关键码排序方法："></a>两种多关键码排序方法：</h3><p>多关键码排序按照从最主位关键码到最次位关键码或从最次位到最主位关键码的顺序逐次排序，分两种方法：</p>
<h4 id="最高位优先-Most-Significant-Digit-first-法，简称MSD法："><a href="#最高位优先-Most-Significant-Digit-first-法，简称MSD法：" class="headerlink" title="最高位优先(Most Significant Digit first)法，简称MSD法："></a>最高位优先(Most Significant Digit first)法，简称MSD法：</h4><p>1）先按k1 排序分组，将序列分成若干子序列，同一组序列的记录中，关键码k1 相等。<br>2）再对各组按k2 排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码kd 对各子组排序后。<br>3）再将各组连接起来，便得到一个有序序列。扑克牌按花色、面值排序中介绍的方法一即是MSD 法。</p>
<h4 id="最低位优先-Least-Significant-Digit-first-法，简称LSD法："><a href="#最低位优先-Least-Significant-Digit-first-法，简称LSD法：" class="headerlink" title="最低位优先(Least Significant Digit first)法，简称LSD法："></a>最低位优先(Least Significant Digit first)法，简称LSD法：</h4><p>1) 先从kd 开始排序，再对kd-1进行排序，依次重复，直到按k1排序分组分成最小的子序列后。<br>2) 最后将各个子序列连接起来，便可得到一个有序的序列, 扑克牌按花色、面值排序中介绍的方法二即是LSD 法。</p>
<h3 id="基于LSD方法的链式基数排序的基本思想"><a href="#基于LSD方法的链式基数排序的基本思想" class="headerlink" title="基于LSD方法的链式基数排序的基本思想"></a>基于LSD方法的链式基数排序的基本思想</h3><p>“多关键字排序”的思想实现“单关键字排序”。对数字型或字符型的单关键字，可以看作由多个数位或多个字符构成的多关键字，此时可以采用“分配 -收集”的方法进行排序，这一过程称作基数排序法，其中每个数字或字符可能的取值个数称为基数。比如，扑克牌的花色基数为4，面值基数为13。在整理扑克 牌时，既可以先按花色整理，也可以先按面值整理。按花色整理时，先按红、黑、方、花的顺序分成4摞（分配），再按此顺序再叠放在一起（收集），然后按面值 的顺序分成13摞（分配），再按此顺序叠放在一起（收集），如此进行二次分配和收集即可将扑克牌排列有序。   </p>
<p>基数排序:<br>是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。<br>算法实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">RadixSort</span><span class="params">(Node L[],length,maxradix)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="keyword">int</span> m,n,k,lsp;  </span><br><span class="line">   k=<span class="number">1</span>;m=<span class="number">1</span>;  </span><br><span class="line">   <span class="keyword">int</span> temp[<span class="number">10</span>][length<span class="number">-1</span>];  </span><br><span class="line">   Empty(temp); <span class="comment">//清空临时空间  </span></span><br><span class="line">   <span class="keyword">while</span>(k&lt;maxradix) <span class="comment">//遍历所有关键字  </span></span><br><span class="line">   &#123;  </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++) <span class="comment">//分配过程  </span></span><br><span class="line">     &#123;  </span><br><span class="line">        <span class="keyword">if</span>(L[i]&lt;m)  </span><br><span class="line">           Temp[<span class="number">0</span>][n]=L[i];  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">           Lsp=(L[i]/m)%<span class="number">10</span>; <span class="comment">//确定关键字  </span></span><br><span class="line">        Temp[lsp][n]=L[i];  </span><br><span class="line">        n++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    CollectElement(L,Temp); <span class="comment">//收集  </span></span><br><span class="line">    n=<span class="number">0</span>;  </span><br><span class="line">    m=m*<span class="number">10</span>;  </span><br><span class="line">    k++;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>各种排序的稳定性，时间复杂度和空间复杂度总结：<br><img src="/images/sum.jpg" alt="sum"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Andrew</p>
              <p class="site-description motion-element" itemprop="description">All In</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">67</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Andrew</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
