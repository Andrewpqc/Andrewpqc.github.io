<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="All In">
<meta property="og:type" content="website">
<meta property="og:title" content="Andrew&#39;s Blog">
<meta property="og:url" content="http://andrewpqc.github.io/page/5/index.html">
<meta property="og:site_name" content="Andrew&#39;s Blog">
<meta property="og:description" content="All In">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Andrew&#39;s Blog">
<meta name="twitter:description" content="All In">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://andrewpqc.github.io/page/5/">





  <title>Andrew's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Andrew's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Stay hungry, Stay foolish.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2017/09/20/Data-manage-in-Docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/20/Data-manage-in-Docker/" itemprop="url">Docker数据管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-20T09:23:01+08:00">
                2017-09-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>生产环境中使用docker，往往需要对数据进行持久化，或者在多个容器之间进行数据共享，这必然涉及容器的数据管理操作。容器中管理数据主要有两种方式：</p>
<ul>
<li>数据卷</li>
<li>数据卷容器</li>
</ul>
<h1 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h1><h2 id="什么是数据卷？"><a href="#什么是数据卷？" class="headerlink" title="什么是数据卷？"></a>什么是数据卷？</h2><p>数据卷是经过特殊设计的目录，可以绕过联合文件系统，为一个或多个容器提供访问。数据卷设计的目的，在于数据的永久化，它完全独立于容器的生存周期，因此docker不会在容器删除时删除其挂载的数据卷，也不会存在垃圾收集机制，对容器引用的数据卷进行处理.</p>
<p><img src="/images/datavolume.jpg" alt="数据卷示意图"></p>
<p>上图可以告诉我们：</p>
<ul>
<li>docker的数据卷是独立于docker的存在，他存在于dockerhost也就是宿主机中，因此他与docker容器的生存周期是分离的。</li>
<li>docker数据卷本质上是存在于docker宿主机的文件系统中</li>
<li>docker数据卷可以是目录也可以是文件</li>
<li>docker容器可以利用数据卷的技术与宿主机进行数据共享</li>
<li>同一个目录或文件可以支持多个容器的访问，这样其实实现了容器间数据的共享和交换。</li>
</ul>
<h2 id="数据卷的特点"><a href="#数据卷的特点" class="headerlink" title="数据卷的特点"></a>数据卷的特点</h2><ul>
<li>数据卷在容器启动时初始化，如果容器使用的镜像在挂载点包含了数据，这些数据会可拷贝到新初始化的数据卷中。</li>
<li>数据卷可以在容器之间共享和重用</li>
<li>可以对数据卷中的内容直接进行修改</li>
<li>数据卷的变化不会影响镜像的更新</li>
<li>卷会一直存在，即使挂载数据卷的容器已经删除</li>
</ul>
<h2 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h2><h3 id="docker-volume子命令"><a href="#docker-volume子命令" class="headerlink" title="docker volume子命令"></a>docker volume子命令</h3><p>docker 1.9引入了新的子命令docker volume,用户可以使用这个命令创建查看和删除数据卷，与此同时，传统的-v参数创建volume的方式也得到了保留。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Usage:	docker volume COMMAND</span><br><span class="line">Options:</span><br><span class="line">      --<span class="built_in">help</span>   Print usage</span><br><span class="line">Commands:</span><br><span class="line">  create      Create a volume</span><br><span class="line">  inspect     Display detailed information on one or more volumes</span><br><span class="line">  ls          List volumes</span><br><span class="line">  prune       Remove all unused volumes</span><br><span class="line">  rm          Remove one or more volumes</span><br></pre></td></tr></table></figure>

<p>创建</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create --name volume1</span><br></pre></td></tr></table></figure>

<p>在用户使用docker创建volume的时候，采用的是默认的local volumedriver,所以volume的文件系统默认使用宿主机的文件系统，如果用户需要创建其他文件系统的volume，则需要使用其他的volumedriver.</p>
<p>docker在创建volume的时候会在宿主机的/var/lib/docker/volume/中创建一个以volume ID为名的目录，并且将volume中的内容存储在名为_data的目录下。</p>
<p>使用docker volume inspect <volume name>命令可以获得该volume包括其在宿主机中该文件夹的位置等信息。</volume></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume inspect volume1</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">        <span class="string">"Labels"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Mountpoint"</span>: <span class="string">"/var/lib/docker/volumes/volume1/_data"</span>,</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"volume1"</span>,</span><br><span class="line">        <span class="string">"Options"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"local"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="为容器添加数据卷"><a href="#为容器添加数据卷" class="headerlink" title="为容器添加数据卷"></a>为容器添加数据卷</h3><p>用户在使用docker run或者docker create创建新容器的时候，可以使用-v选项为容器添加volume(可以多次使用-v选项，为容器添加多个数据卷),用户可以将自行创建或者由docker创建的的volume挂载到容器中，也可以将宿主机上的目录或者文件作为volume挂载到容器中。</p>
<h4 id="宿主机的目录或文件作为数据卷"><a href="#宿主机的目录或文件作为数据卷" class="headerlink" title="宿主机的目录或文件作为数据卷"></a>宿主机的目录或文件作为数据卷</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run  –v  ~/datavolume:/data –it Ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p>-v选项就可以为启动的容器添加数据卷，~/datavolume为宿主机中的目录（这里也可以是一个文件，但是不管值文件夹还是文件都必须使用绝对路径），如果当前宿主机中没有这样的目录，那么容器启动时会自动在当前创建这个目录，这里的话，就是在当前用户的家目录下创建名为datavolume的目录。冒号后面的/data就是对应的容器中的目录。</p>
<p>我们如果在启动的容器的/data目录创建一个文件，并且在文件内写上一些内容。然后退出容器，查看宿主机的~/datavolume目录，则会发现，其中的内容就和我们在容器的/data目录中创建的内容一毛一样。也就是说两者之间的数据实现了同步的共享。</p>
<h4 id="随机名字的数据卷"><a href="#随机名字的数据卷" class="headerlink" title="随机名字的数据卷"></a>随机名字的数据卷</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -v /data ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p>以上的命令创建了一个随机名字的volume,并挂载到容器中的/data目录。要想知道它所挂载的数据卷在宿主机中的位置，可以通过docker volume inspect <volume name>查看。</volume></p>
<h4 id="指定名字的数据卷"><a href="#指定名字的数据卷" class="headerlink" title="指定名字的数据卷"></a>指定名字的数据卷</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create --name volume1</span><br><span class="line">$ docker run -d -v volume1:/data ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p>以上两条命令首先是创建了一个名为volume1的数据卷，然后将其挂载在容器的/data目录。如果不执行第一条命令，直接执行第二条命令的话，docker会代替用户创建名为volume1的volume，并且将其挂载在容器中的/data目录。</p>
<h4 id="为数据卷添加访问权限"><a href="#为数据卷添加访问权限" class="headerlink" title="为数据卷添加访问权限"></a>为数据卷添加访问权限</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run  –v  ~/datavolume:/data:ro Ubuntu  /bin/bash</span><br></pre></td></tr></table></figure>

<p>在-v选项的参数后面添加了一个：ro(read only),这样的话就让这个数据卷变得只读了。<br>注：在退出容器后，可以用docker的inspect命令来查看数据卷的情况，以及读写权限</p>
<h3 id="在dockerfile中创建数据卷"><a href="#在dockerfile中创建数据卷" class="headerlink" title="在dockerfile中创建数据卷"></a>在dockerfile中创建数据卷</h3><p>VOLUME命令<br>如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加多个数据卷</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash">[“/datavolume1”,”/datavolume2”]</span></span><br><span class="line"><span class="comment">#添加一个数据卷</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /date</span></span><br></pre></td></tr></table></figure>

<p>上面的命令所构建的镜像在创建容器时就会在容器的根目录挂载对应数据卷，并且在宿主机的文件系统中随机创建目录分别与容器内的数据卷对应。</p>
<p>与docker run -v不同的是VOLUME不能挂载主机中指定的文件夹，这主要是为了Dockerfile的可移植性。因为不能保证所有的宿主机都有对应的文件夹。</p>
<p>可以用docker inspect命令来查看宿主机上与这两个数据卷对应的目录。但是每次用此镜像运行的容器中的数据卷对应的宿主机的目录是不相同的。这样的话这个镜像所构建的容器们之间就无法进行数据共享。这就有了docker的数据卷容器。</p>
<h1 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h1><p><img src="/images/datavolume2.jpg" alt="数据卷容器示意图"></p>
<h2 id="什么是数据卷容器？"><a href="#什么是数据卷容器？" class="headerlink" title="什么是数据卷容器？"></a>什么是数据卷容器？</h2><p>一个容器挂载数据卷，其他容器通过挂载这个容器实现数据共享，前面的挂载数据卷的容器就叫做数据卷容器。</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#data volume container experience image</span></span><br><span class="line">FORM Ubuntu:latest</span><br><span class="line">VALUME[“/datavolume1”,”/datavolume2”]</span><br><span class="line"><span class="keyword">CMD</span><span class="bash">[“/bin/bash”]</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>如上，我们创建了这样的dockerfile，我们再根据这一dockerfile构建一个镜像image1<br>然后：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --name ct1 image1</span><br></pre></td></tr></table></figure>

<p>我们根据这个镜像创建了一个容器ct1，由上面的内容可知ct1内挂载了两个数据卷/datavolume1,/datavolume2.并且现在docker宿主机上也有两个目录与这两个数据卷相对应。下面我们以ct1为数据卷容器在运行两个容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --volumes-from:ct1 --name ct2 ubuntu /bin/bash	</span><br><span class="line">$ docker run -it --volumes-from:ct1 --name ct3 ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p>这样ct1，ct2，ct3就都拥有了数据卷，他们之间包括和宿主机之间就可以实现数据的共享。并且容器创建好之后，我们可以删除此中的数据卷容器ct1，那么ct2和ct3中的数据卷仍然可以正常使用。虽然数据卷容器在这个容器集群的构建中扮演着重要的角色，但是他只是进行了配置的传递，而容器ct1本身却不起作用，所以即使删除ct1，其他容器可以照样使用。</p>
<p>事实上，当这个集群建好之后，我们删除任意的一个容器，都不会对数据卷产生任何影响。即使删除了所有的挂载的容器，包括ct1,ct2,ct3，数据卷也不会被自动删除，如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时显式使用docker rm -v　CONTAINER_ID命令来指定。</p>
<h2 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h2><p>如果创建容器时从容器中挂载了volume，在/var/lib/docker/volumes/下会生成与volume对应的目录，使用docker rm删除容器并不会删除与volume对应的目录，这些目录会占据不必要的空间。即使可以手动删除，但是由于这些随机生成的目录名称是无意义的随机字符串，要知道他们是否与被删除的容器对应也是十分麻烦的。所以在删除容器时需要对容器中的volume妥善处理。在删除容器时，一并删除volume有一下几种方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对于自己命名的volume,可以直接像下面这样删除即可,这里只有当没有任何容器使用该volume的时候才会删除成功</span></span><br><span class="line">$ docker volume rm &lt;volume name&gt;</span><br><span class="line"><span class="comment">#在删除容器时，一并删除其volume(推荐使用)</span></span><br><span class="line">$ docker rm -v &lt;container_name&gt;</span><br><span class="line"><span class="comment">#在运行容器时使用`docker run --rm`,--rm选项会在容器停止运行时删除容器以及容器所挂载的volume</span></span><br></pre></td></tr></table></figure>

<h2 id="容器与宿主机的数据交换"><a href="#容器与宿主机的数据交换" class="headerlink" title="容器与宿主机的数据交换"></a>容器与宿主机的数据交换</h2><p>使用docker cp命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Usage:	docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</span><br><span class="line">	docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</span><br><span class="line">Copy files/folders between a container and the <span class="built_in">local</span> filesystem</span><br><span class="line">Options:</span><br><span class="line">  -L, --follow-link   Always follow symbol link <span class="keyword">in</span> SRC_PATH</span><br><span class="line">      --<span class="built_in">help</span>          Print usage</span><br></pre></td></tr></table></figure>

<p>上述的docker cp命令只适合纯粹的在容器与宿主机之间交换数据，但是它的灵活性比volume小得多，它不支持数据在容器和宿主机之间的同步。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2017/09/17/cookie-and-session-in-Express-use-redis-to-make-it-work-better/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/17/cookie-and-session-in-Express-use-redis-to-make-it-work-better/" itemprop="url">Express框架中的Cookie，Session，以及Redis使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-17T20:33:05+08:00">
                2017-09-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NodeJS/" itemprop="url" rel="index">
                    <span itemprop="name">NodeJS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文主要包括express框架中cookie和session的使用和需要注意的点，以及redis的使用，如何在express项目中集成redis来缓存session等内容。</p>
<h1 id="Cookie和Session基本原理"><a href="#Cookie和Session基本原理" class="headerlink" title="Cookie和Session基本原理"></a>Cookie和Session基本原理</h1><h2 id="What’s-Cookie"><a href="#What’s-Cookie" class="headerlink" title="What’s Cookie?"></a>What’s Cookie?</h2><p>众所周知，HTTP协议本身是无状态的，服务器不负责维护会话的状态。每次客户端访问完,服务器就会立即断开链接。客户端访问了服务器，服务器不会关心客户端是谁，他只是在人的事先规划之下根据客户端请求报文中包含的信息做出相应的响应，完成了此次响应，就会立即与客户端断开，然后去处理下一个请求(注意：在异步非阻塞的设计之下，服务器并不是完完全全处理完一个请求才处理下一个请求的，node就是这样的设计)。即使下一个请求仍然由同一个客户端发起，服务器也不会有所察觉，他还是会按照一个全新的请求去处理。这样的设计就导致了访问者的身份和状态无法确定，这样的话我们要想在网上做一些具有连贯性的任务就不可实现。比如用户登录，网上购物，游戏的积分，线上学习的进度情况等等。于是cookie出现了。cookie是存储在客户端主机的磁盘上的一串有特定意义的字符串。cookie的实现是客户端和服务器相互配合的结果。目前只要是还在使用的浏览器都支持了cookie的实现。当某一个请求到达服务器，服务器如果需要追踪会话状态的话，就会在响应报文中设置一些特定的数据，这些数据告诉浏览器这个网站需要设置cookie并且cookie中需要包含那些信息。浏览器解析到了相应的信息，就会按照大家事先沟通好的方式，将这些cookie数据写入自己所在主机的磁盘的某一个位置。下一次当再次访问这个网站时，浏览器就会携带之前记录的cookie。这些cookie数据送到服务器，服务器就可以根据它来确定当前来访用户的身份，进而找到数据库中关于此用户的信息，从而确定其会话状态。</p>
<h2 id="What’s-session"><a href="#What’s-session" class="headerlink" title="What’s session?"></a>What’s session?</h2><p>Session同Cookie一样，都是用来解决用户会话的跟踪问题。但是Cookie存在着安全的问题，Cookie中存储的数据必定含有一个可以确定用户身份的关键信息，这一个信息有可能是敏感信息，这样的信息存储在用户磁盘上是极其不安全的。Cookie可以被窃取，被篡改等。虽然也有加密cookie，但是不管怎么说，存储在客户端总是让人不放心的。并且要让客户端每次请求都要带着额外的一堆数据，这对于网络传输来说也是不利的。就在这时Session出现了，session是基于cookie的。但是和cookie不同的是，原来cookie中的数据转移到了服务器端，而客户端则只保留一个无意义的随机字符串，这个无意义的字符串与存储在服务器端的该客户端的相关信息有着一一对应的关系。现在客户端访问这个服务器就只需要带着这一个随机字符串，然后服务器就可以根据这一个字符串确定来访客户的会话状态了。Session与Cookie相比，安全性有了极大的提高，并且减少了客户端访问服务器时所携带的数据量。</p>
<h1 id="在Express中使用Cookie或Session"><a href="#在Express中使用Cookie或Session" class="headerlink" title="在Express中使用Cookie或Session"></a>在Express中使用Cookie或Session</h1><h2 id="Express项目中使用Cookie"><a href="#Express项目中使用Cookie" class="headerlink" title="Express项目中使用Cookie"></a>Express项目中使用Cookie</h2><p>在express 4.x的版本的api中上行的req和下行的res中都有cookie,分别是读取cookie和设置cookie。在express中使用cookie需要用到cookie-parser这一个中间件，此中间件的使用方法是：<br>首先下载cookie-parser(如果你使用express-genarater生成项目的话，就已经下载好了cookie-parser，并且用到了项目中)</p>
<p>###下载cookie-parser</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install cookie-parser --save</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express=<span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> cookieParser=<span class="built_in">require</span>(<span class="string">'cookie-parser'</span>);　<span class="comment">//引包</span></span><br><span class="line">app.use(cookieParser())　　　<span class="comment">//这里的cookieParser()括号中没有字符串就是不带签名的cookie</span></span><br><span class="line"><span class="comment">//下面就可以使用cookie了</span></span><br><span class="line"><span class="comment">//设置cookie</span></span><br><span class="line">res.cookie(<span class="string">"username"</span>,<span class="string">"xiaoming"</span> ,&#123;<span class="attr">domain</span>: <span class="string">'.example.com'</span>, <span class="attr">path</span>: <span class="string">'/admin'</span>, <span class="attr">secure</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="comment">//这里的vaule是一个简单字符串也可以是一个JSON格式的字符串</span></span><br><span class="line"><span class="comment">//读取cookie</span></span><br><span class="line">req.cookies.username</span><br><span class="line">                 -&gt;<span class="string">"xiaoming"</span></span><br></pre></td></tr></table></figure>

<h3 id="设置cookie时的参数"><a href="#设置cookie时的参数" class="headerlink" title="设置cookie时的参数"></a>设置cookie时的参数</h3><p>domain　：cookie在什么域名下有效，类型为String,。默认为网站域名<br>expires : cookie过期日期，类型为Date。如果没有设置或者设置为0，那么该cookie只在这个这个session有效，即关闭浏览器后，这个cookie会被浏览器删除。<br>httpOnly: 只能被web server访问，类型Boolean。不能通过js代码来读取cookie<br>maxAge : 实现expires的功能，设置cookie过期的时间，指明从现在开始，多少毫秒以后，cookie到期。<br>path : cookie在什么路径下有效，默认为’/‘，类型为String<br>secure ：只能被HTTPS使用，类型Boolean，默认为false<br>signed :使用签名，类型Boolean，默认为false。express会使用req.secret来完成签名，需要cookie-parser配合使用,将其设为true时，在取ｃｏｏｋｉｅ时要用 req.signedCookie（）方法<br>sameSite : Boolean or String Value of the “SameSite” Set-Cookie attribute.</p>
<h3 id="签名cookie"><a href="#签名cookie" class="headerlink" title="签名cookie"></a>签名cookie</h3><p>要使用带签名的cookie(一种更安全的cookie的处理方式)，需要cookie-parser的配合：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用cookie-parser中间件的时候要传入secret</span></span><br><span class="line">app.use(cookieParser(<span class="string">"This is a secret that signedcookie needed"</span>));</span><br><span class="line"><span class="comment">//设置cookie时要将signed设为true</span></span><br><span class="line">res.cookie(<span class="string">"username"</span>,<span class="string">"andrewpqc"</span>,&#123;<span class="attr">signed</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"><span class="comment">//读取签名cookie时要使用req.signedCookies</span></span><br><span class="line">req.signedCookies.username</span><br><span class="line">					-&gt;andrewpqc</span><br></pre></td></tr></table></figure>

<h3 id="清除cookie"><a href="#清除cookie" class="headerlink" title="清除cookie"></a>清除cookie</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.clearCookie(<span class="string">'name'</span>, &#123; <span class="attr">path</span>: <span class="string">'/admin'</span> &#125;);</span><br><span class="line"><span class="comment">//这里设置的path要保持和设置该cookie时的一致</span></span><br></pre></td></tr></table></figure>

<h2 id="Express项目中使用Session"><a href="#Express项目中使用Session" class="headerlink" title="Express项目中使用Session"></a>Express项目中使用Session</h2><p>Express中session的实现依赖于express-session</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save express-session</span><br></pre></td></tr></table></figure>

<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express=<span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> session=<span class="built_in">require</span>(<span class="string">'express-session'</span>);</span><br><span class="line"><span class="keyword">var</span> app=express();</span><br><span class="line">app.use(session(&#123;</span><br><span class="line">	secret:<span class="string">"keyboard cat"</span>,</span><br><span class="line">	resave:<span class="literal">false</span>,</span><br><span class="line">	saveUninitialized:<span class="literal">true</span>,</span><br><span class="line">	<span class="comment">//cookie:&#123;secret:true&#125;//这里设为true时，是https协议使用的</span></span><br><span class="line">	<span class="comment">//注意在实验时这里的secret要设为ｆａｌｓｅ，因为本地用的是http协议</span></span><br><span class="line">&#125;));</span><br><span class="line">app.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(req.session.login)&#123;</span><br><span class="line">		res.send(<span class="string">'欢迎您'</span>＋<span class="string">','</span>+req.session.username)</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		res.send(<span class="string">'你还没有登录，请登录！'</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">'/login'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">	req.session.login=<span class="literal">true</span>;        <span class="comment">//设置session</span></span><br><span class="line">	req.session.username=<span class="string">"xiaoming"</span>;<span class="comment">//设置session</span></span><br><span class="line">	req.session.cookie.expires=<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.now()+<span class="number">3600000</span>);<span class="comment">//设置超时时间,这里１小时后失效</span></span><br><span class="line">	res.send(<span class="string">'你已经成功登陆'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>注意，这里在使用时和cookie不同，cookie的req,res都对应有cookie接口，分别读取和设置cookie。而session则不同，无论是读取还是设置，都是通过req.session这一个接口完成的。session的数据并不是存储在cookie中，cookie中存储的仅仅是session ID,而其他的有用的信息存储在服务器端。</p>
<h3 id="可选参数以及详细说明"><a href="#可选参数以及详细说明" class="headerlink" title="可选参数以及详细说明"></a>可选参数以及详细说明</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(session(OPTIONS))</span><br></pre></td></tr></table></figure>

<p>这里有一点需要说明的是从express-session 1.5.0开始，这一个模块已经不再需要cookie-parser这一个中间件了。并且如果你在cookie-parser中使用的secret与express-session中的secret不一致的话就会起冲突。所以最好的处理办法是，如果你已经决定在项目中使用session的，你大可把cookie-parser从你的代码中去掉.</p>
<h1 id="redis的基本使用"><a href="#redis的基本使用" class="headerlink" title="redis的基本使用"></a>redis的基本使用</h1><h2 id="为什么要使用redis"><a href="#为什么要使用redis" class="headerlink" title="为什么要使用redis?"></a>为什么要使用redis?</h2><p>session中的数据要存储在服务器端，怎么存就成了一个问题？可以存储在服务器所在主机的文件系统中，也可以存储在服务器端的数据库中，还可以直接存储在服务器的内存中。(express-session默认就将session数据直接缓存在服务器所在主机的内存中)但是无论是存储在文件中还是普通数据库中，最终程序还是需要在磁盘上面进行读写。大家知道这种数据从磁盘上的读写是非常耗时的。而sesssion数据则是需要频繁的使用的，这就意味着频繁的I/O操作，这对程序的性能是一个巨大的损害。无疑，把session数据存储在内存中是一个最好的选择。但是像express-session默认的将其直接存储在服务器主机的内存中也是不行的。随着网站用户数的增加，session数据会越来越多，这将极大的占用服务器的内存，从而使程序变慢。网站的维护也将变得困难，因为一旦服务器重启，内存中的session数据就将全部丢失。这种方式也不利于session数据的共享。目前最常用的方式就是专门提供一个数据库，它把数据存储在内存中，必要时也可以将数据写入磁盘中，并且还支持多个程序的连接，实现数据的共享，同时提供操作数据的接口，方便程序操作数据。Redis就是这样的一个数据库。我们把Redis单独放在一个稳定的内存大的主机之上，做成一个数据库服务器，这样的话，上述的所有问题就统统解决了。<br>其实除了可以存储session数据之外，redis还可以缓存很多东西。比如我们可以把html缓存在redis中，客户端发请求需要这个html页面，那么我们的程序就可以先在缓存中找这个页面，如果没有找到在去数据库中找。类似这样的操作可以极大的提高响应的速度，增强用户体验。</p>
<h2 id="redis使用-基于ubuntu系统"><a href="#redis使用-基于ubuntu系统" class="headerlink" title="redis使用(基于ubuntu系统)"></a>redis使用(基于ubuntu系统)</h2><h3 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install redis</span><br></pre></td></tr></table></figure>

<p>上面的两条命令就可以安装redis了，但是这样安装的redis往往不是redis的最新版本，(但是也够用了，本人就是这样安装的，安装的是3.2.1版，当前最新的稳定版本是４．０．１)其实区别不大。<br>如果想要安装最新版可以使用下面的几条命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://download.redis.io/releases/redis-4.0.1.tar.gz</span><br><span class="line">$ tar xzf redis-4.0.1.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> redis-4.0.1</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure>

<p>这样的安装时间可能会长一些。</p>
<h3 id="基本工具介绍"><a href="#基本工具介绍" class="headerlink" title="基本工具介绍"></a>基本工具介绍</h3><p>安装完成之后我们就有了两个基本工具了，服务启动工具：redis-server,命令行的客户端工具：redis-cli.</p>
<h4 id="redis-server"><a href="#redis-server" class="headerlink" title="redis-server"></a>redis-server</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-server</span><br></pre></td></tr></table></figure>

<p>上面这条命令就可以启动redis的服务了，redis默认监听的是６３７９端口。但是这种方式启动redis,是以前台的方式启动的，这样的话，我们就必须保持这个会话，关闭回话窗口或按下ctrl+c,服务就停止了。我们还可以以守护式进程的方式，让redis在后台运行。这就需要配置了,在/etc/redis.conf或者/etc/redis/redis.conf中，我们把daemonize后面的no改为yes就行了。这时我们再次启动redis</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure>

<p>这次启动要在命令后面带上刚才修改了的配置文件的路径。这样的话，我们的redis就会在后台运行了。<br>注意：有的版本的redis默认daemonize的选项就是yes,也就是说默认就是在后台运行的，这时我们在运行$ redis-server就会告诉我们6379端口被占用。</p>
<h4 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a>redis-cli</h4><p>redis-cli是一个redis的命令行客户端工具，用于连接和操作redis服务器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br></pre></td></tr></table></figure>

<p>上面的这条命令，默认是连接到本地的6379端口，我们也可以指定主机名和端口号来进行远程链接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure>

<p>这条命令同样链接到本地的6379<br>链接到了redis服务器之后，我们就进入了与redis服务器的会话交互中，我们可以通过一些指令来进行操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ keys *             //查看存储的所有的键</span><br><span class="line">$ <span class="built_in">set</span> hello world    //设置键hello对应的值为world</span><br><span class="line">$ get hello          //查看键hello对应的值</span><br></pre></td></tr></table></figure>

<h4 id="GUI工具"><a href="#GUI工具" class="headerlink" title="GUI工具"></a>GUI工具</h4><p>推荐Redis Desktop Manager</p>
<h3 id="nodejs中操作redis"><a href="#nodejs中操作redis" class="headerlink" title="nodejs中操作redis"></a>nodejs中操作redis</h3><p>在nodejs中操作redis,需要一个redis的驱动。目前比较受欢迎的有两个node_redis,ioredis.下面我们就使用node-redis来讲解。</p>
<h4 id="安装node-redis"><a href="#安装node-redis" class="headerlink" title="安装node_redis"></a>安装node_redis</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save redis</span><br></pre></td></tr></table></figure>

<h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node_redis插件</span></span><br><span class="line"><span class="keyword">const</span> redis = <span class="built_in">require</span>(<span class="string">'redis'</span>);</span><br><span class="line"><span class="comment">//链接redis服务器</span></span><br><span class="line"><span class="keyword">var</span> client = redis.createClient(<span class="number">6379</span>, <span class="string">"localhost"</span>);</span><br><span class="line"><span class="comment">//保存数据</span></span><br><span class="line">client.set(<span class="string">"this is a key"</span>, <span class="string">"this is a vaule"</span>);</span><br><span class="line"><span class="comment">//获取数据</span></span><br><span class="line">client.get(<span class="string">'this is a key'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, value</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(err.message);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//我们可以改写toString方法，让redis存储一个json字符串，这是我们可以把他</span></span><br><span class="line"><span class="comment">//从redis中取出来之后就可以转化成对象，接着使用</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//当然，最好不要改变原型链中的方法</span></span><br><span class="line"><span class="comment">//我们保存一个对象</span></span><br><span class="line">client.set(<span class="string">'key'</span>, &#123;<span class="string">"a"</span>: <span class="number">1</span>,<span class="string">"b"</span>: <span class="number">2</span>&#125;);</span><br><span class="line">client.get(<span class="string">'key'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, value</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(err.message);</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(vaule, <span class="keyword">typeof</span> vaule)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//从输出结果中可以看到，上面的打印ｖａｕｌｅ的类型，是一个字符串</span></span><br><span class="line"><span class="comment">//那是因为当存储的是一个对象的时候，redis会使用toString方法，把他转化成字符串，见上</span></span><br><span class="line"><span class="comment">//操作列表list</span></span><br><span class="line"><span class="comment">//从右边依次插入a,b,c,d,e</span></span><br><span class="line">client.rpush(<span class="string">'testList'</span>,<span class="string">'a'</span>);</span><br><span class="line">client.rpush(<span class="string">'testList'</span>,<span class="string">'b'</span>);</span><br><span class="line">client.rpush(<span class="string">'testList'</span>,<span class="string">'c'</span>);</span><br><span class="line">client.rpush(<span class="string">'testList'</span>,<span class="string">'d'</span>);</span><br><span class="line">client.rpush(<span class="string">'testList'</span>,<span class="string">'e'</span>);</span><br><span class="line"><span class="comment">//同理，还有一个lpush</span></span><br><span class="line"><span class="comment">//从左边加数据</span></span><br><span class="line"><span class="comment">//删除数据（从右边删rpop,从左边删lpop）</span></span><br><span class="line">client.rpop(<span class="string">'testList'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,v</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(err)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(err.message);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(v);<span class="comment">//这里的v就是被删除的数据</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//读取列表</span></span><br><span class="line"><span class="comment">//取数据需要指定从哪里取到哪里，参数中如果是非负数就是从左边开始取，负数就是从右边开始取</span></span><br><span class="line"><span class="comment">//下面的这条语句就是取出全部的数据</span></span><br><span class="line">client.lrange(<span class="string">"testList"</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,list</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(err)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(err.message);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		consol.log(list);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//操作集合</span></span><br><span class="line"><span class="comment">//往集合里面添加东西</span></span><br><span class="line">client.sadd(<span class="string">"testSet"</span>,<span class="string">'a'</span>);</span><br><span class="line">client.sadd(<span class="string">"testSet"</span>,<span class="string">'b'</span>);</span><br><span class="line">client.sadd(<span class="string">"testSet"</span>,<span class="string">'c'</span>);</span><br><span class="line">client.sadd(<span class="string">"testSet"</span>,<span class="string">'d'</span>);</span><br><span class="line"><span class="comment">//集合里面的数据有互异性，在向里面添加数据时只会添加集合中没有的数据，集合中已经有的数据</span></span><br><span class="line"><span class="comment">//将无法插入</span></span><br><span class="line"><span class="comment">//从集合中取东西</span></span><br><span class="line">client.smembers(<span class="string">'testSet'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,values</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(values)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//消息中介</span></span><br><span class="line"><span class="comment">//通过redis的消息订阅与发布可以实现两个进程之间的通信</span></span><br><span class="line"><span class="comment">//消息的发布</span></span><br><span class="line">client.publish(<span class="string">'testPublish'</span>,<span class="string">'message from hhh'</span>);</span><br><span class="line"><span class="comment">//消息的订阅</span></span><br><span class="line">client.subscribe(<span class="string">'testPublish'</span>);</span><br><span class="line">client.on(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">channel,msg</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(channel,msg)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="在Express项目中用redis来缓存Session"><a href="#在Express项目中用redis来缓存Session" class="headerlink" title="在Express项目中用redis来缓存Session"></a>在Express项目中用redis来缓存Session</h4><p>在express项目中使用redis需要connect-redis这一个插件。首先要安装connect-redis</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -save connect-redis</span><br></pre></td></tr></table></figure>

<h4 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express=<span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> redis=<span class="built_in">require</span>(<span class="string">'redis);</span></span><br><span class="line"><span class="string">var session=require('</span>express-session<span class="string">');</span></span><br><span class="line"><span class="string">var RedisStore=require('</span>connect-redis<span class="string">')(session);</span></span><br><span class="line"><span class="string">var client=redis.createClient(6379,"127.0.0.1");</span></span><br><span class="line"><span class="string">var app=express();</span></span><br><span class="line"><span class="string">app.use(session(&#123;</span></span><br><span class="line"><span class="string">	secret: '</span>recommand <span class="number">128</span> bytes random string<span class="string">',</span></span><br><span class="line"><span class="string">	resave:true,</span></span><br><span class="line"><span class="string">	saveUninitialized:true,</span></span><br><span class="line"><span class="string">	cookie:&#123;&#125;,</span></span><br><span class="line"><span class="string">	//在express-session中间件选项中加入store就可以了</span></span><br><span class="line"><span class="string">	store:new RedisStore(&#123;client:client&#125;)</span></span><br><span class="line"><span class="string">&#125;));</span></span><br></pre></td></tr></table></figure>

<p>配置完上面的内容之后，我们还是照常在我们的代码中去操作session，但是这是我们的session的数据就已经存在了redis的缓存系统中了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2017/09/14/Set-and-Multiset-in-STL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/14/Set-and-Multiset-in-STL/" itemprop="url">Set and Multiset in STL</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-14T09:21:38+08:00">
                2017-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index">
                    <span itemprop="name">C/C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关联式容器概述"><a href="#关联式容器概述" class="headerlink" title="关联式容器概述"></a>关联式容器概述</h1><p>set和multiset是一种关联式容器，关联式容器依据特定的排序准则，自动为元素排序。所有的关联式容器都有一个可供选择的template参数，指明排序准则。排序准则以函数的形式呈现，用于比较元素值或元素键，默认情况下，从小到大排列。<br>主要的关联式容器包括set,multiset,map,multimap.其中set可以视为一种特殊的map，它的元素的值就是键的值。前两种需要包含set头文件，后两种要包含map头文件。</p>
<pre><code>set关键词和数据是同一个值，set容器中的所有的元素必须具有唯一值，不可重复。set对象可以一定的次序存储数据。
multiset是另一种类型的容器，其关键词和数据元素也是同样的值。与set不同的是，它可以包含重复的元素。同样的multiset中的数据也是有次序的。
map是一种包含成对数据的容器，一个值是实际的数据值，另一个值是用来寻找数据的关键值。一个特定的关键值只能与一个元素相联系。map中同一对键值只能出现一次.同样的其中的键值对也是按照特定的顺序排列的。
multimap是允许重复键值的出现。</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2017/09/14/Deque-in-STL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/14/Deque-in-STL/" itemprop="url">Deque in STL</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-14T09:19:05+08:00">
                2017-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index">
                    <span itemprop="name">C/C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>dequ(双端队列)和vector非常的相似，deque也是采取动态数组来管理容器中的数据，数据存储的地址都是连续的，可以对deque中的数据进行随机的访问。deque最重要的特征就是在容器的两端插入删除数据都非常的快速，这也是它和vector的主要的区别。(vector只是在尾端插入删除快速，在头部插入删除数据效率很低)。当程序中涉及到需要在容器的头部和尾部频繁的插入和删除数据时，deque就是最好的选择。同样的，作为动态数组的形式，deque必然也存在其局限性：在deque的中间插入和删除数据时效率很低，这一点和vector的情况是一致的。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>由于deque与vector及其的相似，这里就只总结一下它和vector在具体用法上的区别，其他的用法可以参考vector。</p>
<h3 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a>使用前提</h3><p>使用前需要包含deque头文件，使用std命名空间。</p>
<h3 id="push-front-和pop-front"><a href="#push-front-和pop-front" class="headerlink" title="push_front()和pop_front()"></a>push_front()和pop_front()</h3><p>deque在vector的基础之上增加了push_front()和pop_front()两个成员函数来实现对头部元素的快速操作。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2017/09/13/List-in-STL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/13/List-in-STL/" itemprop="url">List in STL</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-13T09:11:51+08:00">
                2017-09-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index">
                    <span itemprop="name">C/C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>与vector一样，list也是STL模板库中提供的序列式容器之一。不同的是，list是由双向链表来实现的，元素与元素之间的地址不一定是连续的，，元素之间的序列关系由指针维护。list支持前后两种移动方式。与vector不同,list不支持随机访问，不可以使用operator[] 或at()来获取元素。list的优势在于任何位置执行插入和删除操作都非常迅速，因为改变的仅仅是指针与节点的链接而已。list的使用需要头文件和std命名空间。</p>
<h2 id="list对象的定义与构造函数"><a href="#list对象的定义与构造函数" class="headerlink" title="list对象的定义与构造函数"></a>list对象的定义与构造函数</h2><p>list对象的定义与初始化一般有一下几种方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;TYPE&gt; mylist;　　　　　　　　<span class="comment">//初始化一个空lkongist</span></span><br><span class="line"><span class="built_in">list</span>&lt;TYPE&gt; mylist(size);          <span class="comment">//初始化一个初始大小为size的空list</span></span><br><span class="line"><span class="built_in">list</span>&lt;TYPE&gt; mylist(size,vaule);    <span class="comment">//初始化一个装有size个vaule的list</span></span><br><span class="line"><span class="built_in">list</span>&lt;TYPE&gt; mylist(elselist);      <span class="comment">//复制构造函数</span></span><br><span class="line"><span class="built_in">list</span>&lt;TYPE&gt; mylist(first,last);　　<span class="comment">//将由迭代器指定的其他list中的多个元素复制以构成新list</span></span><br></pre></td></tr></table></figure>

<h2 id="基础成员函数"><a href="#基础成员函数" class="headerlink" title="基础成员函数"></a>基础成员函数</h2><h3 id="元素的赋值"><a href="#元素的赋值" class="headerlink" title="元素的赋值"></a>元素的赋值</h3><p>list模板类提供了两个成员函数<code>push_back()</code>,<code>push_front()</code>,分别用来将新的节点追加到list的尾部和插入到list的头部。与之对应的<code>pop_back()</code>和<code>pop_front()</code>函数则是在相应位置做删除操作。在vector中只提供了<code>push_back()</code>函数和<code>pop_back()</code>函数，主要是因为vector中在头部插入和删除元素效率很低，所以就没有直接提供相应操作，这也说明了list是双向链表。</p>
<h3 id="list容器的容量"><a href="#list容器的容量" class="headerlink" title="list容器的容量"></a>list容器的容量</h3><p>和list容量相关的主要是下面的几个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mylist.size();         <span class="comment">//返回容器中元素的个数</span></span><br><span class="line">mylist.max_size();　　<span class="comment">//返回容器中最多可以容纳节点的数目，一般是一个非常大的数字，我们可以不用管</span></span><br><span class="line">mylist.resize();　　　<span class="comment">//重新设置容器的大小</span></span><br></pre></td></tr></table></figure>

<h3 id="迭代器相关"><a href="#迭代器相关" class="headerlink" title="迭代器相关"></a>迭代器相关</h3><p>list模板类包含的和迭代器相关的函数主要有：begin(),end(),rbegin(),rend(),back(),front()<br>下面我们通过一个程序演示他们的使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">int</span>&amp; i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; myIntlist;</span><br><span class="line">    myIntlist.push_back(<span class="number">1</span>);</span><br><span class="line">    myIntlist.push_back(<span class="number">2</span>);</span><br><span class="line">    myIntlist.push_back(<span class="number">3</span>);</span><br><span class="line">    myIntlist.push_back(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//顺序打印</span></span><br><span class="line">    for_each(myIntlist.begin(),myIntlist.end(),printList);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//反序打印</span></span><br><span class="line">    for_each(myIntlist.rbegin(),myIntlist.rend(),printList);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator riter;</span><br><span class="line">    riter=myIntlist.rbegin();</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">    iter=myIntlist.begin();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*riter&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*iter&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> last=myIntlist.back();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;last&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4</span><br><span class="line">4 3 2 1</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h3 id="判断链表是否为空"><a href="#判断链表是否为空" class="headerlink" title="判断链表是否为空"></a>判断链表是否为空</h3><p>使用list对象的empty()方法判断链表是否为空，该函数返回bool值</p>
<h3 id="list元素的存取与访问"><a href="#list元素的存取与访问" class="headerlink" title="list元素的存取与访问"></a>list元素的存取与访问</h3><p>list对象不能使用operator[]和at()来实现随机访问，但是可以用迭代器来进行元素的访问。</p>
<h3 id="元素的插入与删除"><a href="#元素的插入与删除" class="headerlink" title="元素的插入与删除"></a>元素的插入与删除</h3><p>可以实现list元素插入与删除的函数有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在链表尾端插入</span></span><br><span class="line">push_back();</span><br><span class="line"><span class="comment">//删除尾端的元素</span></span><br><span class="line">pop_back();</span><br><span class="line"><span class="comment">//链表头部插入</span></span><br><span class="line">push_front();</span><br><span class="line"><span class="comment">//移除头部的元素</span></span><br><span class="line">pop_front();</span><br><span class="line"><span class="comment">//可以实现任意位置的插入</span></span><br><span class="line">insert()</span><br><span class="line"><span class="comment">//任意位置的删除</span></span><br><span class="line">erase()</span><br><span class="line"><span class="comment">//清空链表</span></span><br><span class="line">clear()</span><br><span class="line"><span class="comment">//下面两个成员函数也可以用来删除链表中的元素</span></span><br><span class="line">remove()</span><br><span class="line">remove_if()</span><br></pre></td></tr></table></figure>

<h3 id="运算符函数"><a href="#运算符函数" class="headerlink" title="运算符函数"></a>运算符函数</h3><p>operator==,operator&lt;,operator&gt;,operator&lt;=,operator&gt;=,operator!=这些运算符函数均可以用于两个list对象之间的比较，前提是参与比较的两个list对象的格式应该完全相同。</p>
<h3 id="合并两个list"><a href="#合并两个list" class="headerlink" title="合并两个list"></a>合并两个list</h3><p>list还提供了成员函数merge()成员函数，用于将两个具有相同格式的list对象合并,同时提供了sort()成员函数用于将成员排序:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList2</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; L1,L2;</span><br><span class="line">    L1.push_back(<span class="string">"abc"</span>);</span><br><span class="line">    L1.push_back(<span class="string">"def"</span>);</span><br><span class="line">    L1.push_back(<span class="string">"ghi"</span>);</span><br><span class="line">    for_each(L1.begin(),L1.end(),printList);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    L2.push_back(<span class="string">"jkl"</span>);</span><br><span class="line">    L2.push_back(<span class="string">"mno"</span>);</span><br><span class="line">    L2.push_back(<span class="string">"pqr"</span>);</span><br><span class="line">    for_each(L2.begin(),L2.end(),printList);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    L1.merge(L2,greater&lt;<span class="built_in">string</span>&gt;());</span><br><span class="line">    for_each(L1.begin(),L1.end(),printList);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L3,L4;</span><br><span class="line">    L3.push_back(<span class="number">2</span>);</span><br><span class="line">    L3.push_back(<span class="number">3</span>);</span><br><span class="line">    L3.push_back(<span class="number">1</span>);</span><br><span class="line">    for_each(L3.begin(),L3.end(),printList2);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//从小到大排序</span></span><br><span class="line">    L3.sort();</span><br><span class="line">    for_each(L3.begin(),L3.end(),printList2);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//从大到小【排序</span></span><br><span class="line">    L3.sort(greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    for_each(L3.begin(),L3.end(),printList2);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abc def ghi</span><br><span class="line">jkl mno pqr</span><br><span class="line">jkl mno pqr abc def ghi</span><br><span class="line">2 3 1</span><br><span class="line">1 2 3</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure>

<h3 id="unique-重复的元素只保留一个"><a href="#unique-重复的元素只保留一个" class="headerlink" title="unique()重复的元素只保留一个"></a>unique()重复的元素只保留一个</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList2</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L1;</span><br><span class="line">    L1.push_back(<span class="number">1</span>);</span><br><span class="line">    L1.push_back(<span class="number">2</span>);</span><br><span class="line">    L1.push_back(<span class="number">1</span>);</span><br><span class="line">    for_each(L1.begin(),L1.end(),printList2);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//这里要先sort再unique(),不然的话没有效果</span></span><br><span class="line">    L1.sort();</span><br><span class="line">    L1.unique();</span><br><span class="line">    for_each(L1.begin(),L1.end(),printList2);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 1</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>

<h3 id="reverse-反转顺序"><a href="#reverse-反转顺序" class="headerlink" title="reverse()反转顺序"></a>reverse()反转顺序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList2</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L1;</span><br><span class="line">    L1.push_back(<span class="number">1</span>);</span><br><span class="line">    L1.push_back(<span class="number">2</span>);</span><br><span class="line">    L1.push_back(<span class="number">3</span>);</span><br><span class="line">    for_each(L1.begin(),L1.end(),printList2);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//这里要先sort再unique(),不然的话没有效果</span></span><br><span class="line">    <span class="comment">//L1.sort();</span></span><br><span class="line">    L1.reverse();</span><br><span class="line">    for_each(L1.begin(),L1.end(),printList2);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2017/09/10/something-other-about-c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/10/something-other-about-c/" itemprop="url">C++总结2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-10T08:46:48+08:00">
                2017-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index">
                    <span itemprop="name">C/C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这一篇文章打算把c++里面非常重要而又不容易记住的东西好好总结一下，主要涉及的知识点有独立编译，命名空间，友元，继承的细节，多态等。</p>
<h1 id="独立编译和命名空间"><a href="#独立编译和命名空间" class="headerlink" title="独立编译和命名空间"></a>独立编译和命名空间</h1><p>其实在上一篇文章中,我已经讨论过独立编译的问题，只不过没有讲的深入，在这里我打算详细的讲一讲独立编译。</p>
<h2 id="抽象数据类型-ADT"><a href="#抽象数据类型-ADT" class="headerlink" title="抽象数据类型(ADT)"></a>抽象数据类型(ADT)</h2><p>抽象数据类型(Abstract Data Type)是一个类，它将类的接口与类的实现区分开来。对于标准的开发来讲，所有的类都应该设计成ADT。为了定义一个ADT类，需要将类的使用规范与类的实现细节彻底分开。这一点的实现需要遵循一下三条规则：</p>
<ul>
<li>使所有的成员变量都成为类的私有成员。</li>
<li>使类的每一项基本操作成为类的一个公共成员函数,一个友元函数，一个普通函数或者一个重载的操作符。将类的定义与函数/操作符的声明以及用来告诉类的使用者该如何使用这个类及相关函数的必要的注释统统放在一个文件中，这个文件就是这个ADT类的接口文件。</li>
<li>确保使用ADT的程序员无法访问到基本操作的具体实现。实现由函数定义以及重载的操作符的定义（另外还包括任何辅助函数，或者这些定义需要的其他项）构成。</li>
</ul>
<p>我们在设计类的时候只要按照ADT的设计原则，那么我们的类就是标准的类了。但是这就引出来了其他的一些问题，比如：编译时的依赖关系，接口文件的重复定义，命令空间问题。</p>
<h2 id="解决编译时的依赖关系"><a href="#解决编译时的依赖关系" class="headerlink" title="解决编译时的依赖关系"></a>解决编译时的依赖关系</h2><p>这个问题在上一篇文章中已经讨论过了,这里不在赘述。</p>
<h2 id="防止接口文件的重复编译"><a href="#防止接口文件的重复编译" class="headerlink" title="防止接口文件的重复编译"></a>防止接口文件的重复编译</h2><p>我们设计ADT类的其中一个目的就是要提高代码的可重用性。所有的文件都可以通过include某个ADT类的接口文件，来使用这个类提供的功能。这样的话就有可能出现类似这样的情形：我们项目中的一个文件include另外的两个文件，而另外的两个文件又分别include了同一个ＡＤＴ类，这样的话我们的项目就会编译两次这个ADT类，这是不被允许的。我们必须要解决这个问题。解决的办法就是在类的接口文件中，加三条预编译指令。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>　XXX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XXX</span></span><br><span class="line"><span class="comment">//这中间放类的接口文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>将类的接口放在这三条命令之间，就可以防止重复编译。第一次编译的时候，会定义XXX这个宏，当第二次编译的时候，XXX这个宏已经被定义，编译器就会跳过这个接口文件，从而避免了重复编译。</p>
<h2 id="命名空间问题。"><a href="#命名空间问题。" class="headerlink" title="命名空间问题。"></a>命名空间问题。</h2><p>大型项目的编码工作是由许多的程序员的合作完成的。每个人写的代码最后汇合到一起，这就难以避免的会产生命名冲突。要解决这个问题就要靠命名空间了。大家在编写c++代码的时候，用的最多的就是std命令空间了。其实我们写的每一句代码都是在某一个命名空间中，加入不明确指定一个命名空间，代码就默认放在全局命名空间中。全局命令空间不需要using指令，因为它是默认的命名空间。可以同时使用多个命名空间，比如我们总是在使用全局命名空间，同时也会使用std命名空间。假如一个名称在两个命名空间中都进行了定义，而你又使用了这两个命名空间，那么你使用这个名称的时候就会产生冲突，这个名称是哪个命名空间的呢？所以我们在使用一个名称的时候一般都要指定这个名称属于那个命名空间。<br>为了防止我们自己定义的类中的名称与全局命名空间或用户引用的其他命名空间中的名称产生冲突，我们最好把自己的类放在一个自己的命名空间中。</p>
<h3 id="创建和使用命名空间"><a href="#创建和使用命名空间" class="headerlink" title="创建和使用命名空间"></a>创建和使用命名空间</h3><p>要将代码放到一个命名空间中，需要采取一下形式来定义一个命名空间分组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> my_namespace_name&#123;</span><br><span class="line">	some_code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上述命名空间分组放到自己的代码中，就相当与将some_code中定义的名称放到命名空间my_namespace_name中，为了使用这些名称，需要使用一下的using 指令：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> my_namespace_name;</span><br></pre></td></tr></table></figure>

<p>下面给一点代码来演示命名空间的创建与使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//程序中需要用到cout,所以需要std命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//在两个命名空间中声明两个函数</span></span><br><span class="line"><span class="keyword">namespace</span> ns1&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> ns2&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//要指定使用那个命名空间，才能使用那个命名空间中定义的名称</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> ns1;</span><br><span class="line">        func1();</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> ns2;</span><br><span class="line">        func2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在同样的命名空间中定义这两个函数</span></span><br><span class="line"><span class="keyword">namespace</span> ns1&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"here is func1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> ns2&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"here is func2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="限定名称"><a href="#限定名称" class="headerlink" title="限定名称"></a>限定名称</h3><p>假如现在你遇到了这样一种情况，你需要使用ns1命名空间中的func1函数和ns2中的func2函数，但是在ns1和ns2中又分别定义了一个名为func的同名函数。这时如果你使用using namespace ns1和using namespace ns2就不合适了。因为这会使得ns1和ns2中的所有的名称都进入可用状态，这就产生了冲突。一种更为保险的方法就是下面这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ns1::func1;</span><br><span class="line"><span class="keyword">using</span> ns2::func2;</span><br></pre></td></tr></table></figure>

<p>这样的话，就只会让ns1命名空间中的func1和ns2中的func2进入可用状态，而两个命名空间中的其他名称仍然不可使用。</p>
<h1 id="类中的注意点"><a href="#类中的注意点" class="headerlink" title="类中的注意点"></a>类中的注意点</h1><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>在 C++ 中，每一个对象都能通过this指针访问自己的地址。this指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。</p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>面向对象的设计思想提高了数据封装的程度和程序数据的安全性。外界对对象内部数据的访问得到了严格的控制。外部要想访问对象的私有属性，必须要通过对象提供的方法去访问。但是有时为了简化函数定义和提高效率，我们想让自己定义的外部函数直接访问到对象的私有属性。这在c++中是通过友元函数实现的。就是将某个外部函数定义为某个类的友元，这样这个函数就得到了类的信任，从而可以直接访问类的私有属性。具体实现，看代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Student(<span class="built_in">string</span> _name,<span class="keyword">int</span> _age);</span><br><span class="line">        Student();</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">//下面这个函数就是Studnet类的一个友元函数</span></span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">isSameName</span><span class="params">(Student s1,Student s2)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line">Student::Studnet(strng _name,<span class="keyword">int</span> _age):name(_name),age(_age)&#123;</span><br><span class="line">    <span class="comment">//有意留空</span></span><br><span class="line">&#125;</span><br><span class="line">Student::Student():name(<span class="string">"none"</span>),age(<span class="number">18</span>)&#123;</span><br><span class="line">    <span class="comment">//有意留空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> Studnet::getName()&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Student::setName(<span class="built_in">string</span> _name)&#123;</span><br><span class="line">    name=_name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Student::getAge()&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Student::setAge(<span class="keyword">int</span> _age)&#123;</span><br><span class="line">    age=_age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSameName</span><span class="params">(Studnet s1,Student s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.name==s2.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码包含了一个Student类的接口和实现，由于这里只是演示，所以就没有考虑上文中提到的那些东西。上面定义了一个友元函数，用来判断两个学生是否同名。必须明确的是，友元函数并不是一个类的成员函数，他是一个外部函数，但是把他声明为某个类的友元之后，他就有了访问类的私有属性的权限。声明的方法是在当事类中声明，并且以friend关键字打头，定义的时候还是按照普通函数那样定义。假如我们的类有良好的取值和赋值函数的话，我们也可以不必把这个函数定义成友元函数，直接就把他定义成一个普通的外部函数，这时，他的定义就变成这样了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSameName</span><span class="params">(Student s1,Student s2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.getName()==s2.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见这样的话在一定程度上增加了函数定义的复杂度，并且降低了效率。确实友元可以简化函数的定义和提高效率，但是反对友元的人则说友元函数破坏了类的封装性。依我看两者都有道理，用那一种就看编程者的心情了。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承就是通过一个类(基类)派生出一个新类(派生类)的过程，派生类自动具有基类的所有成员变量和函数，并且可以根据需要添加更多的成员函数或成员变量。<br>先举一个例子</p>
<p>下面我们先来看一个关于继承的小项目,项目结构如下：<br>Project:<br>human.h<br>human.cpp<br>student.h<br>student.cpp<br>teacher.h<br>teacher.cpp<br>main.cpp<br>makefile<br>上面的项目定义了一个Human类，然后由Human类派生出Student类和Teacher类，xxx.h为对应类的接口文件，xxx.cpp为对应类的实现文件，main.cpp为测试这三个类的文件，makefile为编译的文件。<br>human.h的内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HUMAN_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUMAN_H</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> human_namespace&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Human(<span class="built_in">string</span> _name,<span class="keyword">int</span> _age);</span><br><span class="line">        Human();</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="built_in">string</span> _name)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> _age)</span></span>;</span><br><span class="line">        <span class="comment">//下面这个函数就是Studnet类的一个友元函数</span></span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">isSameName</span><span class="params">(Human s1,Human s2)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">human.cpp的内容：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"human.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> human_namespace&#123;</span><br><span class="line">    Human::Human(<span class="built_in">string</span> _name,<span class="keyword">int</span> _age):name(_name),age(_age)&#123;</span><br><span class="line">        <span class="comment">//有意留空</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Human::Human():name(<span class="string">"none"</span>),age(<span class="number">18</span>)&#123;</span><br><span class="line">        <span class="comment">//有意留空</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> Human::getName()&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> Human::setName(<span class="built_in">string</span> _name)&#123;</span><br><span class="line">        name=_name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> Human::getAge()&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> Human::setAge(<span class="keyword">int</span> _age)&#123;</span><br><span class="line">        age=_age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameName</span><span class="params">(Human s1,Human s2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.name==s2.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>student.h的内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STUDENT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STUDENT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"human.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> human_namespace;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> student_namespace&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span><span class="keyword">public</span> Human&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Student(<span class="built_in">string</span> _name,<span class="keyword">int</span> _age,<span class="built_in">string</span> _schoolNmae);</span><br><span class="line">        Student();</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setSchoolName</span><span class="params">(<span class="built_in">string</span> _schoolName)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">getSchoolName</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">studying</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">string</span> schoolName;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">student.cpp的内容：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"student.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> human_namespace;</span><br><span class="line"><span class="keyword">namespace</span> student_namespace&#123;</span><br><span class="line">    Student::Student(<span class="built_in">string</span> _name,<span class="keyword">int</span> _age,<span class="built_in">string</span> _schoolName):Human(_name,_age),schoolName(_schoolName)&#123;</span><br><span class="line">        <span class="comment">//主体有意留空</span></span><br><span class="line">    &#125;</span><br><span class="line">    Student::Student():Human(),schoolName(<span class="string">"none"</span>)&#123;</span><br><span class="line">        <span class="comment">//主体有意留空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> Student::setSchoolName(<span class="built_in">string</span> _schoolName)&#123;</span><br><span class="line">        schoolName=_schoolName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> Student::getSchoolName()&#123;</span><br><span class="line">        <span class="keyword">return</span> schoolName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> Student::studying(<span class="keyword">void</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"我是学生"</span>&lt;&lt;getName()&lt;&lt;<span class="string">"，我在学习！！！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>teacher.h的内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEACHER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEACHER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"human.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> human_namespace;</span><br><span class="line"><span class="keyword">namespace</span> teacher_namespace&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>:</span> <span class="keyword">public</span> Human&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            Teacher(<span class="built_in">string</span> _name,<span class="keyword">int</span> _age,<span class="built_in">string</span> _subject);</span><br><span class="line">            Teacher();</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">setSubject</span><span class="params">(<span class="built_in">string</span> _schoolName)</span></span>;</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">getSubject</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">teaching</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="built_in">string</span> subject;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>teacher.cpp的内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"teacher.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> human_namespace;</span><br><span class="line"><span class="keyword">namespace</span> teacher_namespace&#123;</span><br><span class="line">    Teacher::Teacher(<span class="built_in">string</span> _name,<span class="keyword">int</span> _age,<span class="built_in">string</span> _subject):Human(_name,_age),subject(_subject)&#123;</span><br><span class="line">        <span class="comment">//主体有意留空</span></span><br><span class="line">    &#125;</span><br><span class="line">    Teacher::Teacher():Human(),subject(<span class="string">"none"</span>)&#123;</span><br><span class="line">        <span class="comment">//主体有意留空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> Teacher::setSubject(<span class="built_in">string</span> _subject)&#123;</span><br><span class="line">        subject=_subject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> Teacher::getSubject()&#123;</span><br><span class="line">        <span class="keyword">return</span> subject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> Teacher::teaching(<span class="keyword">void</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"我是一个老师，我在教书！！！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.cpp的内容:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"student.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"teacher.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> student_namespace;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> teacher_namespace;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student s1=Student(<span class="string">"小明"</span>,<span class="number">25</span>,<span class="string">"黄冈中学"</span>);</span><br><span class="line">    Student s2;</span><br><span class="line">    Teacher t1=Teacher(<span class="string">"老王"</span>,<span class="number">40</span>,<span class="string">"语文"</span>);</span><br><span class="line">    Teacher t2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s1.getName()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s2.getName()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    s1.studying();</span><br><span class="line">    s1.setName(<span class="string">"小小明"</span>);</span><br><span class="line">    s1.studying();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;t1.getSubject()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;t2.getAge()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>makefile的内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">main.exe:student.o teacher.o main.o human.o</span><br><span class="line">	g++ -o main.exe student.o teacher.o main.o human.o</span><br><span class="line">human.o:human.cpp human.h</span><br><span class="line">student.o:student.cpp student.h  </span><br><span class="line">	g++ -c student.cpp student.h </span><br><span class="line">teacher.o:teacher.cpp teacher.h </span><br><span class="line">	g++ -c teacher.cpp teacher.h </span><br><span class="line">main.o:main.cpp</span><br><span class="line">	g++ -c main.cpp</span><br><span class="line">cleanall:</span><br><span class="line">	rm main.exe student.o teacher.o main.o human.o student.h.gch teacher.h.gch</span><br><span class="line">cleansome:</span><br><span class="line">	rm student.o teacher.o main.o human.o student.h.gch teacher.h.gch</span><br></pre></td></tr></table></figure>

<p>继承的编码语法这里就不在赘述。派生类自动获得基类的所有成员变量和成员函数（特例：一些特殊的成员函数，比如构造函数将不会被自动继承，私有成员函数根本就不会被继承），继承的成员函数和成员变量不在派生类的定义中提到(特例：如果你需要更改一个继承的函数的定义，那么你需要在派生类的定义中列出它)，但他们会自动成为派生类的成员。</p>
<h2 id="派生类中的构造函数"><a href="#派生类中的构造函数" class="headerlink" title="派生类中的构造函数"></a>派生类中的构造函数</h2><p>基类中的构造函数不被派生类继承，但可以在派生类的构造函数的定义中调用基类的构造函数。要用一种特殊的语法来调用基类的构造函数，即初始化区域：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Teacher::Teacher(<span class="built_in">string</span> _name,<span class="keyword">int</span> _age,<span class="built_in">string</span> _subject):Human(_name,_age),subject(_subject)&#123;</span><br><span class="line">        <span class="comment">//主体有意留空</span></span><br><span class="line">    &#125;</span><br><span class="line">Teacher::Teacher():Human(),subject(<span class="string">"none"</span>)&#123;</span><br><span class="line">    <span class="comment">//主体有意留空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Teacher类继承自Human类，这个Teacher类的构造函数在定义是就是调用了Human类的构造函数。对派生类定义构造函数应该包括对某个基类构造函数的调用，并将这个调用放在构造函数定义的初始化区域。假如不包括对任何基础类构造函数的调用，那么在调用派生类构造函数时，会自动调用基类的默认构造函数(即没有参数的那个构造函数)，如果基类并没有定义这样的默认构造函数，那么在编译时就会报错。<br>派生类成员函数定义中可以使用来自基类的私有变量吗？</p>
<p>答案当然是不可以。就如上面的小项目，Student类继承自Human类，现在在Student类中增加了一个方法studying,这个方法需要用到name,上面我是这样处理的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Student::studying(<span class="keyword">void</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"我是学生"</span>&lt;&lt;getName()&lt;&lt;<span class="string">"，我在学习！！！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里调用的是继承得来的getName()这一取值函数来获取当前对象的name,按理说name这一个基类的私有变量也被继承才对，为何不直接使用name呢？这里需要注意，name是基类Human的私有成员变量，所以只有在Human类的成员函数的定义中才能够直接访问，在其他的任何类中（包括派生类）的成员函数的定义中都不能够直接通过名称来访问.虽然Student类有一个名为name的成员变量(从Human继承得来)，但是在Student类定义的任何成员函数中对成员name的任何直接访问都是非法的。其它的继承来的私有属性或函数也一样。</p>
<h2 id="私有成员函数不会被继承"><a href="#私有成员函数不会被继承" class="headerlink" title="私有成员函数不会被继承"></a>私有成员函数不会被继承</h2><p>上面讲到除非在基类的接口与实现中，否则不能直接访问基类的私有成员变量和私有成员函数，即使是在派生类的一个成员函数的定义中。私有成员变量与私有成员函数类似，但是对私有成员函数来讲这种限制似乎更加严格，在派生类中，基类私有成员变量好歹可以通过取值函数和赋值函数来操作，但是私有成员函数则根本就不可用了。事实上私有成员函数根本就不会被继承下来。</p>
<h2 id="protected限定符"><a href="#protected限定符" class="headerlink" title="protected限定符"></a>protected限定符</h2><p>在前面类的定义中只使用了两种类的成员:public和private,其实还存在第三种:protected.对除了基类的派生类以外的所有类以及外部函数来说，基类中用protected标记的成员和用private标记的成员没有任何区别。但是对与基类的派生类来说，则可以在自己的成员函数的定义中直接通过名称来访问基类的protected成员。如果在Human类中name这一属性没有被标记为private,而被标记为protected，那么Student类中studying函数应该像下面这样定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Student::studying(<span class="keyword">void</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"我是学生"</span>&lt;&lt;name&lt;&lt;<span class="string">"，我在学习！！！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>被protected标记的成员在继承时仍然成为派生类的protected成员，所以对派生类的派生类来讲，它仍然可以通过名称来直接访问在它的爷爷类中定义的protected成员。<br>同样的，对protected的使用也是说法不一，有人认为使用protected是一种不好的风格，因为它违背了“隐藏类实现的细节”这一原则。但也有人认为protected的使用简化了派生类成员函数定义，提高了效率。</p>
<h2 id="重定义成员函数"><a href="#重定义成员函数" class="headerlink" title="重定义成员函数"></a>重定义成员函数</h2><p>继承时基类中的绝大多数成员函数会被原封不动的继承到派生类中，但有时这并不是我们想要的，我们可能还需要某些成员函数的定义做出一些变化，这时我们就需要对其进行重定义。重定义需要注意需要在派生类中明确列出需要修改定义的那些继承成员函数的声明，并且不可改变原函数的参数数量，顺序和类型。</p>
<h2 id="重定义和重载的比较"><a href="#重定义和重载的比较" class="headerlink" title="重定义和重载的比较"></a>重定义和重载的比较</h2><p>不要混淆在派生类中对一个函数定义的重定义以及对一个函数名的重载。重定义函数时，派生类中给出的新函数定义和原函数具有相同的参数数量顺序和类型。与基类的中的函数定义相比，如果派生类中的函数使用了数量不同的参数，或者某个参数具有不同的类型，那么派生类实际上会同时存在两个函数，这成为重载，而非重定义。</p>
<h2 id="访问重定义的基函数"><a href="#访问重定义的基函数" class="headerlink" title="访问重定义的基函数"></a>访问重定义的基函数</h2><p>假如我们重定义了一个函数，使其在派生类中的定义有别与基类中的定义，在这种情况下，并不是说基类中的定义就再也不能由派生类的对象使用了。要为派生类的对象调用函数的基类版本。<br>现在假定Human类中有一个saying函数，它不接受任何参数。Student类继承自Human类，并且在Student类中重定义了saying函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明对象</span></span><br><span class="line">Human A;</span><br><span class="line">Student B;</span><br><span class="line"><span class="comment">//A,B分别调用自己版本的saying()</span></span><br><span class="line">A.saying();</span><br><span class="line">B.saying();</span><br><span class="line"><span class="comment">//B调用saying的基类版本</span></span><br><span class="line">B.Human::saying();</span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p>
<p>下面的实例中，基类 Shape 被派生为两个类，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width, height;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      Shape( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Parent class area :"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      Rectangle( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>):Shape(a, b) &#123; &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">area</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Rectangle class area :"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      Triangle( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>):Shape(a, b) &#123; &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">area</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Triangle class area :"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         <span class="keyword">return</span> (width * height / <span class="number">2</span>); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Shape *shape;</span><br><span class="line">   <span class="function">Rectangle <span class="title">rec</span><span class="params">(<span class="number">10</span>,<span class="number">7</span>)</span></span>;</span><br><span class="line">   <span class="function">Triangle  <span class="title">tri</span><span class="params">(<span class="number">10</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 存储矩形的地址</span></span><br><span class="line">   shape = &amp;rec;</span><br><span class="line">   <span class="comment">// 调用矩形的求面积函数 area</span></span><br><span class="line">   shape-&gt;area();</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 存储三角形的地址</span></span><br><span class="line">   shape = &amp;tri;</span><br><span class="line">   <span class="comment">// 调用三角形的求面积函数 area</span></span><br><span class="line">   shape-&gt;area();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当上面的代码被编译和执行时，它会产生下列结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parent class area</span><br><span class="line">Parent class area</span><br></pre></td></tr></table></figure>

<p>导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的静态多态，或静态链接 - 函数调用在程序执行前就准备好了。有时候这也被称为早绑定，因为 area() 函数在程序编译期间就已经设置好了。<br>但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 virtual，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width, height;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      Shape( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Parent class area :"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>修改后，当编译和执行前面的实例代码时，它会产生以下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rectangle class area</span><br><span class="line">Triangle class area</span><br></pre></td></tr></table></figure>

<p>此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。<br>正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是多态的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>虚函数是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。<br>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。</p>
<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。<br>我们可以把基类中的虚函数 area() 改写如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width, height;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      Shape( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// pure virtual function</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>= 0 告诉编译器，函数没有主体，上面的虚函数是纯虚函数。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>C++面向对象程序设计(第七版)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2017/09/01/a-fake-ssh-based-on-python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/01/a-fake-ssh-based-on-python/" itemprop="url">Python的Socket练习——伪SSH</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-01T08:21:36+08:00">
                2017-09-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这一篇博客介绍一下我最近用python中的socket模块写的一个类似于ssh的小工具，虽说是一个工具，但是比那个真的ssh还是弱了不少，基本上也没什么使用价值。但是学习价值还是有的。主要的学习点是网络传输中的数据包粘包问题的解决方案，和发送过去的数据与源数据的md5校验以及python的os，socket模块的简单使用。</p>
<h1 id="实现的功能"><a href="#实现的功能" class="headerlink" title="实现的功能"></a>实现的功能</h1><p>远程操作主机，实现系统中的部分命令的执行并返回执行的输出，上传本地文件到服务器运行的目录，从服务器运行目录下载文件到本地。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="上传-下载文件-过程差不多"><a href="#上传-下载文件-过程差不多" class="headerlink" title="上传/下载文件(过程差不多)"></a>上传/下载文件(过程差不多)</h3><h4 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,json,hashlib,os</span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">PORT = <span class="number">8005</span></span><br><span class="line">client = socket.socket()</span><br><span class="line">client.connect((HOST, PORT))</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    cmd = input(<span class="string">"&gt;&gt;&gt;"</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> len(cmd)==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">　  <span class="keyword">elif</span> cmd.startswith(<span class="string">'get'</span>):</span><br><span class="line">    client.send(cmd.encode(<span class="string">"utf-8"</span>))</span><br><span class="line">    dateHeader_s2c = json.loads(client.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="keyword">if</span> dateHeader_s2c[<span class="string">'status'</span>]==<span class="string">'Y'</span>:</span><br><span class="line">        client.send(<span class="string">b'ok'</span>)</span><br><span class="line">        md5 = hashlib.md5()</span><br><span class="line">        filename = dateHeader_s2c[<span class="string">'filename'</span>]</span><br><span class="line">        accept_length=<span class="number">0</span></span><br><span class="line">        response_length=dateHeader_s2c[<span class="string">'size'</span>]</span><br><span class="line">        <span class="keyword">while</span> accept_length &lt; response_length:</span><br><span class="line">            <span class="keyword">with</span> open(filename + <span class="string">".s2c"</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                accept_temp = client.recv(<span class="number">1024</span>)</span><br><span class="line">                md5.update(accept_temp)</span><br><span class="line">                f.write(accept_temp)</span><br><span class="line">                accept_length += len(accept_temp)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            client.send(<span class="string">b'ok'</span>)</span><br><span class="line">            accept_md5 = client.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">            <span class="keyword">if</span> accept_md5 == md5.hexdigest():</span><br><span class="line">                print(<span class="string">'下载成功！'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                os.popen(<span class="string">'rm %s'</span> % filename + <span class="string">".s2c"</span>) <span class="comment">#删除已经下载的破碎文件</span></span><br><span class="line">                print(<span class="string">'文件破碎！请重新下载'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'请输入一个正确的文件名'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="服务器代码"><a href="#服务器代码" class="headerlink" title="服务器代码"></a>服务器代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket,os,hashlib,json</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> server_config</span><br><span class="line">server=socket.socket()</span><br><span class="line">server.bind((server_config.HOST,server_config.PORT))</span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'Server start at: %s:%s'</span> %(server_config.HOST,server_config.PORT))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'wait for connection...'</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, addr = server.accept()</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'Connected by '</span>, addr)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment">#接收到客户端输入的命令</span></span><br><span class="line">        cmd = conn.recv(<span class="number">1024</span>).decode().strip()</span><br><span class="line">        <span class="keyword">if</span> len(cmd)==<span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'客户端断开链接．．．'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment">#响应客户端的下载文件请求</span></span><br><span class="line">        <span class="keyword">if</span> cmd.startswith(<span class="string">'get'</span>):</span><br><span class="line">            dataHeader_s2c = &#123;&#125;</span><br><span class="line">            fileName=cmd.split(<span class="string">' '</span>)[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> os.path.isfile(fileName):</span><br><span class="line">                dataHeader_s2c[<span class="string">'status'</span>]=<span class="string">'Y'</span></span><br><span class="line">                dataHeader_s2c[<span class="string">'filename'</span>]=fileName</span><br><span class="line">                dataHeader_s2c[<span class="string">'size'</span>]=os.stat(fileName).st_size <span class="comment">#文件大小</span></span><br><span class="line">                conn.send((json.dumps(dataHeader_s2c)).encode(<span class="string">'utf-8'</span>))</span><br><span class="line">                conn.recv(<span class="number">1024</span>) <span class="comment">#防止粘包</span></span><br><span class="line">                md5=hashlib.md5()</span><br><span class="line">                <span class="keyword">with</span> open(fileName,<span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                        md5.update(line)</span><br><span class="line">                        conn.send(line)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        conn.recv(<span class="number">1024</span>)<span class="comment">#防止粘包</span></span><br><span class="line">                        conn.send(md5.hexdigest().encode(<span class="string">'utf-8'</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dataHeader_s2c[<span class="string">'status'</span>]=<span class="string">'N'</span></span><br><span class="line">                conn.send((json.dumps(dataHeader_s2c)).encode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>

<h4 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h4><pre><code>命令处理：客户端首先接收用户输入的命令，如果输入为空则跳出本轮循环，进入下一轮循环，重新等待用户的输入，如果输入不为空则将输入的内容发送给服务器。服务器接收到数据之后也会判断这个内容是否为空，如果内容为空就会认为客户端已经断开链接，从而直接跳出这一层的循环，等待并处理下一个接入的客户端。可能大家会有疑问，我们在客户端已经检查了用户的输入，可以确保发送给服务器的数据不为空，在服务器端又做一遍这样的检查，有什么用呢？其实python的socket模块做了特殊的设计，当客户端进程退出之前，他会自动向服务器发送一个空消息。所以服务器就是依据这一点来判断客户端是否断开的。
编码与解码：在python3中socket的发送和接收的都是字节，所以我们在发送数据之前要将我们的数据编码（encode）成字节的形式才能发送，同理我们在客户端接收到的数据也是字节形式，所以我们要将其解码（decode）成字符串.
头数据：为了方便客户端接收数据（如什么时候数据可以接收完等），服务器端需要在真正发送数据之前先发送一些与客户端需要的文件相关的头数据，如文件的大小等信息，这里由于客户端并不是只做文件的下载处理，所以这里的头数据还包含了一些标志数据。这里是先将这些数据放入一个字典，然后序列化成json数据，到客户端之后在进行反序列化。
粘包问题：有时候我们需要连续几次发送不同的数据，在客户端也要连续几次来分别接收这些信息。但是这个时候事情往往不是按照我们想象的那样进行的，可能服务器的连续几次发送的信息被客户端的一次接收给接收到了，这个问题叫做粘包。这显然不是我们希望得到的，我们需要解决这个问题。解决这个问题的思路就是将这些连续发送的数据让它不连续，比如我们让一次发送与下一次发送中间休息（sleep）几秒.但是这种方法显然是不对的，这会极大的降低数据传输的速度。实际上我们解决的方法是在两次连续的发送中间来一次接收，或者让接收方在接收的时候恰恰接收当次发送的那么多数据，我们上面采用的都是前一种方法。
md5比对：为了判断在数据传输的过程中是否发生错误，我们还需要对发送过去的数据和原数据进行一个md5值比对，如果不一致我们就删掉破损的文件，提示用户重新下载。</code></pre><h3 id="操作远程主机命令"><a href="#操作远程主机命令" class="headerlink" title="操作远程主机命令"></a>操作远程主机命令</h3><h4 id="客户端代码-1"><a href="#客户端代码-1" class="headerlink" title="客户端代码"></a>客户端代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    client.send(cmd.encode(<span class="string">"utf-8"</span>))</span><br><span class="line">    dateHeader_s2c = json.loads(client.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    response_length=dateHeader_s2c[<span class="string">'size'</span>]</span><br><span class="line">    accept_length=<span class="number">0</span></span><br><span class="line">    accept_content=<span class="string">b''</span></span><br><span class="line">    client.send(<span class="string">b'ok'</span>)</span><br><span class="line">    <span class="keyword">while</span> accept_length&lt;response_length:</span><br><span class="line">        accept_temp = client.recv(<span class="number">1024</span>)</span><br><span class="line">        accept_length+=len(accept_temp)</span><br><span class="line">        accept_content+=accept_temp</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(accept_content.decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>

<h4 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    dataHeader_s2c = &#123;&#125;</span><br><span class="line">    res_content = os.popen(cmd).read()</span><br><span class="line">    <span class="keyword">if</span> len(res_content) == <span class="number">0</span>:</span><br><span class="line">        res_content = <span class="string">"命令没有返回内容"</span></span><br><span class="line">    dataHeader_s2c[<span class="string">'type'</span>] = <span class="string">'cmd'</span></span><br><span class="line">    dataHeader_s2c[<span class="string">'size'</span>] = len(res_content)</span><br><span class="line">    conn.send(json.dumps(dataHeader_s2c).encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    conn.recv(<span class="number">1024</span>)</span><br><span class="line">    conn.send(res_content.encode(<span class="string">"utf-8"</span>))</span><br></pre></td></tr></table></figure>

<h4 id="需要注意的点-1"><a href="#需要注意的点-1" class="headerlink" title="需要注意的点"></a>需要注意的点</h4><p>其实这个过程和前面的文件上传下载差不多，上面要注意的点，这里都要注意这里的主要实现其实就是python中的os模块中的操作操作系统的接口res_content = os.popen(cmd).read()，这一popen需要传输一个系统的命令（字符串），同时返回的是一个类似文件的对象，我们read它之后得到的就是命令返回的内容（字符串）</p>
<p>这里还有一些命令是运行不了的，或者说可以执行但无法返回命令的输出。</p>
<h1 id="我的demo"><a href="#我的demo" class="headerlink" title="我的demo"></a>我的demo</h1><p><a href="https://github.com/Andrewpqc/FakeSsh" target="_blank" rel="noopener">demo</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2017/08/31/a-chatroom-based-on-Express-and-Socketio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/31/a-chatroom-based-on-Express-and-Socketio/" itemprop="url">基于Socket.io和Express的聊天室</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-31T08:06:27+08:00">
                2017-08-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NodeJS/" itemprop="url" rel="index">
                    <span itemprop="name">NodeJS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h1><p>HTTP协议是无状态的，每次处理完客户端的一个(http/1.0)或几个(http/1.1)请求就会立即断开并且。这就导致很难实现客户端与服务器数据的实时同步。以往大家实现实时通信都是通过ajax长轮询，和long poll长连接两种方式。ajax长轮询就是客户端每隔很短的时间就去访问一次服务器，看服务器那里有没有新的数据，如果有就将数据渲染在页面上，没有就一段时间之后又发起相同的请求。如果发起请求的间隔时间够短，就可以给人造成一种实时通信的错觉。ajax请求是一种非阻塞的请求，渲染消息的时候不用重新加载页面，所以用户体验比较好。但是这样频繁的发请求，并且大多数请求是无用的，这对服务器和客户端都造成了巨大的资源浪费。long poll长连接和ajax轮询其实是差不多的,只不过是采用阻塞的方式，如果服务器现在还没有消息，那么就不返回response给他，导致客户端一直在等待,直到等到了消息才返回，返回后又发起一个http请求，又到服务器哪儿去等着。上面的两种方式其实都是客户端不断的发起http请求，服务器被动的接受请求并处理。他们都不是很好的处理这个问题的方式。这时h5中提出了Websocket协议。Websocket解决了下面的几个问题：<br>１．在客户端与服务器首次连接之后，客户端与服务器的地位就平等了，两者之间可以进行真正的全双工通信。不仅客户端可以发送请求给服务器，服务器也可以主动通知客户端了。也就是说客户端再也不用一次一次的到服务器那里去询问有没有新数据，或者傻傻的到服务器那里去等着，直接在有新数据的时候让服务器通知一下客户端就行了。<br>２．首次连接之后，客户端与服务器之间的通信不需要发送头信息了，提高了信息交换的效率。</p>
<h2 id="Websocket的细节"><a href="#Websocket的细节" class="headerlink" title="Websocket的细节"></a>Websocket的细节</h2><p>首先是客户端发送一个http请求给服务器，这个请求头中包含转换协议的数据，服务器接受到之后就会在之后本次会话的其他心意转为tcp,之后两者就是以tcp协议来交流的，而不是http.由于websocket的这种设计与原来的通过http协议运作的浏览器与服务器的架构有很大的不同，所以websocket的应用需要浏览器和服务器以及中间可能有的代理服务器的共同的支持。好在现在的主流的高版本的浏览器，和主流的高版本的服务器软件都已经支持了websocket这一协议，并且越来越多的产品都在慢慢的支持websocket.</p>
<h2 id="socket-IO库"><a href="#socket-IO库" class="headerlink" title="socket.IO库"></a>socket.IO库</h2><p>socket.IO是一个基于websocket的一个实时获取浏览器/客户端数据的库，他能够使开发者不必关心websocket底层的细节，而只需要关心自己的业务逻辑，顶层调用非常简单。并且，它还为不支持websocket协议的浏览器，提供了长轮询的透明模拟机制,它会自动根据浏览器从WebSocket、AJAX长轮询、Iframe流等等各种方式中选择最佳的方式来实现网络实时应用，非常方便和人性化，而且支持的浏览器最低达IE5.5。这使得在大部分情境下，你都能通过socket.io与浏览器保持类似长连接的功能。由于nodejs的单线程，异步I/O,事件驱动的特点，它非常适合编写websocket方面的应用。</p>
<h1 id="用socket-io和express打造聊天室"><a href="#用socket-io和express打造聊天室" class="headerlink" title="用socket.io和express打造聊天室"></a>用socket.io和express打造聊天室</h1><h2 id="下载socket-io"><a href="#下载socket-io" class="headerlink" title="下载socket.io"></a>下载socket.io</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install socket.io</span><br></pre></td></tr></table></figure>

<h2 id="服务器端代码"><a href="#服务器端代码" class="headerlink" title="服务器端代码"></a>服务器端代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入express并实例化一个app</span></span><br><span class="line"><span class="keyword">var</span> express=<span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app=express();</span><br><span class="line"><span class="comment">//socket.io需要原生node的http模块的支持</span></span><br><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer(app);</span><br><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(server);</span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">//监听客户端的连接，并将连接传入socket</span></span><br><span class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">		<span class="comment">//当前连接的socket监听客户端的名为'c2s'的数据发送，并将接收到的数据传入msg</span></span><br><span class="line">        socket.on(<span class="string">'c2s'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">        		<span class="comment">//向所有的当前在线的客户端发送一个名为's2c'的广播</span></span><br><span class="line">                io.sockets.emit(<span class="string">'s2c'</span>, msg);</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>聊天| 聊天室<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span>&gt;</span>欢迎你，<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">'username'</span>&gt;</span>&#123;&#123;username&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"content"</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"submit"</span>&gt;</span>发布<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">'/socket.io/socket.io.js'</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">'/public/javascripts/plugin/jquery-1.12.4.js'</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        	<span class="comment">//创建一个sokeet对象，io()是上面的socket.io.js暴露给我们的一个函数</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> socket=io.connect(<span class="string">'http://localhost'</span>);</span></span><br><span class="line"><span class="javascript">			<span class="comment">//点击提交触发事件</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#submit"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            	<span class="comment">//判断输入框中是否有内容</span></span></span><br><span class="line"><span class="javascript">            	<span class="keyword">if</span>($(<span class="string">'#content'</span>).val())&#123;</span></span><br><span class="line"><span class="javascript">            		<span class="comment">//向服务器发送一个名为'c2s'的消息，后面的一个对象为消息的内容</span></span></span><br><span class="line"><span class="javascript">            		socket.emit(<span class="string">"c2s"</span>,&#123;<span class="attr">user</span>:$(<span class="string">"#username"</span>).text(),<span class="attr">content</span>:$(<span class="string">'#content'</span>).val()&#125;);</span></span><br><span class="line"><span class="javascript">            		<span class="comment">//清空输入框</span></span></span><br><span class="line"><span class="javascript">                	$(<span class="string">"#content"</span>).val(<span class="string">''</span>);</span></span><br><span class="line"><span class="javascript">            	&#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">            		<span class="comment">//如果输入框为空，则什么也不做</span></span></span><br><span class="line">            	&#125; </span><br><span class="line">            &#125;);</span><br><span class="line"><span class="javascript">            <span class="comment">//按下enter键触发事件</span></span></span><br><span class="line"><span class="javascript">            $(<span class="string">"#content"</span>).keydown(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">if</span>((e.keyCode===<span class="number">13</span>)&amp;&amp;($(<span class="string">'#content'</span>).val())&#123;</span></span><br><span class="line"><span class="javascript">                            socket.emit(<span class="string">"c2s"</span>,&#123;<span class="attr">user</span>:$(<span class="string">"#username"</span>).text(),<span class="attr">content</span>:$(<span class="string">'#content'</span>).val()&#125;);</span></span><br><span class="line"><span class="javascript">                            $(<span class="string">"#content"</span>).val(<span class="string">" "</span>);</span></span><br><span class="line"><span class="javascript">					&#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">						<span class="comment">//啥也不做</span></span></span><br><span class="line">					&#125;</span><br><span class="line">            &#125;);</span><br><span class="line"><span class="javascript">            <span class="comment">//监听服务器发出的's2c'消息，消息内容传入msg        	</span></span></span><br><span class="line"><span class="javascript">            socket.on(<span class="string">'s2c'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            	<span class="comment">//利用jQuery将消息渲染到页面上</span></span></span><br><span class="line"><span class="javascript">                  $(<span class="string">"#ul"</span>).prepend(<span class="string">"&lt;li&gt;&lt;b&gt;"</span>+msg.user+<span class="string">"&lt;/b&gt;说"</span>+msg.content+<span class="string">"&lt;/li&gt;"</span>)</span></span><br><span class="line">            &#125;);</span><br><span class="line">   		 &#125;);</span><br><span class="line">	<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当我们的服务器跑起来之后,我们可以直接在浏览器中访问这样一个地址：127.0.0.1:3000/socket.io/socket.io.js,这时我们会发现这一个url已经被劫持了，页面中出现了一个js脚本。我们再回头看一看我们的项目文件夹中，并没有出现socket.io.js这样一个脚本。这个js文件实际放在了服务器端的node_modules文件夹中，在请求这个文件时会重定向，因此不要诧异服务器端不存在这个文件但为什么还能正常工作。其实你可以把服务器端的socket.io.js这个文件拷贝到本地，使它成为客户端的js文件，这样就不用每次都向服务器请求这个js文件，以增强稳定性。无论如何我们必须在客户端引用这个脚本才能使用socket.io的功能。从上面的代码看，群聊聊天室的原理是:某一个客户端需要发言，他就把自己的发言内容先发送到聊天室的服务器，然后由服务器对所有连接到服务器的客户端进行广播，这样其他用户就可以看到你的消息，这也就实现了群聊。</p>
<h2 id="socket-IO的使用"><a href="#socket-IO的使用" class="headerlink" title="socket.IO的使用"></a>socket.IO的使用</h2><p>从上面的聊天室的例子就可以发现，socket.io在使用上的核心其实就是两个函数emit()和on().</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emit()</span><br></pre></td></tr></table></figure>

<p>用来发射一个事件或者说触发一个事件，第一个参数为事件名，第二个参数为要发送的数据，第三个参数为回调函数（一般省略，如需对方接受到信息后立即得到确认时，则需要用到回调函数）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">on()</span><br></pre></td></tr></table></figure>

<p>用来监听一个 emit 发射的事件，第一个参数为要监听的事件名，第二个参数为一个匿名函数用来接收对方发来的数据，该匿名函数的第一个参数为接收的数据，若有第二个参数，则为要返回的函数。</p>
<h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><h4 id="监听客户端的链接与断开"><a href="#监听客户端的链接与断开" class="headerlink" title="监听客户端的链接与断开"></a>监听客户端的链接与断开</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监听客户端连接,回调函数会传递本次连接的socket</span></span><br><span class="line">io.on(‘connection’,<span class="function"><span class="keyword">function</span>(<span class="params">socket</span>));</span></span><br><span class="line"><span class="function">//监听客户端的断开连接,这里会传入"<span class="title">transport</span> <span class="title">close</span>"这个字符串到<span class="title">c</span>这个形参中</span></span><br><span class="line"><span class="function"><span class="title">socket</span>.<span class="title">on</span>(<span class="params"><span class="string">'disconnect'</span>,function(c</span>))</span></span><br></pre></td></tr></table></figure>

<h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给所有的客户端广播消息(包含发送消息过来触发这个函数的那个客户端)</span></span><br><span class="line">io.sockets.emit(‘<span class="built_in">String</span>’,data);</span><br><span class="line">或　io.emit(<span class="string">'String'</span>,data);</span><br><span class="line"><span class="comment">//给客户端广播消息(除了该socket所属于的那个客户端)</span></span><br><span class="line">socket.boradcast.emit(<span class="string">'String'</span>,data)</span><br><span class="line"><span class="comment">//给指定的客户端发送消息</span></span><br><span class="line">io.sockets.socket(socketid).emit(‘<span class="built_in">String</span>’, data);</span><br><span class="line"><span class="comment">//给该socket的客户端发送消息</span></span><br><span class="line">socket.emit(‘<span class="built_in">String</span>’, data);</span><br></pre></td></tr></table></figure>

<h4 id="监听客户端的事件"><a href="#监听客户端的事件" class="headerlink" title="监听客户端的事件"></a>监听客户端的事件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监听该socket所属于的客户端的String消息，这里的String是自定义的消息名称</span></span><br><span class="line">socket.on(<span class="string">'String'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>))</span></span><br></pre></td></tr></table></figure>

<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">io.on(<span class="string">'connection'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123;</span><br><span class="line">	socket.on(<span class="string">'group1'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	socket.join(<span class="string">'group1'</span>)</span><br><span class="line">	&#125;);</span><br><span class="line">	socket.on(<span class="string">'group2'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	socket.join(<span class="string">'group2'</span>)</span><br><span class="line">	&#125;);	</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如上面的代码，当一个客户端链接进来之后，并且发送了一个名为group1的事件消息，那么在服务器端，它与服务器的socket就通过socket.join(‘group1’)加入了一个名为group1的分组中，客户端的代码可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">'text/javascript'</span> src=<span class="string">'/socket.io/socket.io.js'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*创建与服务器的连接，并且返回一个socket对象，这里由于是服务器和客户端到是在本地</span></span><br><span class="line"><span class="comment">*所以在connect()中可以不用传递值，如果是在生产环境这里就需要传值，如：</span></span><br><span class="line"><span class="comment">* socket.connect('localhost:3000')</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> socket=io.connect();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*发送一个名为group1的消息，就可以在服务器的处理中被加入group1组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">socket.emit(<span class="string">'group1'</span>,&#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>一个用户可以存在与多个分组中</p>
<h4 id="踢出分组"><a href="#踢出分组" class="headerlink" title="踢出分组"></a>踢出分组</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.leave(data.room)</span><br></pre></td></tr></table></figure>

<h4 id="向一个组广播消息"><a href="#向一个组广播消息" class="headerlink" title="向一个组广播消息"></a>向一个组广播消息</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向一个组广播消息(发送者无法收到消息)，并且这一方法允许当前socket不在这一分组中</span></span><br><span class="line">socket.broadcast.to(<span class="string">'your group name'</span>).emit(<span class="string">'broadcast group message'</span>);</span><br><span class="line"><span class="comment">//向一个组广播消息(包括发送者都能收到消息),发送者必须在分组中</span></span><br><span class="line">io.sockets.in(<span class="string">'your group name'</span>).emit(<span class="string">'broadcast romm message'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="获取连接的客户端socket"><a href="#获取连接的客户端socket" class="headerlink" title="获取连接的客户端socket"></a>获取连接的客户端socket</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io.sockets.clients().forEach(<span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//可以对其进行操作</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="获取分组信息"><a href="#获取分组信息" class="headerlink" title="获取分组信息"></a>获取分组信息</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取所有的组别信息</span></span><br><span class="line">io.sockets.manager.rooms</span><br><span class="line"><span class="comment">//获取此socketid进入的组别信息</span></span><br><span class="line">io.sockets.manager.roomClients[socket.id]</span><br><span class="line"><span class="comment">//获取某一个房间中的客户端，返回所有在此房间的socket实例</span></span><br><span class="line">io.sockets.clients(<span class="string">'某组名'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><h4 id="建立socket链接"><a href="#建立socket链接" class="headerlink" title="建立socket链接"></a>建立socket链接</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket=io(<span class="string">'http://&lt;hostname&gt;:&lt;port&gt;'</span>);</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">var</span> socket=io.connect(<span class="string">'http://&lt;hostname&gt;:&lt;port&gt;'</span>)</span><br></pre></td></tr></table></figure>

<p>如果是在本机做测试，客户端，服务器都在同一台主机上，则上面两个连接方式<br>的括号中可以不用写东西</p>
<h4 id="监听服务器的消息"><a href="#监听服务器的消息" class="headerlink" title="监听服务器的消息"></a>监听服务器的消息</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">socket.on(<span class="string">'msg'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(data);</span><br><span class="line">	<span class="comment">//向服务器发送消息</span></span><br><span class="line">	socket.emit(<span class="string">'msg_c2s'</span>,&#123;&#125;);</span><br><span class="line">&#125;)；</span><br></pre></td></tr></table></figure>

<h4 id="监听socket断开与重连"><a href="#监听socket断开与重连" class="headerlink" title="监听socket断开与重连"></a>监听socket断开与重连</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">socket.on(<span class="string">'disconnect'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'与服务器断开链接'</span>)；</span><br><span class="line">&#125;);</span><br><span class="line">socket.on(<span class="string">'reconnect'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'重新链接到服务器'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述的’disconnect’,’reconnect’是socket.io默认支持的可以被客户端监听的事件，像这样的事件有：<br>connect：连接成功<br>connecting：正在连接<br>disconnect：断开连接<br>connect_failed：连接失败<br>error：错误发生，并且无法被其他事件类型所处理<br>message：同服务器端message事件<br>anything：同服务器端anything事件<br>reconnect_failed：重连失败<br>reconnect：成功重连<br>reconnecting：正在重连<br>当第一次连接时，事件触发顺序为：connecting-&gt;connect；当失去连接时，事件触发顺序为：disconnect-&gt;reconnecting（可能进行多次）-&gt;connecting-&gt;reconnect-&gt;connect</p>
<h1 id="我的demo"><a href="#我的demo" class="headerlink" title="我的demo"></a>我的demo</h1><p><a href="https://github.com/Andrewpqc/simpleChatroom" target="_blank" rel="noopener">demo</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2017/08/25/Docker-container-operation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/25/Docker-container-operation/" itemprop="url">Docker容器操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-25T18:32:34+08:00">
                2017-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面总结了docker的镜像的基本操作,有了镜像之后我们就可以用这个镜像来运行容器了。</p>
<h1 id="docker的容器技术是什么？"><a href="#docker的容器技术是什么？" class="headerlink" title="docker的容器技术是什么？"></a>docker的容器技术是什么？</h1><p>以我极度不专业的话来讲，docker的容器技术就是一种数据虚拟化和数据隔离的技术，通过某个镜像，比如ubuntu，就可以在你的电脑上虚拟出来一台装了ubuntu系统的计算机，它里面有文件系统，有用户管理，文件的权限管理等等，你可以在里面下载软件，敲实体ubuntu中能够敲的绝大多数命令，并且他可以与外界的环境进行有效的隔离。虽然他无法完全模拟出物理机的所有功能，但是对于应用的部署，集群的构建，分布式系统的构建来说，他的功能已经够用。灵活高效，对物理机的低消耗是他的特点。</p>
<h1 id="Container-VS-Virtual-Machine"><a href="#Container-VS-Virtual-Machine" class="headerlink" title="Container VS Virtual Machine"></a>Container VS Virtual Machine</h1><p>与虚拟机相比Docker实现了轻量级虚拟化。<br><img src="/images/dockervsvm.png" alt="docker vs VM"></p>
<p>为什么不是虚拟机，而是Container呢？大家可能会讲，虚拟机的功能比Container的功能全，比如虚拟机可以虚拟出图形化操作，但是Container就不行。没错，同样作为一种数据虚拟化和数据隔离的技术，虚拟机在功能上比Container强的多，但是虚拟机的资源消耗，安装过程，存储空间的占用等都是惊人的。虚拟机中部署的应用，是依赖于虚拟机所安装的操作系统，虚拟机的操作系统又依赖于虚拟机引擎，而虚拟机引擎则依赖于其底层包和物理机的操作系统。而Container则不一样，在其中的应用直接依赖于docker引擎及其底层包，然后docker引擎则依赖于操作系统。两相对比，就可以发现，运行虚拟机比运行container要多占用一个操作系统的空间。更不用说物理机的操作系统要付出多大的代价了。最为重要的是，虚拟机的安装过程是及其繁琐和耗时的，这对于集群的构建来说是致命的。而对Container,只要一条命令即可安装docker,然后几条命令就可以跑起来一个容器，并且这个容器可以非常方便的移植到其他的主机上。</p>
<h1 id="容器操作的基本命令"><a href="#容器操作的基本命令" class="headerlink" title="容器操作的基本命令"></a>容器操作的基本命令</h1><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run IMAGE [COMMAND] [ARG…]</span><br></pre></td></tr></table></figure>

<p>IMAGE－－－－－镜像的名称，可以是镜像的唯一ＩＤ，也可以是repository:tag的形式<br>COMMAND－－－－－启动容器后运行的命令<br>ARG－－－－－命令的参数<br>比如下面以ubuntu为镜像，运行起来一个容器，并且在容器中运行/bin/bash(即打开容器的bash):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p>运行完了之后我们发现容器直接退出了！？容器退出了，但是我们的命令确实执行了，容器运行了起来，bash也打开了，然后容器就退出了。可是这有什么用呢?我们需要容器一直打开，然后进行其他操作。请往下看。</p>
<h2 id="启动交互式容器"><a href="#启动交互式容器" class="headerlink" title="启动交互式容器"></a>启动交互式容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run –i –t IMAGE /bin/bash</span><br></pre></td></tr></table></figure>

<p>-i –interactive=ture|false 默认为false 告诉docker的守护进程，为容器始终打开标准输入<br>-t –tty=ture|false 默认为false，告诉docker为容器分配一个伪tty终端</p>
<p>上面的命令让新创建的容器提供了一个交互式的shell 当然IMAGE里必须有bash才行。这条命令运行完了之后，我们就直接进入了这个容器的交互式运行环境，我们会发现我们终端中输入命令的前缀已经发生了变化。也就是说，现在你所输入的命令已经不是在你的物理机上执行的，而是在容器中执行的。你可以输入ls,ps 等你在物理机上常使用的命令，你会发现你就好像进入了另一台计算机的终端一样。最后你要想直接退出当前容器，请直接在容器中输入exit，这样你就退出了容器，回到了你的主机bash中。同时刚才的容器也就停止运行了</p>
<h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps  查看当前还在运行的容器</span><br><span class="line">$ docker ps –a 查看系统中所有的容器</span><br><span class="line">$ docker ps –l   查看最近一次使用的容器</span><br></pre></td></tr></table></figure>

<h2 id="查看容器的详细信息"><a href="#查看容器的详细信息" class="headerlink" title="查看容器的详细信息"></a>查看容器的详细信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect NAME</span><br></pre></td></tr></table></figure>

<p>NAME既可以是docker ps 命令返回内容中的容器的CONTAINER ID也可以是最后一列中的NAME，该命令会返回该容器的详细信息。在将镜像的时候也提到过docker的inspect命令，inspect命令既可以查看容器也可以查看镜像，并且用法还相同。</p>
<h2 id="自定义容器名"><a href="#自定义容器名" class="headerlink" title="自定义容器名"></a>自定义容器名</h2><p>我们在上面查看容器的一些操作中会发现，有一列数据NAME,每一个容器都会对应一个NAME,这里的NAME非常没有规律，不便于记忆，就是一串随机的字符串。那是因为我们在运行这个容器的时候没有指定容器的名字，然后docker就分配了一个随机的名字给我们的容器。那么怎样制定容器的名字呢？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --name　容器名 ubuntu /bin/bash</span><br></pre></td></tr></table></figure>

<p>看到没，就是这么简单，在刚才运行容器的命令上面再加一个–name的参数就可以指定容器名了。</p>
<h2 id="重新启动已经停止的容器"><a href="#重新启动已经停止的容器" class="headerlink" title="重新启动已经停止的容器"></a>重新启动已经停止的容器</h2><p>我们刚才用exit直接退出了容器，容器就停止运行了，假如我们又想进入这个容器，怎么办呢？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker start [-i] 容器名</span><br></pre></td></tr></table></figure>

<p>-i 表示是否用交互的方式启动已经停止的容器</p>
<h2 id="删除已经停止的容器"><a href="#删除已经停止的容器" class="headerlink" title="删除已经停止的容器"></a>删除已经停止的容器</h2><p>又假如我们不想要这个容器了，想要删除他，可以下面这样做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rm 容器名或ＩＤ</span><br></pre></td></tr></table></figure>

<p>这样这个容器就删除了，注意这个命令只能删除已经停止运行的容器</p>
<h2 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h2><p>有时，需要将容器从一个系统迁移到另外一个系统，此时就可以使用docker的导入和导出功能。</p>
<h3 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h3><p>导出容器是指导出一个已经创建的容器到一个文件，不管此时这个容器是否处于运行状态，都可以使用docker export命令，示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">export</span> -o test.tar CONTAINER_ID</span><br><span class="line">或者：</span><br><span class="line">$ docker <span class="built_in">export</span> CONTAINER_ID &gt;test.tar</span><br></pre></td></tr></table></figure>

<p>之后可以将导出的tar文件传输到其他的机器上，然后通过导入命令导入到系统中，从而实现了容器的迁移。</p>
<h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><p>导出的文件可以通过docker import命令导入变成镜像，下面将上面导出的test.tar文件导入到系统中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker import test.tar - <span class="built_in">test</span>/ubuntu:v1.0</span><br></pre></td></tr></table></figure>

<p>完成后通过docker images命令就可以看到导入的test/ubuntu:v1.0镜像了。</p>
<h3 id="导入导出容器与导入导出镜像的区别"><a href="#导入导出容器与导入导出镜像的区别" class="headerlink" title="导入导出容器与导入导出镜像的区别"></a>导入导出容器与导入导出镜像的区别</h3><p>在docker image and repostory中讲过docker load命令来导入一个镜像文件，这与docker import命令十分相似。事实上既可以使用docker load命令来导入镜像存储文件到本地镜像库，也可以使用docker import命令来导入一个容器快照到本地镜像库。这两者之间的区别在于容器快照文件将丢失所有的历史记录和元数据信息（仅保存容器运行时的快照状态），而镜像存储文件将保存完整记录，体积也更大。</p>
<h2 id="docker的守护式容器"><a href="#docker的守护式容器" class="headerlink" title="docker的守护式容器"></a>docker的守护式容器</h2><p>我们在交互式容器中不要以exit 命令来退出，而是用Ctrl+Ｐ,Ctrl+Q来退出交互式容器，这时我们就得到了一个守护容器。这种方式退出与exit不同的是，用exit退出之后容器就停止了，而这种方式容器就会移入到后台运行，容器并未停止。<br>如果我们想要再次进入此在后台运行的容器的话，我们可以使用：updated:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker attach 容器名或ＩＤ</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it 容器名或ＩＤ　/bin/bash</span><br></pre></td></tr></table></figure>

<p>这样我们就又可以进入其交互式环境中了。上面这两种进入守护式容器的命令稍有不同，后面会讲到。</p>
<p>除了通过交互式环境得到守护容器外，我们还通过run命令来启动一个守护式容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run –d IMAGE [COMMAND] [ARG…]</span><br></pre></td></tr></table></figure>

<p>在run命令中加入-d这个选项之后，命令的执行被放在了后台。这样同样可以得到一个守护式容器。</p>
<h2 id="Log命令查看容器的日志"><a href="#Log命令查看容器的日志" class="headerlink" title="Log命令查看容器的日志"></a>Log命令查看容器的日志</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">log</span> [-f ] [-t ] [--tail] 容器名</span><br></pre></td></tr></table></figure>

<p>-f –follow=ture|false 默认为 false 跟踪日志的变化，并返回结果<br>-t –timestamps=ture|false 默认为false 给每条日志加上一个时间戳，及日志产生的时间<br>–tail 选择结尾处多少数量的日志，如果不指定，返回所有的日志</p>
<h2 id="查看运行中容器内的进程"><a href="#查看运行中容器内的进程" class="headerlink" title="查看运行中容器内的进程"></a>查看运行中容器内的进程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker top 容器名</span><br></pre></td></tr></table></figure>

<h2 id="在已经运行的容器中启动新的进程"><a href="#在已经运行的容器中启动新的进程" class="headerlink" title="在已经运行的容器中启动新的进程"></a>在已经运行的容器中启动新的进程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> [-i] [-t] [-d] 容器名 [COMMAND] [ARG…]</span><br></pre></td></tr></table></figure>

<p>虽然docker的理念是一个容器运行一种服务，但我们有时任然需要做一些监控，日志记录等服务，所以有时候我们还会在已经运行的容器中开启新的进程，上面的命令可以做到这一点，可以发现他与run命令非常像。</p>
<h2 id="停止守护式容器"><a href="#停止守护式容器" class="headerlink" title="停止守护式容器"></a>停止守护式容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop 容器名</span><br><span class="line">$ docker <span class="built_in">kill</span> 容器名</span><br></pre></td></tr></table></figure>

<h2 id="attach和exec的区别"><a href="#attach和exec的区别" class="headerlink" title="attach和exec的区别"></a>attach和exec的区别</h2><p>刚刚我们讲到进入守护式容器有两种方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker attach 容器名或ＩＤ</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it 容器名或ＩＤ　/bin/bash</span><br></pre></td></tr></table></figure>

<p>他们之间有什么区别呢？他们有很大的区别，attach是进入前面的那个进程，并且进入你离开时的状态，而exec则是在容器内开启一个新的进程。虽然两条命令都可以进入到一个容器中去操作容器，但是我们还是有必要学会在什么时候用什么命令。如果我们一直以exec进入容器，并且在退出的时候是以ctrl+p,ctrl+q的方式退出的话，那么容器中开启的进程会逐渐的增多，这对资源是一个巨大的消耗，如果以exit退出当前的进程则可以避免这个问题。attach呢？貌似我们可以一直使用attach，其实不然。由于attach总是进入到同一个进程，如果那个进程由于运行个什么东西而被阻塞（比如uwsgi）那么你就无法再次进入到这个进程了，这个时候就该使用exec开启一个新线程。总而言之，明白两者之间的区别，根据不同的情况使用不同的命令，才是最好的。<br>对了，关于attach还有一个小问题。就是当使用attach进入时，容器中的命令提示符总是迟迟不出来，好像就是卡在哪儿似的。其实他已经进入了容器，只是不显示前面的命令提示符而已。这个时候我们可以敲一个ls或者是个其他的什么命令，就可以让命令行回归正常了。不知道这是不是docker的一个小bug呢？（我的系统环境是：4.10.0-32-generic，docker版本：Docker version 17.05.0-ce, build 89658be）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2017/08/24/Docker-introduction-and-basic-operation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/24/Docker-introduction-and-basic-operation/" itemprop="url">Docker简介,安装及镜像基本操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-24T17:05:31+08:00">
                2017-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/images/docker.jpeg" alt="docker"></p>
<h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><p>Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上.Docker容器完全使用沙箱机制，相互之间不会有任何接口。使用docker容器可以实现开发，测试，部署环境的一致化，缩短产品的开发周期。Docker是以Docker容器为资源分割和调度的基本单位，封装整个软件的运行时环境，为开发者和系统管理员设计的，用于构建，发布和运行分布式应用的平台。</p>
<p>docker是按照C/S架构设计而成，由docker客户端（docker client）,docker守护进程（docker doamonn,充当着server的角色，响应docker客户端的指令），docker　registry组成。docker里面还有两个重要的概念：镜像（image）与容器(container)。镜像是容器的基础。而docker的容器技术是基于Linux内核的namespace和cgroups实现的。两者分别实现了资源的隔离和限制。镜像存放在registry(注册服务器)中。</p>
<h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><h2 id="查看系统情况"><a href="#查看系统情况" class="headerlink" title="查看系统情况"></a>查看系统情况</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ uname -r</span><br></pre></td></tr></table></figure>

<p>Docker要求Ubuntu系统的内核版本高于３．１０。只有满足这一条件方可继续下面的步骤。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -qO- https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure>

<p>上面的命令会下载并安装最新版本的docker</p>
<h2 id="查看是否安装成功"><a href="#查看是否安装成功" class="headerlink" title="查看是否安装成功"></a>查看是否安装成功</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure>

<p>如果docker安装成功，上面的命令就会在docker　hub的公共仓库中去拉取hello-world这个镜像，并且启动镜像，生成一个容器，执行容器中预设的命令，然后立即退出容器。如果在这条命令的输出结果中出现的是关于docker的相关说明的话，那么你就安装成功了。注意：这里我们一定要以超级用户的身份运行这一命令，如果运行上述命令时漏掉了sudo,则会报下面的错误：docker:Connot not connect to the docker deamon.Is the docker deamon runing on this host? See ”docker run –help”，要想解决这个问题，请往下看。</p>
<h2 id="在Docker用户组中添加自己"><a href="#在Docker用户组中添加自己" class="headerlink" title="在Docker用户组中添加自己"></a>在Docker用户组中添加自己</h2><p>默认情况下，我们在执行docker命令的时候都要开启超级用户的权限，也就是说，每条命令都要输入sudo,这显然太麻烦了。好在docker在安装的时候给我们的系统中建了一个名为docker的用户组，只要是用户组中的用户，就可以直接使用docker了。方法是运行下面的这条命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  sudo usermod -aG docker &lt;your name&gt;</span><br></pre></td></tr></table></figure>

<p>然后重启docker服务（$ sudo servire docker restart），注销,重新登录系统，这样以后输入dcoker命令就不用每次都输入sudo了。</p>
<h2 id="配置镜像加速服务"><a href="#配置镜像加速服务" class="headerlink" title="配置镜像加速服务"></a>配置镜像加速服务</h2><p>现在我们已经完全安装好了docker,但是如果要想愉快的使用docker的话，还需要配置镜像加速服务。默认情况下，我们在拉取镜像时是在docker　hub这一个仓库中拉取的，由于docker hub仓库在国外，所以在国内拉取镜像时，速度及其的慢（翻墙除外）。好在国内有docker hub的镜像，我们可以通过简单的配置docker守护进程的启动选项即可免费使用这一镜像加速服务了。具体的配置就不讲了，因为在daocloud的网站上有配置脚本，并且提供了获取和启动脚本的命令，大家只需要到daocloud的网站上复制下这条命令，然后粘贴到终端并回车即可配置好，之后我们拉取镜像就用的是国内的镜像仓库，不用翻墙速度也超快。<br>下面的是我在daocloud上复制下的linux版本的加速命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s</span><br></pre></td></tr></table></figure>

<p>大家在配置的时候最好不要直接抄我这个，还是自己到daocloud网站上去复制吧，在加速器中。因为还存在版本的升级问题。</p>
<h1 id="Docker镜像基本操作"><a href="#Docker镜像基本操作" class="headerlink" title="Docker镜像基本操作"></a>Docker镜像基本操作</h1><p>Docker镜像是一个只读的Docker容器模板，含有启动Docker容器所需文件系统结构及其内容，因此是启动Docker容器的基础。docker镜像的文件内容以及一些运行Docker容器的配置文件组成了Docker容器的静态文件系统运行环境——rootfs。可以这么理解，Docker镜像是Docker容器的静态视角，Docker容器是Dokcer镜像的运行状态。</p>
<h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>获取镜像的方式有两种：<br>１．在docker hub或某个私有镜像仓库中拉取镜像(即下载镜像到本地)。<br>２．自己在基础镜像的基础上构建镜像。<br>由于即使是自己构建镜像也需要一个镜像作为基础镜像，而这个基础镜像一般是从docker hub的公共仓库中拉取的。所以我们在这里讲如何在docker hub中拉取镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull [OPTIONS] NAME [:TAG]</span><br></pre></td></tr></table></figure>

<p>常用选项OPTIONS:-a,–all-tags 会下载所有此仓库中的打了标签的镜像<br>如果拉取镜像的速度极慢，那么请参考docker的安装及基本概念中的镜像加速部分。</p>
<h2 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h2><p>其实我们一般在拉取镜像之前，会先以我们想要的镜像名字做一个搜索，然后更具搜索出来的信息来决定我们想要拉取的镜像。搜索的信息一般会包括这个镜像的星级，镜像是否为官方镜像以及此镜像的一个简短的描述。这些信息都可以作为我们拉取镜像的一个参考。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker search [OPTIONS] TERM</span><br></pre></td></tr></table></figure>

<p>常用选项OPTIONS: –automated 只显示自动化构建出的镜像<br>         –no-trunc    不使用截断输出<br>         -s,–stars=0  规定显示结果的最低星级</p>
<p>由于构建镜像是docker中的一个非常重要的一部分，所以我在后面会专门写一篇博客来介绍。</p>
<h2 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h2><p>我们不仅可以构建自己的镜像，还可以把我们构建的有适用性的高质量的镜像推送到docker hub上，贡献给社区的其他小伙伴(public)，或者自己保存(private),以便以后接着使用。说明:dockerhub的共公镜像存储服务是完全免费的。但仅支持每个用户一个私有仓库，如果你想保存更多的私有镜像的话，就可以使用docker hub的付费服务。在推送镜像之前，必须要有docker hub的账号。</p>
<p>命令行登录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login -p &lt;docker hub <span class="built_in">pwd</span> &gt; -u &lt;docker hub username&gt;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login</span><br></pre></td></tr></table></figure>

<p>下面会提示你输入用户名和密码。<br>登录成功之后就可以推送自己的镜像了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker push NAME[:TAG]</span><br></pre></td></tr></table></figure>

<p>成功之后，你可以登录docker hub,就可以看到这个镜像了，默认他是公开的，你可以把他转为私有。如果公开的话，你还可以在命令行搜索到你的镜像。当然，社区的其他人也可以搜索到。</p>
<p>这条命令并不会把整个镜像都提交上去，而是提交你在基础镜像的基础上所作出的修改的那一部分。</p>
<h2 id="tag命令添加镜像标签"><a href="#tag命令添加镜像标签" class="headerlink" title="tag命令添加镜像标签"></a>tag命令添加镜像标签</h2><p>为了方便在后续工作中使用特定的镜像，可以使用docker tag命令来为本地镜像任意添加新的标签，例如将ubuntu:latest打上标签：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag ubuntu:latest myubuntu:latest</span><br></pre></td></tr></table></figure>

<p>当我们使用docker images列出本地主机上的镜像信息的时候，可以看到多了一个拥有myubuntu:latest标签的镜像，之后我们就可以直接使用myubuntu:latest来表示这个镜像了。尝试一下就可以发现，打上新标签的镜像与原来的镜像的id是一样的，加入我们要删除原镜像ubuntu:latest,那么myubuntu:latest也就跟着不见了。事实上打上新的标签并没有复制一个新的镜像，实际上只是给原镜像去了一个别名而已，他们实际指向的是同一个镜像，docker tag命令添加的标签实际上起到了类似链接的作用。</p>
<h2 id="镜像历史"><a href="#镜像历史" class="headerlink" title="镜像历史"></a>镜像历史</h2><p>镜像文件由多个层组成，我们可以通过history子命令来查看各个层的创建信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">history</span> ubuntu:latest</span><br></pre></td></tr></table></figure>

<h2 id="导出镜像"><a href="#导出镜像" class="headerlink" title="导出镜像"></a>导出镜像</h2><p>如果要导出镜像到本地文件，可以使用docker save命令，例如：导出本地的ubuntu:latest镜像为文件ubuntu_latest.tar,使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker save -o ubuntu_latest ubuntu:latest</span><br></pre></td></tr></table></figure>

<p>之后就可以通过复制ubuntu_latest.tar文件将该镜像分享给别人。</p>
<h2 id="载入镜像"><a href="#载入镜像" class="headerlink" title="载入镜像"></a>载入镜像</h2><p>可以使用docker load将导出的tar文件再导入到本地镜像库，例如从文件ubuntu_latest.tar导入镜像到本地镜像列表，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker load --input ubuntu_latest.tar</span><br><span class="line">或者：</span><br><span class="line">$ docker load &lt; ubuntu_latest.tar</span><br></pre></td></tr></table></figure>

<p>这将导入镜像及其相关的元数据信息(包括标签等)</p>
<h2 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker images [OPTIONS] [REPOSITORY]</span><br></pre></td></tr></table></figure>

<p>上面的命令会列出我们系统中已经有的镜像，有下面这些条件：<br>　　　　　OPTIONS: -a,–all=false 默认为false,为true时会显示所有的镜像，包括中间层镜像<br>-f,–filter=[] 默认不过滤某个镜像<br>-q,–quit=false 为true时只显示镜像的唯一ＩＤ<br>REPOSITORY:　仓库名，制定要显示那个仓库的镜像</p>
<h2 id="查看镜像的详细信息"><a href="#查看镜像的详细信息" class="headerlink" title="查看镜像的详细信息"></a>查看镜像的详细信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect [OPTIONS] IMAGE [IMAGE2.....]</span><br></pre></td></tr></table></figure>

<p>docker的inspect命令可以输出所查看镜像的完整的详细的信息。其实这个命令也可以用来查看容器的信息。</p>
<h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi [OPTIONS] IMAGE [IMAGE2….]</span><br></pre></td></tr></table></figure>

<p>个选项会删除所指定的一个或多个镜像<br>OPTIONS: -f,–force 强制删除镜像<br>有时候我们想要删除某个仓库中的所有镜像，如过使用上面的这条命令的话就太麻烦了，这是我们可以使用下面这条命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi $(docker images –q ubuntu)</span><br></pre></td></tr></table></figure>

<p>上面的命令删除了ubuntu仓库中的所有镜像，$ docker images -q ubuntu 这条命令就会输出ubuntu仓库中的所有镜像的唯一id,而输出结果更好作为docker rmi命令的参数了。</p>
<h1 id="正确区分registry和repository"><a href="#正确区分registry和repository" class="headerlink" title="正确区分registry和repository"></a>正确区分registry和repository</h1><p>Repository：仓库，一个repository里面存放的着相同种类不同标签的镜像，比如Tomcat下面有很多个版本的镜像，它们共同组成了Tomcat的Repository。粗浅的理解：比如一个基础镜像ubuntu分别制作成了各种不同的功能，而打上了不同的标签，这样每一个镜像就是不同的镜像，而他们都共同组成了ubuntu的repository</p>
<p>Registry：镜像注册服务器，比如DockerHub网站就是一个registry,Registry上有很多的Repository，Redis、Tomcat、MySQL等等Repository组成了Registry。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Andrew</p>
              <p class="site-description motion-element" itemprop="description">All In</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">67</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Andrew</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
