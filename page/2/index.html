<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="All In">
<meta property="og:type" content="website">
<meta property="og:title" content="Andrew&#39;s Blog">
<meta property="og:url" content="http://andrewpqc.github.io/page/2/index.html">
<meta property="og:site_name" content="Andrew&#39;s Blog">
<meta property="og:description" content="All In">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Andrew&#39;s Blog">
<meta name="twitter:description" content="All In">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://andrewpqc.github.io/page/2/">





  <title>Andrew's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Andrew's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Stay hungry, Stay foolish.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2018/07/17/sequence-number-and-ack-number-in-tcp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/17/sequence-number-and-ack-number-in-tcp/" itemprop="url">TCP中的序号和确认号</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-17T15:09:19+08:00">
                2018-07-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index">
                    <span itemprop="name">Network</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在上一节讲到TCP报文段结构的时候讲到TCP首部中有两个字段序号和确认号，这一节里面我们就详细的讲讲TCP序号和确认号是如何在TCP的可靠数据传输服务中发挥重要作用的。在我们实际了解序号和确认号之前我们先要了解一下可靠数据传输原理。</p>
<h1 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h1><p>TCP协议是运行在网络层IP协议之上的，这里我们需要直接给出的是:IP协议提供了单一的服务，称为<strong>尽力而为服务</strong>，数据在IP协议上传输是不可靠的。我们要研究可靠数据传输，那么就需要知道数据直接在IP协议上传输怎么就不可靠了呢?会出现那些问题呢?数据在网络中传输会出现下列问题:</p>
<ul>
<li><strong>比特错误</strong></li>
<li><strong>分组丢失</strong></li>
<li><strong>接收顺序错乱</strong></li>
</ul>
<p>可靠数据传输的目的就是要解决上面的三个问题。</p>
<h2 id="比特错误"><a href="#比特错误" class="headerlink" title="比特错误"></a>比特错误</h2><p>对于比特错误，TCP首部中有检验和字段，接收方在接收到数据之后，通过检查检验和字段就可以判断传输的数据中是否发生了比特错误。如果发生了比特错误，接收方可以进行纠错，如果纠错无法恢复那么接收方就只能给发送方以反馈，把这个消息告诉发送方。发送方这时就会重传该分组。</p>
<p>上面描述中的给发送方以反馈的过程就是发送一个ACK分组，即确认的过程(事实上，无论接收到的分组是否出现了错误，接收方都应该给发送方以反馈，让发送方时刻知道当前数据发送是否正常。也就是说每发送一个分组，发送方和接收方之间都会有一个确认的过程)。而发送方重传则是当传输出现问题时的唯一解决办法。</p>
<p>这里我们忽略了一个问题，确认分组(ACK分组)也可能会发生比特错误。这时候该怎么办呢?首先我们要明白的一点是确认分组也是一个TCP报文段，也包含了检验和字段，也就是说发送方可以根据这个检验和字段判断出该确认分组是否出现了比特错误。基于这一点，这个问题或许有下面的三中解决办法:</p>
<p>1.当发送方接收到发生比特错误的确认分组时，需要向接收方也发过去一个类似确认分组的分组，以告诉接收方重新发送确认分组。但是这个类似于确认分组的分组也是可能会发生比特错误的。这这样的话我们明显陷入了一个循环问题，如果选择这种方法，无疑我们走上了一条困难重重之路。这种方法显然是行不通的。</p>
<p>2.第二种可能的方法是增加足够的检验和比特，使发送方不仅可以检测到比特错误，还可以自动纠正比特错误。这种方法对于会产生比特错误，但是不会丢失数据的情况来说是可以直接解决问题的。但真实的情景中丢失数据是存在的。所以这种方法在真实的情景中也是无能为力。</p>
<p>3.第三种方法是，当发送方检查到表明传送成功的确认分组和检查到由于比特错误而意义含糊不清的确认分组时，都重传最近分组。这种方法逻辑很清晰，但是却引入了一个新问题。由于比特错误而意义含糊不清的确认分组里面有一部分是表明传送成功，还有一部分是表明传送失败，而发送方都将其看做是传送失败的意思，从而重传最近分组。这样就在网络传输中引入了冗余分组。接收方不知道接收到的分组是新的还是一次重传。也就是说，接收方可能会两次或以上的接收到同一个分组，并且将他们当做新的分组处理。这样的话，发送方发送的数据与接收方接收到的数据就不一致，所以这也违背了可靠数据传输的原则。</p>
<p>解决这一个问题其实也很简单，我们只需要对第三种方法稍加改进即可。也就是在数据分组中添加一个新字段，让发送发对其数据分组编号，即将发送发数据分组的序号放入该分组中。于是，接收方只需要检查序号即可确定收到的分组是否是一次重传。(几乎所有现有的数据传输协议中，包括TCP，都采用了这种方法)</p>
<h2 id="分组丢失"><a href="#分组丢失" class="headerlink" title="分组丢失"></a>分组丢失</h2><p>下面我们来考虑分组丢失的问题。在丢失分组这个层面来讲，<strong>发送方将一个分组发送出去有可能发生发送的分组丢失或者接收方发送给发送方的用于确认的分组丢失</strong>,如下:<br><img src="/images/segment-lost.jpeg" alt><br><img src="/images/ack-lost.png" alt></p>
<p>上面的两种丢失情况，对于发送方来说是一样的－－接收不到确认分组。所以发送方采取的措施也是统一的－－重传。</p>
<p>但是，这里我们还需要考虑一些细节。发送方怎样确认自己接收不到一个分组的确认分组的呢？发送方需要等待足够长的时间以便确认分组丢失。<strong>显然发送方至少需要等待一个这样长的时间:即发送方与接收方之间的一个往返时延加上接收方处理一个分组的时间。</strong>在许多网络环境下，最欢情况下的最大时延是很难估算的，确定的因素非常少。在实际的处理是发送方明智的选择一个时间　值，以判定可能发生了丢包(尽管不能确保)，如果在这个时间内没有收到ACK，则重传该分组。这就是TCP的<strong>超时重传机制</strong>。注意到如果一个分组经历了一个特别大的时延，发送方可能会重传该分组，即使该数据分组及其ACK都没有丢失。这样就可能在发送方与接收方的信道中引入<strong>冗余数据分组</strong>,好在，上面讲到的<strong>序号</strong>可以成功解决这一个问题。</p>
<p>从发送方的观点看，重传是一种万能灵药。<strong>发送方不知道是一个数据分组丢失，还是一个ACK丢失，或者只是该分组或ACK过度时延。在所有这些情况下，动作都是一样的:重传</strong>。为了实现基于时间的重传机制，我们需要一个<strong>倒计时定时器</strong>。</p>
<h2 id="接收顺序错乱"><a href="#接收顺序错乱" class="headerlink" title="接收顺序错乱"></a>接收顺序错乱</h2><p>经过上面的讨论，解决接收顺序错乱也就简单了，依然是<strong>序号</strong>，接收方有了每一个分组的需要，那么不发生数据错误和数据丢失就可以装配出完整的数据。</p>
<h1 id="序号和确认号的工作细节"><a href="#序号和确认号的工作细节" class="headerlink" title="序号和确认号的工作细节"></a>序号和确认号的工作细节</h1><p>在了解了可靠数据传输所采取的一般策略之后，我们就来仔细看看序号和确认号具体是怎样协同工作的。<strong>TCP报文段首部中两个最重要的字段就是序号字段和确认字段</strong>,这两个字段是TCP可靠传输服务的关键部分。</p>
<p>TCP把数据看做看成一个无结构的、有序的字节流。序号是建立在传送的字节流上，而不是建立在传送的报文段的序列之上。因此，<strong>一个报文段的序号是该报文段首字节的字节流编号</strong>。</p>
<p>假设主机A上的一个进程想通过一条TCP连接向主机B上的一个进程发送一个数据流。主机A中的TCP将隐式的对数据流中的每一个字节编号。假定数据流由一个包含500000字节的文件组成，其MSS为1000字节，数据流的首字节编号是0。如图所示，该TCP将为该数据流构建500个报文段，给第一个报文段分配序号0,第二个报文段分配序号1000,第三个报文段分配序号2000,以此类推。每一个序号被填入到相应TCP报文段首部的序号字段。</p>
<p><img src="/images/byte-stream.png" alt></p>
<p>确认号要比序号要难处理一些。<strong>主机A填充进报文段的确认号是主机A期望从主机B收到的下一个字节的序号</strong>。看一个例子有助于实际发生的事情。假设主机A已收到了来自主机B的编号为0–535的所有字节，同时假设它打算发送一个报文段给主机B。主机A等待主机B的数据流中字节536及之后的所有字节。所以主机A就会在它发往主机B的报文段的确认号字段中填上536.</p>
<!-- ![](/images/seq-ack.gif) -->

<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ul>
<li>数据在网络中传输会出现:比特错误、分组丢失、接收顺序错乱三种错误</li>
<li>序号是建立在传送的字节流上，而不是建立在传送的报文段的序列之上。因此，一个报文段的序号是该报文段首字节的字节流编号</li>
<li>主机A填充进报文段的确认号是主机A期望从主机B收到的下一个字节的序号</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2018/07/16/introduction-to-tcp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/16/introduction-to-tcp/" itemprop="url">TCP简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-16T17:57:07+08:00">
                2018-07-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index">
                    <span itemprop="name">Network</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一篇文章，我们讲了UDP。UDP最大的缺点就是无法提供可靠数据传输，这使得数据发送出去之后可能丢失。在一些对数据完整性要求十分严格的场景下，UDP就无用武之地了。而TCP就是用来解决数据完整传输这一问题的。</p>
<p><img src="/images/tcp.jpg" alt><br>－－图　泰国TCP Group(เกี่ยวกับ TCP),貌似是卖饮料的。</p>
<p>TCP是因特网传输层的<strong>面向连接</strong>的<strong>可靠数据传输</strong>。为了实现可靠数据传输，TCP使用了许多措施:<strong>差错检测、超时重传、累积确认、定时器以及用于序号和确认号的首部字段</strong>。</p>
<h1 id="可靠数据传输机制"><a href="#可靠数据传输机制" class="headerlink" title="可靠数据传输机制"></a>可靠数据传输机制</h1><table>
<thead>
<tr>
<th align="center">机制</th>
<th align="center">用途和说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">检验和</td>
<td align="center">用于监测在一个传输分组中的比特错误</td>
</tr>
<tr>
<td align="center">定时器</td>
<td align="center">用于超时/重传一个分组,可能因为该分组(或其ACK)在信道中丢失了.由于当一个分组延时但未丢失,或当一个分组已被接收方接收但从接收方到发送方的ACK丢失时,可能产生超时事件,所以接收方可能会收到一个分组的多个冗余副本.</td>
</tr>
<tr>
<td align="center">序号</td>
<td align="center">用于为从发送方流向接收方的数据分组按序号编号.所接受分组的序号的空隙可是的接收方检测除丢失的分组.具有相同序号的分组可使接收方检测出一个分组的冗余副本.</td>
</tr>
<tr>
<td align="center">确认</td>
<td align="center">接收方用于告诉发送方一个分组或一组分组已经被正确地接收到了.确认报文通常携带着被确认的分组或多个分组的序号.确认可以是逐个的或积累的,这取决于协议.</td>
</tr>
<tr>
<td align="center">否定确认</td>
<td align="center">收方用于告诉发送方某个分组未被正确的接收.否则人确定报文通常携带着未被正确接收的分组的序号.</td>
</tr>
<tr>
<td align="center">窗口、流水线</td>
<td align="center">发送方也许被限制仅发送那些序号落在一个指定范围内的分组.通过允许一次发送多个分组但未被确认,发送方的利用率可以在停等操作模式上得到增加.我们很快将会看到,窗口长度可根据接收方接收和缓存报文的能力/网络中的拥塞程度或两者的情况来进行设置.</td>
</tr>
</tbody></table>
<p>在这里，我首先给出TCP可靠数据传输所采取的机制，关于这些机制的原理我后面还会有陆续几篇文章介绍。</p>
<h1 id="TCP通信的过程"><a href="#TCP通信的过程" class="headerlink" title="TCP通信的过程"></a>TCP通信的过程</h1><p>TCP是面向连接的,这是因为在一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须先相互“握手”，即它们必须先相互发送某些预备报文段，以建立确保数据传输的参数。在握手的过程中，连接的双方都将初始化与TCP连接的许多TCP状态变量，例如<strong>初始化发送缓存和接收缓存，交换确定彼此的序号和确认号等</strong>。</p>
<p>一旦建立起一条TCP连接，两个应用进程之间就可以相互发送数据了。在介绍发送接收数据之前我们先介绍TCP连接的两个基本特点:</p>
<ul>
<li><strong>TCP连接提供的是全双工服务</strong><br>如果一台主机上的进程A与另一台主机上的进程B存在一条TCP连接，那么应用层数据可以在从进程B流向进程A的同时，也从进程A流向进程B。</li>
<li><strong>TCP连接是点对点的</strong><br>也即是TCP连接是单个发送方和单个接收方之间的连接。多播(在一次发送操作中，从一个发送方将数据传送给多个接收方)对于TCP来说是不可能的。</li>
</ul>
<p><img src="/images/io-buf.jpeg" alt></p>
<p>我们考虑一下从客户进程向服务进程发送数据的情况。客户端进程通过套接字(该进程之门)传递数据流。数据一旦通过该门，它就由客户端中运行的TCP控制了.TCP经这些数据引导到该链接的发送缓存里，发送缓存是在三次握手初期设置的设置的缓存之一。接下来TCP就会不时从发送缓存里取出一块数据。<strong>取出数据的大小受限于最大报文段长度</strong>(Maximum Segment Size,MSS)。然后，TCP会为每块应用层数据配上一个TCP首部，从而形成多个TCP报文段，这些报文段被下传到网络层，网络层将其封装在网络层的IP数据包中，然后这些IP数据报被发送到网络中。当TCP在另一端接收到一个报文段后，该报文段的数据就被放入该TCP连接的接收缓存，应用程序从此缓存中读取数据流。由于TCP提供的是全双工服务，所以<strong>TCP连接的每一端都有各自的发送缓存和接收缓存</strong>。</p>
<p>由上面的讨论我们可以看出，<strong>TCP连接的组成包括:一台主机上的缓存、变量和与进程连接的套接字，以及另一台主机上的另一组缓存、变量和与进程连接的套接字</strong>。两台主机之间的网络元素(路由器、交换机和中继器)没有为该TCP连接分配任何缓存与变量。</p>
<h1 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h1><p>为了便于后面介绍TCP可靠数据传输的实现，这里我们先介绍一下TCP报文段的结构:</p>
<p><img src="/images/tcp-segment-struct.JPG" alt></p>
<p><strong>TCP报文段由首部字段和一个数据字段组成</strong>。数据字段包含一块应用数据。如前所述，MSS限制报文段数据字段的最大长度。当TCP发送一个大文件时，通常是将该文件划分为长度为MSS的若干块(最后一块除外，它通常小于MSS).然而对于很多交互式应用来说，其TCP报文的数据字段通常很小。例如像Telnet这样的远程登录应用，其TCP报文段的数据字段经常只有一个字节，由于TCP的首部一般是20个字节(比UDP首部多12字节)，所以Telnet发送的报文段也许只有21字节。</p>
<p>如上图，TCP报文段由下列部分组成:</p>
<ul>
<li><p><strong>源端口号(source port)和目的端口号(dest port)</strong><br>被用来多路复用/分解来自或送到上层应用的数据。协助实现进程间的数据交付功能。</p>
</li>
<li><p><strong>检验和字段(checksum)</strong><br>同UDP一样，检验和字段也是用来检查报文中可能发生的比特错误。</p>
</li>
<li><p><strong>32比特的序号字段(sequence number)和32比特的确认号字段(acknowledgement number)</strong><br>这两个字段被TCP发送方和接收方用来实现可靠数据传输服务。</p>
</li>
<li><p><strong>16比特的接收窗口字段(receive window)</strong><br>该字段用来实现流量控制，即匹配发送方的发送速度与接收方的接收速度。</p>
</li>
<li><p><strong>4比特的首部长度字段</strong><br>该字段指示了以32比特的字为单位的TCP首部长度。由于TCP选项字段的原因，TCP首部字段的长度是可变的，所以发送方需要计算首部的长度，以方便接收方处理。</p>
</li>
<li><p><strong>可选与变长的选项字段(options,variable length)</strong><br>该字段用于发送方与接收方协商最大报文段长度时，或者在高速网络环境下用作窗口调节因子时使用</p>
</li>
<li><p><strong>6比特的标志字段(flag field)</strong><br>标志字段的6个比特分别为:URG、ACK、PSH、RST、SYN、FIN。ACK比特置为1，则表明这是一个确认报文，包含一个对已成功接收报文段的确认。RST、SYN、FIN用于连接的建立和拆除。当PSH比特设置为1,就指示接收方应立即将数据交给上层。URG比特用来指示报文段里存在着被发送端上层的实体置为紧急的数据，紧急数据的最后一个字节由16比特的<strong>应急数据指针</strong>指出。当紧急数据存在并给定指向紧急数据尾的指针的时候，TCP必须通知接收端的上层实体。(在实践中，PSH,URG和紧急数据指针并没有使用。为了讨论的完整性，这里才提到这些字段)</p>
</li>
</ul>
<p>了解TCP报文段的结构对于后面我们讨论TCP可靠数据传输来说至关重要。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ul>
<li>TCP是因特网传输层的面向连接的可靠数据传输。</li>
<li>TCP为了实现可靠数据传输，采用了:差错检测、超时重传、累积确认、定时器以及用于序号和确认号的首部字段等措施。</li>
<li>TCP连接提供的是全双工服务,点对点通信。“多播”对TCP协议来说是不可能的。</li>
<li>TCP在通信之前需要先握手，以初始化与TCP连接的许多TCP状态变量。这也是TCP称为面向连接的原因。</li>
<li>TCP连接的每一端都有各自的发送缓存和接收缓存。</li>
<li>TCP连接的组成包括:一台主机上的缓存、变量和与进程连接的套接字，以及另一台主机上的另一组缓存、变量和与进程连接的套接字。</li>
<li>TCP报文段由首部字段和一个数据字段组成，数据字段的大小受限于最大报文段长度(MSS)。</li>
<li>TCP报文由源端口号(source port)和目的端口号(dest port)、检验和字段(checksum)、32比特的序号字段(sequence number)和32比特的确认号字段(acknowledgement number)、16比特的接收窗口字段(receive window)、4比特的首部长度字段、可选与变长的选项字段(options,variable length)、6比特的标志字段(flag field)等部分组成。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2018/07/16/udp-and-its-features/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/16/udp-and-its-features/" itemprop="url">UDP协议及其功能</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-16T16:42:14+08:00">
                2018-07-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index">
                    <span itemprop="name">Network</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在上一篇文章中，我们讲了一些运输层的基本特点。这一篇文章中，我们就从具体的网络协议下手。在传输层常用的协议就是TCP(传输控制协议)和UDP(用户数据报协议),这一节我们先聊一聊比较简单的UDP协议。UDP是一个不提供不必要服务的最简化的运输层协议，<strong>它提供了两种最为基本的服务：进程到进程间的数据交付和差错检查。</strong></p>
<h1 id="UDP报文段结构"><a href="#UDP报文段结构" class="headerlink" title="UDP报文段结构"></a>UDP报文段结构</h1><p><img src="/images/udp-segment-struct.png" alt><br>UDP报文由上图中的五部分组成：<strong>源端口，目的端口，长度，检验和，应用数据</strong>。应用层数据占用了UDP报文段的数据字段，其他的四个部分则组成了UDP报文段的首部字段。UDP首部中的四个字段每一个占用两个字节(16 bit)。</p>
<ul>
<li>源端口号<br>传递源端口号有助于服务器端应用程序确定报文的来源。</li>
<li>目的端口号<br>传递目的端口号可以使目的主机将应用数据交付运行在目的端口的响应进程(即执行分解功能)。</li>
<li>长度<br>长度字段则指示了在UDP报文段中的字节数(首部加数据)，因为数据字段的长度在UDP报文段中不是固定的，为了便于接收端程序的处理，所以需要一个长度字段。</li>
<li>检验和<br>接收方使用检验和来检查该报文段中是否出现了差错。</li>
</ul>
<h1 id="差错检查的实现原理"><a href="#差错检查的实现原理" class="headerlink" title="差错检查的实现原理"></a>差错检查的实现原理</h1><p>UDP检验和提供了差错检测功能。这就是说，检验和用于确认当UDP报文段从源到目的地移动时，其中的比特是否发生了改变(这种改变可能是由于链路中的噪声干扰或者存储在路由器中引入问题引起的)。检验和的计算方法是这样的:发送方的UDP对报文段中的所有16比特字的和进行反码运算，求和遇到任何溢出都被回卷。得到的结果放在UDP报文段中的检验和字段。可以在[<a href="https://tools.ietf.org/html/rfc1071" target="_blank" rel="noopener">RFC 1071</a>]中找到有效实现的细节.</p>
<p><strong>虽然UDP提供了这种差错检测的机制，但是它对差错回复却无能为力。UDP的某种实现只是丢弃受损的报文段，其他的实现是将受损的报文段交给应用程序并且给出警告。</strong></p>
<h1 id="UDP应用场景"><a href="#UDP应用场景" class="headerlink" title="UDP应用场景"></a>UDP应用场景</h1><p>UDP不提供可靠数据传输，就没有三次握手这种消耗时间的建立连接的操作，也没有对包的各种检查以及状态维护操作。所以使用UDP作为传输层协议往往会更加快速，但也可能会出现丢失数据的情况。UDP也不提供拥塞控制,所以它没有传输速率限制。由于UDP协议传输时的特点，它还是有许多的应用场景。它主要适合与可以容忍少量数据丢失，低时延，需要快速传输大量数据的场景。如因特网电话、视频会议之类的实时应用以及流式多媒体的传输。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ul>
<li>UDP是无连接的</li>
<li>UDP只提供进程到进程间的数据交付和差错检查两种服务</li>
<li>UDP报文由源端口，目的端口，长度，检验和，应用数据五部分组成</li>
<li>UDP适合与可以容忍少量数据丢失，低时延，需要快速传输大量数据的场景</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2018/07/16/transport-layer-udp-and-tcp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/16/transport-layer-udp-and-tcp/" itemprop="url">聊聊计算机网络传输层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-16T15:01:45+08:00">
                2018-07-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index">
                    <span itemprop="name">Network</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/images/cs-network-layers.jpg" alt><br>如上图，计算机网络在TCP/IP概念模型中被分为4层，传输层位于应用层和网络层之间，它是分层的网络体系结构的重要组成部分。<strong>该层为运行在不同主机上的应用进程提供直接通信</strong>起着至关重要的作用。这篇文章，就聊一聊传输层。</p>
<p>在协议栈中，传输层位于网络层之上。<strong>网络层提供了主机之间的逻辑通信，而传输层为不同主机上的进程之间提供了逻辑通信。</strong>理解传输层与网络层的这种本质差别对理解传输层提供的服务至关重要。下面我们举一个类比的例子，来说明。</p>
<h1 id="一个类比例子"><a href="#一个类比例子" class="headerlink" title="一个类比例子"></a>一个类比例子</h1><blockquote>
<p>考虑有两个家庭，一家位于美国东海岸，一家位于美国西海岸，每家有12个孩子。东海岸的孩子们是西海岸家庭孩子们的堂兄弟姐妹。这两个家庭的孩子们喜欢彼此通信，每个人每周要给每个堂兄弟姐妹写一封信，每封信都用单独的信封通过传统的邮政服务发送。因此，每个家庭每周向另一家庭发送144封信。（如果他们有电子邮件的话，这些孩子可以省不少钱！）每个家庭有一个孩子负责收发邮件，西海岸家庭是Ann而东海岸家庭是Bill。每周Ann去她所有的兄弟姐妹那里收集邮件，并将这些邮件交到每天到家门口的邮政运输车上。当信件到达西海岸家庭时，Ann也负责将信件发到她的兄弟姐妹手上，东海岸家庭中Bill也负责类似工作。</p>
</blockquote>
<p>－－ 例子来源于《<a href="https://book.douban.com/subject/26176870/" target="_blank" rel="noopener">计算机网络－自顶向下的方法</a>》</p>
<p>我们可以做下面这样的类比:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">应用层报文　　＝　信封上的字符</span><br><span class="line">进程　　　　　＝　堂兄弟姐妹</span><br><span class="line">主机(端系统)　＝　家庭</span><br><span class="line">运输层协议　　＝　Ann和Bill</span><br><span class="line">网络层协议　　＝　邮政服务</span><br></pre></td></tr></table></figure>

<p>在这个例子中，网络层就像邮递员，而运输层就像Ann和Bill。现在我们再来理解上面的这句话:<strong>网络层提供了主机之间的逻辑通信，而传输层为不同主机上的进程之间提供了逻辑通信。</strong>邮政服务知识将信件送到指定的家庭，它不会将信件分发到家庭的具体成员手中。这个分发的工作则是由Ann和Bill提供的。值得注意的是Ann和Bill都是在各自的家里进行工作的，他们没有参与任何中间邮件中心对邮件进行分拣的工作，也没有将邮件从一个邮件中心送到另一个邮件中心。相应的，<strong>运输层协议只工作在端系统中</strong>。在端系统中，运输层协议将来自应用进程的的报文移动到网络边缘(即网络层)，但对有关这些报文在网络层中如何移动却不做任何规定。<br>由这个例子，我们可以做出如下概括:<strong>网络层提供了不同端系统的数据交付服务，而传输层则将这种不同主机间的交付拓展为了运行在不同端系统上的两个进程之间的交付。</strong>进程到进程之间的数据交付是传输层提供的最基本的服务之一。</p>
<h1 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h1><p>传输层的这种进程间的数据交付是怎样实现的呢?众所周知，一个网络应用程序有一个或多个套接字(Socket),它相当于是从网络向进程传递数据和从进程向网络传递数据的门户。在接收端，传输层实际上并没有将数据交付给进程，而是将数据交给了一个中间套接字。由于在任一时刻，在接收主机上可能不止一个套接字，所以每个套接字都有唯一的标识符。</p>
<p>现在我们考虑接收主机怎样将一个到达的运输层报文段定向到适当的套接字。为此目的每个运输层报文段中具有几个字段。在接收端，运输层检查这些字段，标识出接收套接字，进而将报文段定向到该套接字。将运输层报文段中的数据交付到正确的套接字的工作称为<strong>多路分解</strong>。在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息(这将在以后用于分解)从而生成报文段，然后将这些报文段传递到网络，所有这些工作被称为<strong>多路复用</strong>。联系上面的例子，Ann收集家庭成员的信件，并交到每天到家门口的邮政运输车上就是多路复用；而Ann分发收到的邮件给各个兄弟姐妹的过程则为多路分解。</p>
<h1 id="传输层提供的其他服务"><a href="#传输层提供的其他服务" class="headerlink" title="传输层提供的其他服务"></a>传输层提供的其他服务</h1><p>上面讲到了传输层通过多路复用和多路分解将不同主机间的交付拓展为了运行在不同端系统上的两个进程之间的交付。进程到进程之间的数据交付是传输层提供的最基本的服务之一。除此之外传输层还提供了许多其它的服务。下面进行列举:</p>
<ul>
<li>进程间的数据交付(TCP,UDP)</li>
<li>完整性检查(TCP,UDP)</li>
<li>可靠数据传输(TCP)</li>
<li>拥塞控制(TCP)</li>
</ul>
<p>这里先列举出来，置于这些服务究竟是怎么实现的，请关注后续文章。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>1.运输层拓展了网络层的主机到主机的数据交付，提供了进程之间的数据交付。<br>2.运输层只运行在端系统中。<br>3.进程间的数据交付只是传输层最基本的功能之一，传输层还可以提供很多其他的功能。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2018/07/15/http2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/15/http2/" itemprop="url">HTTP常用首部字段</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-15T23:10:58+08:00">
                2018-07-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index">
                    <span itemprop="name">Network</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在上一篇文章<a href="https://andrewpqc.github.io/2018/07/15/http1/#more">HTTP协议总结</a>中讲到了HTTP报文结构，无论是请求报文还是响应报文中都有首部。在HTTP报文众多的字段当中，HTTP首部字段包含的信息最为丰富。首部字段同时存在于请求和响应报文内，并涵盖HTTP报文相关的内容信息。使用首部字段是为了给客服端和服务器端提供报文主体大小、所使用的语言、认证信息等内容。下面我们就总结一下在HTTP请求和响应中常用的首部字段。</p>
<h1 id="首部字段的结构和分类"><a href="#首部字段的结构和分类" class="headerlink" title="首部字段的结构和分类"></a>首部字段的结构和分类</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li>HTTP首部字段是由首部字段名和字段值构成的，中间用冒号”:”分隔。   </li>
<li>另外，字段值对应单个 HTTP 首部字段可以有多个值。</li>
<li>当HTTP 报文首部中出现了两个或以上具有相同首部字段名的首部字段时，这种情况在规范内尚未明确，根据浏览器内部处理逻辑的不同，优先处理的顺序可能不同，结果可能并不一致。</li>
</ul>
<p>如下是两个首部字段的例子:</p>
<table>
<thead>
<tr>
<th align="center">首部字段名</th>
<th align="center">冒号</th>
<th align="center">字段值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Content-Type</td>
<td align="center">:</td>
<td align="center">text/html</td>
</tr>
<tr>
<td align="center">Keep-Alive</td>
<td align="center">:</td>
<td align="center">timeout=30, max=120</td>
</tr>
</tbody></table>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>首部字段根据实际用途被分为以下4种类型：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">通用首部字段</td>
<td align="center">请求报文和响应报文两方都会使用的首部</td>
</tr>
<tr>
<td align="center">请求首部字段</td>
<td align="center">从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息</td>
</tr>
<tr>
<td align="center">响应首部字段</td>
<td align="center">从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</td>
</tr>
<tr>
<td align="center">实体首部字段</td>
<td align="center">针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的的信息。</td>
</tr>
</tbody></table>
<p>下面我按照这四种类型详细的总结一下。</p>
<h1 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h1><table>
<thead>
<tr>
<th align="center">首部字段名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Cache-Control</td>
<td align="center">控制缓存的行为</td>
</tr>
<tr>
<td align="center">Connection</td>
<td align="center">逐挑首部、连接的管理</td>
</tr>
<tr>
<td align="center">Date</td>
<td align="center">创建报文的日期时间</td>
</tr>
<tr>
<td align="center">Pragma</td>
<td align="center">报文指令</td>
</tr>
<tr>
<td align="center">Trailer</td>
<td align="center">报文末端的首部一览</td>
</tr>
<tr>
<td align="center">Transfer-Encoding</td>
<td align="center">指定报文主体的传输编码方式</td>
</tr>
<tr>
<td align="center">Upgrade</td>
<td align="center">升级为其他协议</td>
</tr>
<tr>
<td align="center">Via</td>
<td align="center">代理服务器的相关信息</td>
</tr>
<tr>
<td align="center">Warning</td>
<td align="center">错误通知</td>
</tr>
</tbody></table>
<h2 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h2><p>通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。</p>
<h3 id="可用的指令一览"><a href="#可用的指令一览" class="headerlink" title="可用的指令一览"></a>可用的指令一览</h3><p>可用的指令按请求和响应分类如下：</p>
<h4 id="缓存请求指令"><a href="#缓存请求指令" class="headerlink" title="缓存请求指令"></a>缓存请求指令</h4><table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">参数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">no-cache</td>
<td align="center">无</td>
<td align="center">强制向服务器再次验证</td>
</tr>
<tr>
<td align="center">no-store</td>
<td align="center">无</td>
<td align="center">不缓存请求或响应的任何内容</td>
</tr>
<tr>
<td align="center">max-age = [秒]</td>
<td align="center">必需</td>
<td align="center">响应的最大Age值</td>
</tr>
<tr>
<td align="center">max-stale( =[秒])</td>
<td align="center">可省略</td>
<td align="center">接收已过期的响应</td>
</tr>
<tr>
<td align="center">min-fresh = [秒]</td>
<td align="center">必需</td>
<td align="center">期望在指定时间内的响应仍有效</td>
</tr>
<tr>
<td align="center">no-transform</td>
<td align="center">无</td>
<td align="center">代理不可更改媒体类型</td>
</tr>
<tr>
<td align="center">only-if-cached</td>
<td align="center">无</td>
<td align="center">从缓存获取资源</td>
</tr>
<tr>
<td align="center">cache-extension</td>
<td align="center">-</td>
<td align="center">新指令标记（token）</td>
</tr>
<tr>
<td align="center">#### 缓存响应指令</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">参数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center">无</td>
<td align="center">可向任意方提供响应的缓存</td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">可省略</td>
<td align="center">仅向特定用户返回响应</td>
</tr>
<tr>
<td align="center">no-cache</td>
<td align="center">可省略</td>
<td align="center">缓存前必须先确认其有效性</td>
</tr>
<tr>
<td align="center">no-store</td>
<td align="center">无</td>
<td align="center">不缓存请求或响应的任何内容</td>
</tr>
<tr>
<td align="center">no-transform</td>
<td align="center">无</td>
<td align="center">代理不可更改媒体类型</td>
</tr>
<tr>
<td align="center">must-revalidate</td>
<td align="center">无</td>
<td align="center">可缓存但必须再向源服务器进行确认</td>
</tr>
<tr>
<td align="center">proxy-revalidate</td>
<td align="center">无</td>
<td align="center">要求中间缓存服务器对缓存的响应有效性再进行确认</td>
</tr>
<tr>
<td align="center">max-age = [秒]</td>
<td align="center">必需</td>
<td align="center">响应的最大Age值</td>
</tr>
<tr>
<td align="center">s-maxage = [秒]</td>
<td align="center">必需</td>
<td align="center">公共缓存服务器响应的最大Age值</td>
</tr>
<tr>
<td align="center">cache-extension</td>
<td align="center">-</td>
<td align="center">新指令标记（token）</td>
</tr>
</tbody></table>
<h3 id="表示能否缓存的指令"><a href="#表示能否缓存的指令" class="headerlink" title="表示能否缓存的指令"></a>表示能否缓存的指令</h3><ul>
<li>public 指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: public</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>当指定使用 public 指令时，则明确表明其他用户也可利用缓存。</p>
<ul>
<li>private 指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: private</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>当指定 private 指令后，响应只以特定的用户作为对象，这与 public 指令的行为相反。缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送过来的请求，代理服务器则不会返回缓存。</p>
<ul>
<li>no-cache 指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>使用 no-cache 指令是为了防止从缓存中返回过期的资源。<br>客户端发送的请求中如果包含 no-cache 指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。<br>如果服务器中返回的响应包含 no-cache 指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。<br>Cache-Control: no-cache=Location<br>由服务器返回的响应中，若报文首部字段 Cache-Control 中对 no-cache 字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存。换言之，无参数值的首部字段可以使用缓存。只能在响应指令中指定该参数。</p>
<ul>
<li>no-store 指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-store</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>当使用 no-store 指令时，暗示请求（和对应的响应）或响应中包含机密信息。因此，该指令规定缓存不能在本地存储请求或响应的任一部分。<br>注意：no-cache 指令代表不缓存过期的指令，缓存会向源服务器进行有效期确认后处理资源；no-store 指令才是真正的不进行缓存。</p>
<h3 id="指定缓存期限和认证的指令"><a href="#指定缓存期限和认证的指令" class="headerlink" title="指定缓存期限和认证的指令"></a>指定缓存期限和认证的指令</h3><ul>
<li>s-maxage 指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: s-maxage=604800（单位：秒）</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器（一般指代理）。也就是说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。<br>另外，当使用 s-maxage 指令后，则直接忽略对 Expires 首部字段及 max-age 指令的处理。</p>
<ul>
<li>max-age 指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=604800（单位：秒）</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定的时间更小，那么客户端就接收缓存的资源。另外，当指定 max-age 的值为0，那么缓存服务器通常需要将请求转发给源服务器。<br>当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间。<br>应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，并忽略掉 Expires 首部字段；而 HTTP/1.0 版本的缓存服务器则相反。</p>
<ul>
<li>min-fresh 指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: min-fresh=60（单位：秒）</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。</p>
<ul>
<li>max-stale 指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-stale=3600（单位：秒）</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>使用 max-stale 可指示缓存资源，即使过期也照常接收。<br>如果指令未指定参数值，那么无论经过多久，客户端都会接收响应；如果指定了具体参数值，那么即使过期，只要仍处于 max-stale 指定的时间内，仍旧会被客户端接收。</p>
<ul>
<li>only-if-cached 指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: only-if-cached</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源的有效性。</p>
<ul>
<li>must-revalidate 指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: must-revalidate</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍有效。另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令。</p>
<ul>
<li>proxy-revalidate 指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: proxy-revalidate</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。</p>
<ul>
<li>no-transform 指令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-transform</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。这样做可防止缓存或代理压缩图片等类似操作。</p>
<h3 id="Cache-Control-扩展"><a href="#Cache-Control-扩展" class="headerlink" title="Cache-Control 扩展"></a>Cache-Control 扩展</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: private, community=&quot;UCI&quot;</span><br></pre></td></tr></table></figure>

<p>通过 cache-extension 标记（token），可以扩展 Cache-Control 首部字段内的指令。上述 community 指令即扩展的指令，如果缓存服务器不能理解这个新指令，就会直接忽略掉。</p>
<h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><p>Connection 首部字段具备以下两个作用：</p>
<ul>
<li>控制不再转发的首部字段<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>在客户端发送请求和服务器返回响应中，使用 Connection 首部字段，可控制不再转发给代理的首部字段，即删除后再转发（即Hop-by-hop首部）。</p>
<ul>
<li>管理持久连接<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>HTTP/1.1 版本的默认连接都是持久连接。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 close。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure>

<p>HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。</p>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>表明创建 HTTP 报文的日期和时间。<br>Date: Mon, 10 Jul 2017 15:50:06 GMT<br>HTTP/1.1 协议使用在 RFC1123 中规定的日期时间的格式。</p>
<h2 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h2><p>Pragma 首部字段是 HTTP/1.1 版本之前的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pragma: no-cache</span><br></pre></td></tr></table></figure>

<p>该首部字段属于通用首部字段，但只用在客户端发送的请求中，要求所有的中间服务器不返回缓存的资源。<br>所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 Cache-Control: no-cache 指定缓存的处理方式最为理想。但是要整体掌握所有中间服务器使用的 HTTP 协议版本却是不现实的，所以，发送的请求会同时包含下面两个首部字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br><span class="line">Pragma: no-cache</span><br></pre></td></tr></table></figure>

<h2 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Trailer: Expires</span><br></pre></td></tr></table></figure>

<p>首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。可应用在 HTTP/1.1 版本分块传输编码时。</p>
<h2 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure>

<p>规定了传输报文主体时采用的编码方式。<br>HTTP/1.1 的传输编码方式仅对分块传输编码有效。</p>
<h2 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Upgrade: TSL/1.0</span><br></pre></td></tr></table></figure>

<p>用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。</p>
<h2 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Via: 1.1 a1.sample.com(Squid/2.7)</span><br></pre></td></tr></table></figure>

<p>为了追踪客户端和服务器端之间的请求和响应报文的传输路径。<br>报文经过代理或网关时，会现在首部字段 Via 中附加该服务器的信息，然后再进行转发。<br>首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。</p>
<h2 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h2><p>该首部字段通常会告知用户一些与缓存相关的问题的警告。<br>Warning 首部字段的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning：[警告码][警告的主机:端口号] &quot;[警告内容]&quot;([日期时间])</span><br></pre></td></tr></table></figure>

<p>最后的日期时间可省略。<br>HTTP/1.1 中定义了7种警告，警告码对应的警告内容仅推荐参考，另外，警告码具备扩展性，今后有可能追加新的警告码。</p>
<table>
<thead>
<tr>
<th align="center">警告码</th>
<th align="center">警告内容</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">110</td>
<td align="center">Response is stale(响应已过期)</td>
<td align="center">代理返回已过期的资源</td>
</tr>
<tr>
<td align="center">111</td>
<td align="center">Revalidation failed(再验证失败)</td>
<td align="center">代理再验证资源有效性时失败（服务器无法到达等原因）</td>
</tr>
<tr>
<td align="center">112</td>
<td align="center">Disconnection operation(断开连接操作)</td>
<td align="center">代理与互联网连接被故意切断</td>
</tr>
<tr>
<td align="center">113</td>
<td align="center">Heuristic expiration(试探性过期)</td>
<td align="center">响应的试用期超过24小时(有效缓存的设定时间大于24小时的情况下)</td>
</tr>
<tr>
<td align="center">199</td>
<td align="center">Miscellaneous warning(杂项警告)</td>
<td align="center">任意的警告内容</td>
</tr>
<tr>
<td align="center">214</td>
<td align="center">Transformation applied(使用了转换)</td>
<td align="center">代理对内容编码或媒体类型等执行了某些处理时</td>
</tr>
<tr>
<td align="center">299</td>
<td align="center">Miscellaneous persistent warning(持久杂项警告)</td>
<td align="center">任意的警告内容</td>
</tr>
</tbody></table>
<h1 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h1><table>
<thead>
<tr>
<th align="center">首部字段名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Accept</td>
<td align="center">用户代理可处理的媒体类型</td>
</tr>
<tr>
<td align="center">Accept-Charset</td>
<td align="center">优先的字符集</td>
</tr>
<tr>
<td align="center">Accept-Encoding</td>
<td align="center">优先的内容编码</td>
</tr>
<tr>
<td align="center">Accept-Language</td>
<td align="center">优先的语言（自然语言）</td>
</tr>
<tr>
<td align="center">Authorization</td>
<td align="center">Web认证信息</td>
</tr>
<tr>
<td align="center">Expect</td>
<td align="center">期待服务器的特定行为</td>
</tr>
<tr>
<td align="center">From</td>
<td align="center">用户的电子邮箱地址</td>
</tr>
<tr>
<td align="center">Host</td>
<td align="center">请求资源所在服务器</td>
</tr>
<tr>
<td align="center">If-Match</td>
<td align="center">比较实体标记（ETag）</td>
</tr>
<tr>
<td align="center">If-Modified-Since</td>
<td align="center">比较资源的更新时间</td>
</tr>
<tr>
<td align="center">If-None-Match</td>
<td align="center">比较实体标记（与 If-Macth 相反）</td>
</tr>
<tr>
<td align="center">If-Range</td>
<td align="center">资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td align="center">If-Unmodified-Since</td>
<td align="center">比较资源的更新时间(与 If-Modified-Since 相反)</td>
</tr>
<tr>
<td align="center">Max-Forwards</td>
<td align="center">最大传输逐跳数</td>
</tr>
<tr>
<td align="center">Proxy-Authorization</td>
<td align="center">代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td align="center">Range</td>
<td align="center">实体的字节范围请求</td>
</tr>
<tr>
<td align="center">Referer</td>
<td align="center">对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td align="center">TE</td>
<td align="center">传输编码的优先级</td>
</tr>
<tr>
<td align="center">User-Agent</td>
<td align="center">HTTP 客户端程序的信息</td>
</tr>
<tr>
<td align="center">## Accept</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html, application/xhtml+xml, application/xml; q=0.5</span><br></pre></td></tr></table></figure></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。<br>若想要给显示的媒体类型增加优先级，则使用 q=[数值] 来表示权重值，用分号（;）进行分隔。权重值的范围 0~1（可精确到小数点后三位），且 1 为最大值。不指定权重值时，默认为 1。</p>
<h2 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Charset: iso-8859-5, unicode-1-1; q=0.8</span><br></pre></td></tr></table></figure>

<p>Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。同样使用 q=[数值] 来表示相对优先级。</p>
<h2 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure>

<p>Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先顺序，并可一次性指定多种内容编码。同样使用 q=[数值] 来表示相对优先级。也可使用星号（*）作为通配符，指定任意的编码格式。</p>
<h2 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Lanuage: zh-cn,zh;q=0.7,en=us,en;q=0.3</span><br></pre></td></tr></table></figure>

<p>告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级，可一次性指定多种自然语言集。同样使用 q=[数值] 来表示相对优先级。</p>
<h2 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Basic ldfKDHKfkDdasSAEdasd==</span><br></pre></td></tr></table></figure>

<p>告知服务器用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异。</p>
<h2 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expect: 100-continue</span><br></pre></td></tr></table></figure>

<p>告知服务器客户端期望出现的某种特定行为。</p>
<h2 id="From"><a href="#From" class="headerlink" title="From"></a>From</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">From: Deeson_Woo@163.com</span><br></pre></td></tr></table></figure>

<p>告知服务器使用用户代理的电子邮件地址。</p>
<h2 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: andrewpqc.xyz</span><br></pre></td></tr></table></figure>

<p>告知服务器，请求的资源所处的互联网主机和端口号。<br>Host 首部字段是 HTTP/1.1 规范内唯一一个必须被包含在请求内的首部字段。<br>若服务器未设定主机名，那直接发送一个空值即可  Host: 。</p>
<h2 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h2><p>形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Match: &quot;123456&quot;</span><br></pre></td></tr></table></figure>

<p>首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用的实体标记（ETag）值。这时的服务器无法使用弱 ETag 值。<br>服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响应。<br>还可以使用星号（*）指定 If-Match 的字段值。针对这种情况，服务器将会忽略 ETag 的值，只要资源存在就处理请求。</p>
<h2 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Mon, 10 Jul 2017 15:50:06 GMT</span><br></pre></td></tr></table></figure>

<p>首部字段 If-Modified-Since，属附带条件之一，用于确认代理或客户端拥有的本地资源的有效性。<br>它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应。</p>
<h2 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match: &quot;123456&quot;</span><br></pre></td></tr></table></figure>

<p>首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match 作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求。</p>
<h2 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Range: &quot;123456&quot;</span><br></pre></td></tr></table></figure>

<p>首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。<br>下面我们思考一下不使用首部字段 If-Range 发送请求的情况。服务器端的资源如果更新，那客户端持有资源中的一部分也会随之无效，当然，范围请求作为前提是无效的。这时，服务器会暂且以状态码 412 Precondition Failed 作为响应返回，其目的是催促客户端再次发送请求。这样一来，与使用首部字段 If-Range 比起来，就需要花费两倍的功夫。</p>
<h2 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Unmodified-Since: Mon, 10 Jul 2017 15:50:06 GMT</span><br></pre></td></tr></table></figure>

<p>首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。</p>
<h2 id="Max-Forwards"><a href="#Max-Forwards" class="headerlink" title="Max-Forwards"></a>Max-Forwards</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Max-Forwards: 10</span><br></pre></td></tr></table></figure>

<p>通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应。</p>
<h2 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a>Proxy-Authorization</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy-Authorization: Basic dGlwOjkpNLAGfFY5</span><br></pre></td></tr></table></figure>

<p>接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。<br>这个行为是与客户端和服务器之间的 HTTP 访问认证相类似的，不同之处在于，认证行为发生在客户端与代理之间。</p>
<h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes=5001-10000</span><br></pre></td></tr></table></figure>

<p>对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。<br>接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 206 Partial Content 的响应。无法处理该范围请求时，则会返回状态码 200 OK 的响应及全部资源。</p>
<h2 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Referer: http://www.sample.com/index.html</span><br></pre></td></tr></table></figure>

<p>首部字段 Referer 会告知服务器请求的原始资源的 URI。</p>
<h2 id="TE"><a href="#TE" class="headerlink" title="TE"></a>TE</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TE: gzip, deflate; q=0.5</span><br></pre></td></tr></table></figure>

<p>首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。<br>首部字段 TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分块传输编码的方式。应用后者时，只需把 trailers 赋值给该字段值。TE: trailers</p>
<h2 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101</span><br></pre></td></tr></table></figure>

<p>首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。<br>由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。</p>
<h1 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h1><table>
<thead>
<tr>
<th align="center">首部字段名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Accept-Ranges</td>
<td align="center">是否接受字节范围请求</td>
</tr>
<tr>
<td align="center">Age</td>
<td align="center">推算资源创建经过时间</td>
</tr>
<tr>
<td align="center">ETag</td>
<td align="center">资源的匹配信息</td>
</tr>
<tr>
<td align="center">Location</td>
<td align="center">令客户端重定向至指定 URI</td>
</tr>
<tr>
<td align="center">Proxy-Authenticate</td>
<td align="center">代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td align="center">Retry-After</td>
<td align="center">对再次发起请求的时机要求</td>
</tr>
<tr>
<td align="center">Server</td>
<td align="center">HTTP 服务器的安装信息</td>
</tr>
<tr>
<td align="center">Vary</td>
<td align="center">代理服务器缓存的管理信息</td>
</tr>
<tr>
<td align="center">WWW-Authenticate</td>
<td align="center">服务器对客户端的认证信息</td>
</tr>
<tr>
<td align="center">## Accept-Ranges</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。<br>可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none。</p>
<h2 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Age: 1200</span><br></pre></td></tr></table></figure>

<p>首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。<br>若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段 Age。</p>
<h2 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: &quot;usagi-1234&quot;</span><br></pre></td></tr></table></figure>

<p>首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。<br>另外，当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配。<br>ETag 中有强 ETag 值和弱 ETag 值之分。强 ETag 值，不论实体发生多么细微的变化都会改变其值；弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/： ETag: W/“usagi-1234”。</p>
<h2 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Location: http://www.sample.com/sample.html</span><br></pre></td></tr></table></figure>

<p>使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。<br>基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的 URI。<br>几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问。</p>
<h2 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy-Authenticate: Basic realm=&quot;Usagidesign Auth&quot;</span><br></pre></td></tr></table></figure>

<p>首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。<br>它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在于其认证行为是在客户端与代理之间进行的。</p>
<h2 id="Retry-After"><a href="#Retry-After" class="headerlink" title="Retry-After"></a>Retry-After</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Retry-After: 180</span><br></pre></td></tr></table></figure>

<p>首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。<br>字段值可以指定为具体的日期时间（Mon, 10 Jul 2017 15:50:06 GMT 等格式），也可以是创建响应后的秒数。</p>
<h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server: Apache/2.2.6 (Unix) PHP/5.2.5</span><br></pre></td></tr></table></figure>

<p>首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。</p>
<h2 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vary: Accept-Language</span><br></pre></td></tr></table></figure>

<p>首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。<br>从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相同，因此必须要从源服务器重新获取资源。</p>
<h2 id="WWW-Authenticate"><a href="#WWW-Authenticate" class="headerlink" title="WWW-Authenticate"></a>WWW-Authenticate</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WWW-Authenticate: Basic realm=&quot;Usagidesign Auth&quot;</span><br></pre></td></tr></table></figure>

<p>首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。</p>
<h1 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h1><table>
<thead>
<tr>
<th align="center">首部字段名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Allow</td>
<td align="center">资源可支持的 HTTP 方法</td>
</tr>
<tr>
<td align="center">Content-Encoding</td>
<td align="center">实体主体适用的编码方式</td>
</tr>
<tr>
<td align="center">Content-Language</td>
<td align="center">实体主体的自然语言</td>
</tr>
<tr>
<td align="center">Content-Length</td>
<td align="center">实体主体的大小（单位：字节）</td>
</tr>
<tr>
<td align="center">Content-Location</td>
<td align="center">替代对应资源的 URI</td>
</tr>
<tr>
<td align="center">Content-MD5</td>
<td align="center">实体主体的报文摘要</td>
</tr>
<tr>
<td align="center">Content-Range</td>
<td align="center">实体主体的位置范围</td>
</tr>
<tr>
<td align="center">Content-Type</td>
<td align="center">实体主体的媒体类型</td>
</tr>
<tr>
<td align="center">Expires</td>
<td align="center">实体主体过期的日期时间</td>
</tr>
<tr>
<td align="center">Last-Modified</td>
<td align="center">资源的最后修改日期时间</td>
</tr>
<tr>
<td align="center">## Allow</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Allow: GET, HEAD</span><br></pre></td></tr></table></figure></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。<br>当服务器接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。</p>
<h2 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure>

<p>首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。<br>主要采用这 4 种内容编码的方式（gzip、compress、deflate、identity）。</p>
<h2 id="Content-Language"><a href="#Content-Language" class="headerlink" title="Content-Language"></a>Content-Language</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Language: zh-CN</span><br></pre></td></tr></table></figure>

<p>首部字段 Content-Language 会告知客户端，实体主体使用的自然语言（指中文或英文等语言）。</p>
<h2 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: 15000</span><br></pre></td></tr></table></figure>

<p>首部字段 Content-Length 表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用 Content-Length首部字段。</p>
<h2 id="Content-Location"><a href="#Content-Location" class="headerlink" title="Content-Location"></a>Content-Location</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Location: http://www.sample.com/index.html</span><br></pre></td></tr></table></figure>

<p>首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。</p>
<h2 id="Content-MD5"><a href="#Content-MD5" class="headerlink" title="Content-MD5"></a>Content-MD5</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-MD5: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==</span><br></pre></td></tr></table></figure>

<p>首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。</p>
<h2 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Range: bytes 5001-10000/10000</span><br></pre></td></tr></table></figure>

<p>针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。</p>
<h2 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure>

<p>首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。参数 charset 使用 iso-8859-1 或 euc-jp 等字符集进行赋值。</p>
<h2 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Mon, 10 Jul 2017 15:50:06 GMT</span><br></pre></td></tr></table></figure>

<p>首部字段 Expires 会将资源失效的日期告知客户端。<br>缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。<br>源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写入与首部字段 Date 相同的时间值。</p>
<h2 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: Mon, 10 Jul 2017 15:50:06 GMT</span><br></pre></td></tr></table></figure>

<p>首部字段 Last-Modified 指明资源最终修改的时间。一般来说，这个值就是 Request-URI 指定资源被修改的时间。但类似使用 CGI 脚本进行动态数据处理时，该值有可能会变成数据最终修改时的时间。</p>
<h1 id="为-Cookie-服务的首部字段"><a href="#为-Cookie-服务的首部字段" class="headerlink" title="为 Cookie 服务的首部字段"></a>为 Cookie 服务的首部字段</h1><table>
<thead>
<tr>
<th align="center">首部字段名</th>
<th align="center">说明</th>
<th align="center">首部类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Set-Cookie</td>
<td align="center">开始状态管理所使用的 Cookie 信息</td>
<td align="center">响应首部字段</td>
</tr>
<tr>
<td align="center">Cookie</td>
<td align="center">服务器接收到的 Cookie 信息</td>
<td align="center">请求首部字段</td>
</tr>
<tr>
<td align="center">## Set-Cookie</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: status=enable; expires=Mon, 10 Jul 2017 15:50:06 GMT; path=/;</span><br></pre></td></tr></table></figure></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>下面的表格列举了 Set-Cookie 的字段值。</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NAME=VALUE</td>
<td align="center">赋予 Cookie 的名称和其值（必需项）</td>
</tr>
<tr>
<td align="center">expires=DATE</td>
<td align="center">Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）</td>
</tr>
<tr>
<td align="center">path=PATH</td>
<td align="center">将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）</td>
</tr>
<tr>
<td align="center">domain=域名</td>
<td align="center">作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie的服务器的域名）</td>
</tr>
<tr>
<td align="center">Secure</td>
<td align="center">仅在 HTTPS 安全通信时才会发送 Cookie</td>
</tr>
<tr>
<td align="center">HttpOnly</td>
<td align="center">加以限制，使 Cookie 不能被 JavaScript 脚本访问</td>
</tr>
</tbody></table>
<h3 id="expires-属性"><a href="#expires-属性" class="headerlink" title="expires 属性"></a>expires 属性</h3><p>Cookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。<br>当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session）时间段内。这通常限于浏览器应用程序被关闭之前。<br>另外，一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可以显式删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作。</p>
<h3 id="path-属性"><a href="#path-属性" class="headerlink" title="path 属性"></a>path 属性</h3><p>Cookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。</p>
<h3 id="domain-属性"><a href="#domain-属性" class="headerlink" title="domain 属性"></a>domain 属性</h3><p>通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。比如，当指定 example.com 后，除example.com 以外，<a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 或 www2.example.com 等都可以发送 Cookie。<br>因此，除了针对具体指定的多个域名发送 Cookie 之 外，不指定 domain 属性显得更安全。<br>8.1.4 secure 属性<br>Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。</p>
<h3 id="HttpOnly-属性"><a href="#HttpOnly-属性" class="headerlink" title="HttpOnly 属性"></a>HttpOnly 属性</h3><p>Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting，XSS）对 Cookie 的信息窃取。<br>通过上述设置，通常从 Web 页面内还可以对 Cookie 进行读取操作。但使用 JavaScript 的 document.cookie 就无法读取附加 HttpOnly 属性后的 Cookie 的内容了。因此，也就无法在 XSS 中利用 JavaScript 劫持 Cookie 了。</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: status=enable</span><br></pre></td></tr></table></figure>

<p>首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。</p>
<h1 id="其他首部字段"><a href="#其他首部字段" class="headerlink" title="其他首部字段"></a>其他首部字段</h1><p>HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。<br>以下是最为常用的首部字段。</p>
<h2 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Frame-Options: DENY</span><br></pre></td></tr></table></figure>

<p>首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。首部字段 X-Frame-Options 有以下两个可指定的字段值：</p>
<p>DENY：拒绝<br>SAMEORIGIN：仅同源域名下的页面（Top-level-browsing-context）匹配时许可。（比如，当指定 <a href="http://sample.com/sample.html" target="_blank" rel="noopener">http://sample.com/sample.html</a> 页面为 SAMEORIGIN 时，那么 sample.com 上所有页面的 frame 都被允许可加载该页面，而 example.com 等其他域名的页面就不行了）</p>
<h2 id="X-XSS-Protection"><a href="#X-XSS-Protection" class="headerlink" title="X-XSS-Protection"></a>X-XSS-Protection</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-XSS-Protection: 1</span><br></pre></td></tr></table></figure>

<p>首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。首部字段 X-XSS-Protection 可指定的字段值如下:</p>
<p>0 ：将 XSS 过滤设置成无效状态<br>1 ：将 XSS 过滤设置成有效状态</p>
<h2 id="DNT"><a href="#DNT" class="headerlink" title="DNT"></a>DNT</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DNT: 1</span><br></pre></td></tr></table></figure>

<p>首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。首部字段 DNT 可指定的字段值如下：</p>
<p>0 ：同意被追踪<br>1 ：拒绝被追踪<br>由于首部字段 DNT 的功能具备有效性，所以 Web 服务器需要对 DNT做对应的支持。</p>
<h2 id="P3P"><a href="#P3P" class="headerlink" title="P3P"></a>P3P</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P3P: CP=&quot;CAO DSP LAW CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDa OUR BUS IND</span><br></pre></td></tr></table></figure>

<p>首部字段 P3P 属于 HTTP 响应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。<br>要进行 P3P 的设定，需按以下操作步骤进行：</p>
<p>步骤 1：创建 P3P 隐私<br>步骤 2：创建 P3P 隐私对照文件后，保存命名在 /w3c/p3p.xml<br>步骤 3：从 P3P 隐私中新建 Compact policies 后，输出到 HTTP 响应中</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2018/07/15/http1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/15/http1/" itemprop="url">HTTP协议总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-15T17:03:57+08:00">
                2018-07-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index">
                    <span itemprop="name">Network</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>HTTP协议是Hyper Text Transfer Protocol(超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web)服务器传输超文本到本地浏览器的传送协议。HTTP是当今世界上应用最为广泛的<strong>应用层</strong>协议之一。</p>
<p>HTTP协议工作于客户端-服务端架构(CS)之上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p>
<p><img src="/images/http%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94.jpg" alt></p>
<p>下面总结一下HTTP的相关知识点，首先我们从HTTP的报文结构开始。</p>
<h1 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h1><h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><p><img src="/images/http_request.png" alt></p>
<p>HTTP请求报文由四部分组成:<strong>请求行、请求头、一个空行、请求体</strong>。如上图第一行为请求行，请求行由3部分组成，分别是请求方法，请求的URL和所使用的HTTP协议版本，这三部分用一个空格隔开，行未为一个回车换行符。请求行下面的是请求头部分，每一个请求头由头部字段名和值组成，中间用冒号分隔，行未依然为回车换行符。请求头可以有任意个。一个单独的换车换行符(即一个空行)表示了请求头部分结束，空行下面的就是可选的请求体部分。这就是一个HTTP请求的报文格式。</p>
<h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><p><img src="/images/http_resp.jpeg" alt><br>HTTP响应报文与请求报文的格式基本相同，它是由:<strong>状态行、响应头、一个空行、响应实体四部分组成</strong>。如上图第一行为状态行。与请求报文不同的是状态行由协议版本、状态码和原因短语组成。</p>
<h1 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h1><p>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GET</td>
<td align="center">请求指定的页面信息，并返回实体主体。</td>
</tr>
<tr>
<td align="center">POST</td>
<td align="center">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</td>
</tr>
<tr>
<td align="center">PUT</td>
<td align="center">从客户端向服务器传送的数据取代指定的文档的内容.</td>
</tr>
<tr>
<td align="center">DELETE</td>
<td align="center">请求服务器删除指定的页面。</td>
</tr>
<tr>
<td align="center">HEAD</td>
<td align="center">类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td align="center">OPTIONS</td>
<td align="center">允许客户端查看服务器的性能、获取服务器支持的HTTP请求方法。</td>
</tr>
<tr>
<td align="center">TRACE</td>
<td align="center">回显服务器收到的请求，主要用于测试或诊断。</td>
</tr>
<tr>
<td align="center">CONNECT</td>
<td align="center">HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</td>
</tr>
</tbody></table>
<p>在实践中GET,POST,PUT,DELETE四种方法使用的比较多,他们分别对应对资源的获取，创建，更新，删除这四种操作。</p>
<h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><p>HTTP状态码类型及其含义:</p>
<table>
<thead>
<tr>
<th align="center">分类</th>
<th align="center">分类描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1xx</td>
<td align="center">信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td align="center">2xx</td>
<td align="center">成功，操作被成功接收并处理</td>
</tr>
<tr>
<td align="center">3xx</td>
<td align="center">重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td align="center">4xx</td>
<td align="center">客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td align="center">5xx</td>
<td align="center">服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody></table>
<p>常见HTTP状态码列表:</p>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th align="center">状态码英文名称</th>
<th align="center">中文描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">100</td>
<td align="center">Continue</td>
<td align="center">继续。客户端应继续其请求</td>
</tr>
<tr>
<td align="center">101</td>
<td align="center">Switching Protocols</td>
<td align="center">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td align="center">200</td>
<td align="center">OK</td>
<td align="center">请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td align="center">201</td>
<td align="center">Created</td>
<td align="center">已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td align="center">202</td>
<td align="center">Accepted</td>
<td align="center">已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td align="center">203</td>
<td align="center">Non-Authoritative Information</td>
<td align="center">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td align="center">204</td>
<td align="center">No Content</td>
<td align="center">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td align="center">205</td>
<td align="center">Reset Content</td>
<td align="center">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td align="center">206</td>
<td align="center">Partial Content</td>
<td align="center">部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td align="center">300</td>
<td align="center">Multiple Choices</td>
<td align="center">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td align="center">301</td>
<td align="center">Moved Permanently</td>
<td align="center">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td align="center">302</td>
<td align="center">Found</td>
<td align="center">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td align="center">303</td>
<td align="center">See Other</td>
<td align="center">查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td align="center">304</td>
<td align="center">Not Modified</td>
<td align="center">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td align="center">305</td>
<td align="center">Use Proxy</td>
<td align="center">使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td align="center">306</td>
<td align="center">Unused</td>
<td align="center">已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td align="center">307</td>
<td align="center">Temporary Redirect</td>
<td align="center">临时重定向。与302类似。使用GET请求重定向</td>
</tr>
<tr>
<td align="center">400</td>
<td align="center">Bad Request</td>
<td align="center">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td align="center">401</td>
<td align="center">Unauthorized</td>
<td align="center">请求要求用户的身份认证</td>
</tr>
<tr>
<td align="center">402</td>
<td align="center">Payment Required</td>
<td align="center">保留，将来使用</td>
</tr>
<tr>
<td align="center">403</td>
<td align="center">Forbidden</td>
<td align="center">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td align="center">404</td>
<td align="center">Not Found</td>
<td align="center">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td align="center">405</td>
<td align="center">Method Not Allowed</td>
<td align="center">客户端请求中的方法被禁止</td>
</tr>
<tr>
<td align="center">406</td>
<td align="center">Not Acceptable</td>
<td align="center">服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td align="center">407</td>
<td align="center">Proxy Authentication Required</td>
<td align="center">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td align="center">408</td>
<td align="center">Request Time-out</td>
<td align="center">服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td align="center">409</td>
<td align="center">Conflict</td>
<td align="center">服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td align="center">411</td>
<td align="center">Length Required</td>
<td align="center">服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td align="center">413</td>
<td align="center">Request Entity Too Large</td>
<td align="center">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td align="center">414</td>
<td align="center">Request-URI Too Large</td>
<td align="center">请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td align="center">415</td>
<td align="center">Unsupported Media Type</td>
<td align="center">服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td align="center">429</td>
<td align="center">Too Many Requests</td>
<td align="center">发送请求太多，服务器拒绝服务</td>
</tr>
<tr>
<td align="center">500</td>
<td align="center">Internal Server Error</td>
<td align="center">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td align="center">501</td>
<td align="center">Not Implemented</td>
<td align="center">服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td align="center">502</td>
<td align="center">Bad Gateway</td>
<td align="center">充当网关或代理的服务器，从远端服务器接收到了一个无效的请求</td>
</tr>
<tr>
<td align="center">503</td>
<td align="center">Service Unavailable</td>
<td align="center">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td align="center">504</td>
<td align="center">Gateway Time-out</td>
<td align="center">充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td align="center">505</td>
<td align="center">HTTP Version not supported</td>
<td align="center">服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>
<h1 id="持续连接与非持续连接"><a href="#持续连接与非持续连接" class="headerlink" title="持续连接与非持续连接"></a>持续连接与非持续连接</h1><p>HTTP是建立在TCP协议之上的应用层协议，众所周知TCP协议为了实现可靠数据传输在建立连接的过程会进行三次握手。也就是说，客户端需要与服务器建立连接必须首先先服务器发送一个特殊的报文段(SYN)，该报文段是不能携带应用层数据的，然后客户端需要等待服务器发回确认报文(SYNAK)。待接收到服务器发会的SYNACK报文之后，客户端还需要发送ACK报文给服务器(这个ACK报文中可以携带应用层的数据)。在客户端服务器进行了三次报文的传输之后，连接才算建立，之后应用层的数据会在这个连接上传输。</p>
<p>HTTP 协议的初始版本中，<strong>每进行一个 HTTP 通信(即一个请求响应对)都要断开一次 TCP 连接，这种方式称为非持续连接</strong>。比如使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问HTML页面资源的同时，也会请求该HTML页面里包含的其他资源。因此，非持续连接每次的请求都会造成无畏的TCP连接建立和断开，增加通信量的开销。为了解决上述 TCP 连接的问题，HTTP/1.1 和部分 HTTP/1.0 想出了持久连接的方法。其特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。<strong>旨在建立一次 TCP 连接后进行多次请求和响应的交互，这种方式称为持久连接</strong>。<strong>在HTTP/1.1 中，所有的连接默认都是持久连接。</strong></p>
<h1 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h1><p>持久连接使得多数请求以流水线方式发送成为可能。以前发送请求后需等待并接收到响应，才能发送下一个请求。流水线技术出现后，不用等待亦可发送下一个请求。这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应了。比如，当请求一个包含多张图片的 HTML页面时，与挨个连接相比，用持久连接可以让请求更快结束。而流水线技术要比持久连接速度更快。请求数越多，时间差就越明显。采用流水线方式的持久连接使的HTTP通信的速度大幅提升。</p>
<h1 id="一些辨析"><a href="#一些辨析" class="headerlink" title="一些辨析"></a>一些辨析</h1><h2 id="301-302-303-307"><a href="#301-302-303-307" class="headerlink" title="301/302/303/307"></a>301/302/303/307</h2><p>301/302/303/307都是表示重定向。重定向实际使用是一个响应码(301或302或303或307)和一个响应头location，当浏览器收到响应的时候check响应码是3xx，则会取出响应头中Location对应的url，然后将该url替换浏览器地址栏中的并发起另一次HTTP事务。既然它们都表示重定向，那么他们的区别是什么呢</p>
<p>HTTP 1.0规范中有2个重定向－－301和302，在HTTP 1.1规范中存在4个重定向——301、302、303和307。<br><strong>HTTP 1.0规范定义</strong>301表示永久重定向,也就是资源的真实URL为Location头部中的URL。对于GET请求重定向，浏览器跟进；对于POST请求的重定向，还是需要用户确认之后才能重定向，并且应该以POST方法发出重定向请。302表示临时重定向，Location中的地址不应该被认为是资源路径，在后续的请求中应该继续使用原地址。这时，原请求是POST，则不能自动进行重定向；原请求是GET，才可以自动重定向。<br><strong>在目前主流浏览器的实现中</strong>浏览器无论是接收到301还是302,同样无论是GET还是POST,都会自动进行重定向，这导致规范和实现之间产生了二义性。由此衍生了一些问题，譬如302劫持，因此在HTTP 1.1中将302的规范细化成了303和307，希望以此来消除二义性。</p>
<blockquote>
<p><strong>302劫持</strong>：<br>对于301,搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；对于302,搜索引擎会抓取新的内容而保存旧的网址。利用这一原理，从网站A（网站比较烂）上做了一个302跳转到网站B（搜索排名很靠前），这时候有时搜索引擎会使用网站B的内容，但却收录了网站A的地址，这样在不知不觉间，网站B在为网站A作贡献，网站A的排名就靠前了，这就是302劫持。</p>
</blockquote>
<p>为了消除上面规范与实现的二义性，在HTTP 1.1中引入了303和307状态码。实际上官方文档已经不建议使用302状态码，只是为了兼容而保留302。 HTTP 1.1把HTTP 1.0规范中302的实现和规范拆分开，分别赋予HTTP 1.1中303和307，因此在HTTP 1.1中，303继承了HTTP 1.0中302的实现（即原请求是post，也允许自动进行重定向，结果是无论原请求是get还是post，都可以自动进行重定向），而307则继承了HTTP 1.0中302的规范（即如果原请求是post，则不允许进行自动重定向，结果是post不重定向，get可以自动重定向）。</p>
<p>在HTTP 1.1规范中，307为临时重定向，如果重定向307的原请求不是get或者head方法，那么浏览器一定不能自动的进行重定向，即便Location有url，也应该忽略。</p>
<h2 id="GET-POST"><a href="#GET-POST" class="headerlink" title="GET/POST"></a>GET/POST</h2><blockquote>
<p>GET后退按钮/刷新无害，POST数据会被重新提交（浏览器应该告知用户数据会被重新提交）。<br>GET书签可收藏，POST为书签不可收藏。GET能被缓存，POST不能缓存 。<br>GET编码类型application/x-www-form-url，POST编码类型encodedapplication/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。<br>GET历史参数保留在浏览器历史中。POST参数不会保存在浏览器历史中。<br>GET对数据长度有限制，当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。POST无限制。<br>GET只允许 ASCII 字符。POST没有限制。也允许二进制数据。<br>与 POST 相比，GET 的安全性较差，因为所发送的数据是URL的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。GET的数据在URL中对所有人都是可见的。POST的数据不会显示在 URL 中。<br>GET是幂等的，POST不幂等。</p>
</blockquote>
<p>关于GET/POST的辨析，可以参考:<a href="https://www.zhihu.com/question/28586791" target="_blank" rel="noopener">https://www.zhihu.com/question/28586791</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2018/05/02/something-about-https-and-let-s-encrypt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/something-about-https-and-let-s-encrypt/" itemprop="url">聊聊HTTP、HTTPS那些事儿</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-02T23:05:56+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index">
                    <span itemprop="name">Network</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在HTTP协议中有可能存在信息窃听或身份伪装等安全问题，而使用HTTPS通信机制则可以有效的防止这些问题。这一篇文章我打算从安全的角度来聊一聊HTTP和HTTPS。</p>
<h1 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h1><p>HTTP具有相当优秀和方便的一面，然而它也并非只有好的一面，事物皆具有两面性，它也有自己的不足之处。这些不足之处尤其体现在安全方面。下面我们就先来看看HTTP在安全方面的缺陷。</p>
<h2 id="通信使用明文可能会被窃听"><a href="#通信使用明文可能会被窃听" class="headerlink" title="通信使用明文可能会被窃听"></a>通信使用明文可能会被窃听</h2><p>众所周知，HTTP报文使用明文(未经加密的报文)的方式来发送。而按照TCP/IP协议簇的工作方式，通信内容在所有的通信线路上都有可能遭到窥视。互联网是由能够连通到全世界的网络组成的。无论世界上哪个角落的服务器在和客户端通信时，再此通信线路上的某些网络设备、光缆、计算机等都不可能是个人的私有物，所以不排除某个环节中会遭到恶意窥视的行为的发生。</p>
<p>即使经过加密处理的通信，其通信内容仍然会被窥视到，这点和未加密的通信是一样的。只是说如果通信经过加密，就有可能让人无法破解报文信息的含义，但加密处理后的报文信息还是会被看到。</p>
<p>窃听相同段上的通信并非难事，只需要收集在互联网上流动的数据包(帧)就行了。对于收集来的数据包的解析工作，可以交给那些抓包或者嗅探器工具。所以说，<strong>互联网上任何角落都存在通信内容被窃听的风险</strong>。</p>
<p>在目前大家正在研究的如何防止窃听的保护措施中，最为普及的就是加密技术。加密的对象可以是对整个通信线路进行加密，也就是服务器和客户端之间在建立起安全的通信线路之后才开始真正的通信。还有一种是将参与通信的内容本身加密。为了做到有效的内容加密，前提是要求客户端和服务器同时具备加密和解密机制。</p>
<h2 id="不验证通信方身份可能遭遇伪装"><a href="#不验证通信方身份可能遭遇伪装" class="headerlink" title="不验证通信方身份可能遭遇伪装"></a>不验证通信方身份可能遭遇伪装</h2><p>HTTP协议中的请求和响应不会对通信方进行确认，也就是说存在’服务器是否就是发送请求中URI真正指定的主机，返回的响应是否真的返回到实际请求的客户端’等类似问题。理论上来讲，任何人都可以发起请求，服务器只要接收到请求，不管对方是谁都会返回一个响应，这会存在以下的各种忧患：</p>
<ul>
<li>无法确认请求发送至目标的Web服务器是，否是按照真实意图返回响应的那台服务器，有可能是已经伪装的Web服务器。</li>
<li>无法确认响应返回到的客户端是否是按真实意图接收响应的那个客户端，有可能是已伪装的客户端。</li>
<li>无意义的请求也会照单全收。无法阻止海量请求下的DoS攻击(Denial of Service,拒绝服务攻击)。</li>
</ul>
<p>虽然HTTP协议无法确认通信方，但如果使用SSL则可以，SSL不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确认通信方。证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。另外，伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认同通信方(服务器或客户端)持有的证书，即可判断通信方的真实意图。</p>
<h2 id="无法证明报文完整性，可能已遭篡改"><a href="#无法证明报文完整性，可能已遭篡改" class="headerlink" title="无法证明报文完整性，可能已遭篡改"></a>无法证明报文完整性，可能已遭篡改</h2><p>由于HTTP协议无法证明通信的报文的完整性，因此在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。换句话说，没有任何办法确认，发出的请求/响应和接收到的请求/响应是前后相同的。因为在数据传输的途中，内容可能会被篡改。像这样，请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击(Man-in-the-Middle attack,MITM).</p>
<p>虽然有使用HTTP协议确定报文完整性的方法，但事实上并不便捷、可靠。其中常用的是MD5,SHA-1等散列值校验的方法。但是这种方法都需要操作客户端的用户本人亲自检查验证下载的文件是否就是原来服务器上的文件，浏览器无法自动帮用户检查。另外，这种方法也依然无法百分之百的保证确认结果正确，应为MD5值本身被改写的话，用户是没有办法意识到的。</p>
<p>通过上面的分析，我们知道HTTP在安全方面确实存在着很大的缺陷，为了有效的防止这些弊端，有必要使用HTTPS。</p>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p><strong>HTTP加上加密处理和认证以及完整性保护后就是HTTPS</strong>。HTTPS并非是应用层的一种新协议，只是HTTP通信接口部分用SSL和TLS协议替代而已。通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，所谓HTTPS,其实就是身披SSL协议这层外壳的HTTP。在采用SSL之后，HTTP就拥有了安全传输的能力。</p>
<h2 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h2><p>要了解https我们先来了解一下两种加密算法:对称加密和非对称加密。<br>对称加密特点是：加密和解密使用相同密钥的算法。它要求发送方和接收方在安全通信之前，商定一个对称密钥。对称算法的安全性完全依赖于密钥，密钥泄漏就意味着任何人都可以对他们发送或接收的消息解密，所以密钥的保密性对通信至关重要。<br>非对称加密特点是：有公钥和私钥之分，公钥可以给任何人，而私钥则只部署在服务器端。<strong>并且公钥加密的数据，有且只有与该公钥对应的私钥才可以解密。</strong>非对称加密的缺点是加密和解密的计算量比较大，非常消耗CPU资源。</p>
<h2 id="SSL-TSL"><a href="#SSL-TSL" class="headerlink" title="SSL/TSL"></a>SSL/TSL</h2><p><img src="/images/sslsession.png" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2018/04/30/let-the-terminal-penetrate-the-firewall/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/30/let-the-terminal-penetrate-the-firewall/" itemprop="url">终端翻墙备忘录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-30T10:17:09+08:00">
                2018-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这几天要开始用GO写东西了，但是由于GFW的存在，在终端中有一些包用<code>go get</code>无法下载到。虽然本人有可以使用的ssr服务(服务默认跑在本地的1080端口)，但是ssr使用的是socks5代理。在命令行终端下，ssr无法正常工作。因为在终端下wget、curl、git、brew等命令行工具使用的都是http协议。这样的话，我们需要做就是将socks5代理转成http代理。下面就介绍两个常用的转换的工具。</p>
<h1 id="socks5转http"><a href="#socks5转http" class="headerlink" title="socks5转http"></a>socks5转http</h1><h2 id="privoxy"><a href="#privoxy" class="headerlink" title="privoxy"></a>privoxy</h2><blockquote>
<p>Privoxy is a non-caching web proxy with advanced filtering capabilities for enhancing privacy,modifying web page data and HTTP headers, controlling access, and removing ads and other obnoxious Internet junk. Privoxy has a flexible configuration and can be customized to suit individual needs and tastes. It has application for both stand-alone systems and multi-user networks.</p>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install privoxy</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在<code>/etc/privoxy/config</code>文件中添加如下的一条配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forward-socks5 / 127.0.0.1:1080 .</span><br></pre></td></tr></table></figure>

<p>这条配置的意思是将到达privoxy的http流量以socks5的形式转发至本地的1080端口(ssr服务跑在该端口)，将从本地1080端口传回的socks5流量以http形式转发至终端程序.(这句话完全是我自己的理解)</p>
<h3 id="重启并确认"><a href="#重启并确认" class="headerlink" title="重启并确认"></a>重启并确认</h3><p>因为更改了配置文件，所以要重启provixy服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service privoxy restart</span><br></pre></td></tr></table></figure>

<p>确认privoxy服务已经启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service privoxy status</span><br></pre></td></tr></table></figure>

<p>privoxy服务默认跑在本地的8118端口。</p>
<h2 id="polipo"><a href="#polipo" class="headerlink" title="polipo"></a>polipo</h2><blockquote>
<p>Polipo is single-threaded, non blocking caching web proxy that has very modest resource needs. </p>
</blockquote>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install polipo</span><br></pre></td></tr></table></figure>

<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>在<code>/etc/polipo/config</code>文件中做如下的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># This file only needs to list configuration variables that deviate</span><br><span class="line"># from the default values.  See /usr/share/doc/polipo/examples/config.sample</span><br><span class="line"># and &quot;polipo -v&quot; for variables you can tweak and further information.</span><br><span class="line"></span><br><span class="line">logSyslog = true</span><br><span class="line">logFile = /var/log/polipo/polipo.log</span><br><span class="line"></span><br><span class="line">proxyAddress = &quot;0.0.0.0&quot;</span><br><span class="line"></span><br><span class="line">socksParentProxy = &quot;127.0.0.1:1080&quot;</span><br><span class="line">socksProxyType = socks5</span><br><span class="line"></span><br><span class="line">chunkHighMark = 50331648</span><br><span class="line">objectHighMark = 16384</span><br><span class="line"></span><br><span class="line">dnsQueryIPv6 = no</span><br></pre></td></tr></table></figure>

<h3 id="重启并确认-1"><a href="#重启并确认-1" class="headerlink" title="重启并确认"></a>重启并确认</h3><p>因为更改了配置文件，所以要重启polipo服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service polipo restart</span><br></pre></td></tr></table></figure>

<p>确认polipo服务已经启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service polipo status</span><br></pre></td></tr></table></figure>

<p>polipo服务默认跑在本地的8123端口。</p>
<h1 id="终端设置"><a href="#终端设置" class="headerlink" title="终端设置"></a>终端设置</h1><p>当我们把协议转换服务架设好之后，下一步要做的就是在终端中设置代理了.</p>
<h2 id="当前终端设置代理"><a href="#当前终端设置代理" class="headerlink" title="当前终端设置代理"></a>当前终端设置代理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=`http://127.0.0.1:8118`</span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">'http://127.0.0.1:8118'</span></span><br></pre></td></tr></table></figure>

<p>注意上面使用的是privoxy的端口，如果是polipo则改为对应的端口。下同。<br>我们在当前终端中设置上面的两个环境变量即可设置代理。但是这种方式只在当前终端有效，当新启动一个终端后就需要重新设置。</p>
<h2 id="在-bashrc文件中设置代理"><a href="#在-bashrc文件中设置代理" class="headerlink" title="在.bashrc文件中设置代理"></a>在.bashrc文件中设置代理</h2><p>我们可以在当前用户的<code>.bashrc</code>文件中设置如下的两个alias：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> proxy=<span class="string">"export http_proxy=http://localhost:8118;export https_proxy=http://localhost:8118"</span> </span><br><span class="line"><span class="built_in">alias</span> unproxy=<span class="string">"unset http_proxy;unset https_proxy"</span></span><br></pre></td></tr></table></figure>

<p>让配置立即生效:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> .bashrc</span><br></pre></td></tr></table></figure>

<p>我们在终端中通过运行<code>proxy</code>命令来启用终端代理，运行<code>unproxy</code>就不用代理。这样就可以在代理与非代理之间切换自如了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2018/04/25/heapster-in-kubernetes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/25/heapster-in-kubernetes/" itemprop="url">在k8s-dashboard中集成heapster</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-25T21:26:38+08:00">
                2018-04-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kubernetes/" itemprop="url" rel="index">
                    <span itemprop="name">Kubernetes</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面，我们在k8s集群中安装了kubernetes-dashboard插件，进入到了dashboard的界面中去了。但是我们查看kubernetes-dashboard的log,会发现有下面这样的记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2018/04/29 01:56:10 Getting config category</span><br><span class="line">2018/04/29 01:56:10 Getting discovery and load balancing category</span><br><span class="line">2018/04/29 01:56:10 Getting lists of all workloads</span><br><span class="line">2018/04/29 01:56:10 No metric client provided. Skipping metrics.</span><br><span class="line">2018/04/29 01:56:10 No metric client provided. Skipping metrics.</span><br><span class="line">2018/04/29 01:56:10 No metric client provided. Skipping metrics.</span><br><span class="line">2018/04/29 01:56:10 No metric client provided. Skipping metrics.</span><br><span class="line">2018/04/29 01:56:10 No metric client provided. Skipping metrics.</span><br><span class="line">2018/04/29 01:56:10 Getting pod metrics</span><br><span class="line">2018/04/29 01:56:10 No metric client provided. Skipping metrics.</span><br><span class="line">2018/04/29 01:56:10 No metric client provided. Skipping metrics.</span><br><span class="line">2018/04/29 01:56:10 No metric client provided. Skipping metrics.</span><br><span class="line">2018/04/29 01:56:10 [2018-04-29T01:56:10Z] Outcoming response to 10.32.0.1:49022 with 200 status code</span><br><span class="line">2018/04/29 01:56:38 Metric client health check failed: the server could not find the requested resource (get services heapster). Retrying in 30 seconds.</span><br></pre></td></tr></table></figure>

<p>从上面的log中我们大致可以得出如下的信息:当前系统中没有用于获取监控信息指标的客户端(metric client)，所以kubernetes-dashboard的处理方式是跳过这一步。同时，对metric client的健康检查失败了。这些问题不会导致dashboard无法工作，只是kubernetes-dashboard获取不到系统以及各个pod的监控数据。这里的解决方案就是安装另外一个k8s插件－－heapster.</p>
<h1 id="heapster简介"><a href="#heapster简介" class="headerlink" title="heapster简介"></a>heapster简介</h1><p>Heapster是容器集群监控和性能分析工具，天然的支持Kubernetes和CoreOS。<br>Kubernetes有个出名的监控agent—cAdvisor。在每个kubernetes Node上都会运行cAdvisor，它会收集本机以及容器的监控数据(cpu,memory,filesystem,network,uptime)。<br>Heapster是一个收集者，将每个Node上的cAdvisor的数据进行汇总，然后导到第三方工具(如InfluxDB)。<br><img src="/images/heapster.png" alt></p>
<p>Heapster首先从K8S Master获取集群中所有Node的信息，然后通过这些Node上的kubelet获取有用数据，而kubelet本身的数据则是从cAdvisor得到。所有获取到的数据都被推到Heapster配置的后端存储中，并还支持数据的可视化。现在后端存储 + 可视化的方法，如InfluxDB + grafana。</p>
<p>下面我们就在k8s集群中配置安装heapster.</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>我们仍然采用容器化的方式，依托于k8s集群本身的方式来安装heapster.</p>
<h2 id="镜像准备"><a href="#镜像准备" class="headerlink" title="镜像准备"></a>镜像准备</h2><p>我们需要下面的三个镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heapster-influxdb-amd64:v1.3.3</span><br><span class="line">heapster-grafana-amd64:v4.4.3</span><br><span class="line">heapster-amd64:v1.4.0</span><br></pre></td></tr></table></figure>

<p>本来这些镜像本来在gcr.io上，但是由于国内网络无法直接访问到。我们这里依然采用网友上传到docker hub上的镜像。使用下面的脚本即可:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">images=(heapster-amd64:v1.4.0 heapster-influxdb-amd64:v1.3.3 heapster-grafana-amd64:v4.4.3)</span><br><span class="line"><span class="keyword">for</span> imageName <span class="keyword">in</span> <span class="variable">$&#123;images[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">  docker pull alleyj/<span class="variable">$imageName</span></span><br><span class="line">  docker tag alleyj/<span class="variable">$imageName</span> gcr.io/google_containers/<span class="variable">$imageName</span></span><br><span class="line">  docker rmi alleyj/<span class="variable">$imageName</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>这样，我们的镜像就准备完了。下面我们就需要获得对应的manifest文件了。</p>
<h2 id="manifest文件准备"><a href="#manifest文件准备" class="headerlink" title="manifest文件准备"></a>manifest文件准备</h2><p>这里，我们一共需要4个manifest文件，这四个文件可以在<a href="https://github.com/kubernetes/heapster" target="_blank" rel="noopener">heapster的github仓库</a>获得。在目录<code>heapster/deploy/kube-config/influxdb/</code>下有三个yml文件，分别对应的是heapster、influxdb、grafana。另外还需要的一个yml文件是一个基于rbac的角色绑定文件，在<code>heapster/deploy/kube-config/rbac/</code>目录下。</p>
<p>这样我们就准备好了这些文件，置于heapster目录之下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">heapster-rbac.yaml</span><br><span class="line">heapster.yaml</span><br><span class="line">grafana.yaml</span><br><span class="line">influxdb.yaml</span><br></pre></td></tr></table></figure>

<h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>查看这些文件，看看所使用的镜像版本是否是你上面所下载的镜像的版本。确认无误之后运行下面的命令即可配置完成:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f heapster/</span><br></pre></td></tr></table></figure>

<p>这样，我们再次进入到k8s-dashboard就可以看到各种以图表形式展示的系统，各个pod的实时的监控数据了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://andrewpqc.github.io/2018/04/25/k8s-dashboard-auth/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Andrew">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Andrew's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/25/k8s-dashboard-auth/" itemprop="url">Kubernetes-dashboard的身份认证</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-25T21:24:02+08:00">
                2018-04-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kubernetes/" itemprop="url" rel="index">
                    <span itemprop="name">Kubernetes</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一篇文章中，我们成功配置安装了kubernetes-dashboard插件，但是这里似乎来了另外一个问题:我们怎样进入到dashboard?</p>
<p><img src="/images/dashboard.login.png" alt="login"><br>如上图，<code>kubernetes-dashboard</code>提供了两种验证方式:<code>kubeconfig</code>、<code>token</code>。这两种验证方式都是怎么回事呢?诶，好像有一个<code>skip</code>,我们点击看看。直接点击<code>skip</code>,我们进入到了dashboard的界面，但是似乎我们什么都做不了，页面给出了提醒，我们没有权限查看和操作集群里面的资源。该怎么办呢？下面就让我们一起来看看kubernetes里面的身份认证和权限管理吧!</p>
<p>要了解k8s中的身份认证和权限管理我们就必须先来了解k8s中的RBAC(Role-based access control)授权模式。</p>
<h1 id="RBAC-in-K8s"><a href="#RBAC-in-K8s" class="headerlink" title="RBAC in K8s"></a>RBAC in K8s</h1><p><code>RBAC Authorization</code>的基本概念是<code>Role</code>和<code>RoleBinding</code>。<code>Role</code>是一些<code>permission</code>的集合；而<code>RoleBinding</code>则是将<code>Role</code>授权给某些<code>User</code>、某些<code>Group</code>或某些<code>ServiceAccount</code>。K8s官方博客<a href="https://kubernetes.io/blog/2017/04/rbac-support-in-kubernetes" target="_blank" rel="noopener">RBAC Support in Kubernetes</a>一文的中的配图对此做了很生动的诠释：</p>
<p><img src="/images/rbac2.png" alt="picture"><br>从上图中我们可以看到：<br>Role:<code>pod-reader</code> 拥有Pod的<code>get</code>和<code>list</code> permissions；<br>RoleBinding:<code>pod-reader</code>将<code>Role</code>:<code>pod-reader</code>授权给右边的<code>User</code>、<code>Group</code>和<code>ServiceAccount</code>。</p>
<p>与<code>Role</code>和<code>RoleBinding</code>对应的是，K8s还有<code>ClusterRole</code>和<code>ClusterRoleBinding</code>的概念，它们不同之处在于：<code>ClusterRole</code>和<code>ClusterRoleBinding</code>是针对整个<code>Cluster</code>范围内有效的，无论用户或资源所在的<code>namespace</code>是什么；而<code>Role</code>和<code>RoleBinding</code>的作用范围是局限在某个k8s namespace中的。</p>
<p>kubernetes在安装之初就已经生成了许多<code>role</code>、<code>rolebinding</code>、<code>clusterrole</code>和<code>clusterrolebinding</code>,它们也是属于kubernetes资源的一部分，所以可以通过<code>get</code>、<code>describe</code>等命令查看，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9f6pgul78p7die5tlzZ dashboard]<span class="comment"># kc get role -n kube-system</span></span><br><span class="line">NAME                                             AGE</span><br><span class="line">extension-apiserver-authentication-reader        5d</span><br><span class="line">kubernetes-dashboard-minimal                     2d</span><br><span class="line">system::leader-locking-kube-controller-manager   5d</span><br><span class="line">system::leader-locking-kube-scheduler            5d</span><br><span class="line">system:controller:bootstrap-signer               5d</span><br><span class="line">system:controller:cloud-provider                 5d</span><br><span class="line">system:controller:token-cleaner                  5d</span><br><span class="line">weave-net                                        5d</span><br><span class="line">[root@iZwz9f6pgul78p7die5tlzZ dashboard]<span class="comment"># kc describe role extension-apiserver-authentication-reader -n kube-system</span></span><br><span class="line">Name:		extension-apiserver-authentication-reader</span><br><span class="line">Labels:		kubernetes.io/bootstrapping=rbac-defaults</span><br><span class="line">Annotations:	rbac.authorization.kubernetes.io/autoupdate=<span class="literal">true</span></span><br><span class="line">PolicyRule:</span><br><span class="line">  Resources	Non-Resource URLs	Resource Names				Verbs</span><br><span class="line">  ---------	-----------------	--------------				-----</span><br><span class="line">  configmaps	[]			[extension-apiserver-authentication]	[get]</span><br></pre></td></tr></table></figure>

<p>下面截取了<code>kubernetes-dashboard.yml</code>文件的一部分：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ------------------- Dashboard Service Account ------------------- #</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># ------------------- Dashboard Role &amp; Role Binding ------------------- #</span></span><br><span class="line"></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubernetes-dashboard-minimal</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="comment"># Allow Dashboard to create and watch for changes of 'kubernetes-dashboard-key-holder' secret.</span></span><br><span class="line"><span class="attr">- apiGroups:</span> <span class="string">[""]</span></span><br><span class="line"><span class="attr">  resources:</span> <span class="string">["secrets"]</span></span><br><span class="line"><span class="attr">  verbs:</span> <span class="string">["create",</span> <span class="string">"watch"</span><span class="string">]</span></span><br><span class="line"><span class="attr">- apiGroups:</span> <span class="string">[""]</span></span><br><span class="line"><span class="attr">  resources:</span> <span class="string">["secrets"]</span></span><br><span class="line">  <span class="comment"># Allow Dashboard to get, update and delete 'kubernetes-dashboard-key-holder' secret.</span></span><br><span class="line"><span class="attr">  resourceNames:</span> <span class="string">["kubernetes-dashboard-key-holder",</span> <span class="string">"kubernetes-dashboard-certs"</span><span class="string">]</span></span><br><span class="line"><span class="attr">  verbs:</span> <span class="string">["get",</span> <span class="string">"update"</span><span class="string">,</span> <span class="string">"delete"</span><span class="string">]</span></span><br><span class="line">  <span class="comment"># Allow Dashboard to get metrics from heapster.</span></span><br><span class="line"><span class="attr">- apiGroups:</span> <span class="string">[""]</span></span><br><span class="line"><span class="attr">  resources:</span> <span class="string">["services"]</span></span><br><span class="line"><span class="attr">  resourceNames:</span> <span class="string">["heapster"]</span></span><br><span class="line"><span class="attr">  verbs:</span> <span class="string">["proxy"]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubernetes-dashboard-minimal</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line"><span class="attr">  apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">  kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubernetes-dashboard-minimal</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="attr">- kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>上面这个yml文件做了这么一件事情：在<code>kube-system</code>命名空间中创建了一个名为<code>kubernetes-dashboard</code>的<code>ServiceAccount</code>。同时，在<code>kube-system</code>命名空间中创建了一个名为<code>kubernetes-dashboard-minimal</code>的<code>Role</code>，并且定义了这个Role的权限.然后同样是在<code>kube-system</code>命名空间中创建了一个<code>RoleBinding</code>,将上面的<code>Role</code>与<code>ServiceAccount</code>绑定在一起了。这样<code>kubernetes-dashboard</code>就有了<code>kubernetes-dashboard-minimal</code>所定义的权限了。<strong>有一点需要注意：这里的<code>kubernetes-dashboard</code>这个ServiceAccount是当用户直接点击<code>skip</code>进入到<code>dashboard</code>时所使用的账户。</strong></p>
<h1 id="测试环境中的认证"><a href="#测试环境中的认证" class="headerlink" title="测试环境中的认证"></a>测试环境中的认证</h1><p>如果是在测试环境中，我们图个简单，不考虑安全性的情况之下。可以考虑让外部用户直接点击<code>skip</code>进入到dashboard，并且拥有所有的权限。这一点可以通过将<code>cluster-admin</code>这个拥有全集群最高权限的<code>ClusterRole</code>绑定到默认使用的<code>ServiceAccount－－kubernetes-dashboard</code>，具体的做法是:<br>创建文件:<code>dashboard-admin.yml</code>,填写下列内容:</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line"><span class="attr">  apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">  kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">cluster-admin</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="attr">- kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></table></figure>

<p>执行下面的命令来创建一个ClusterRoleBinding：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f dashboard-admin.yml</span><br></pre></td></tr></table></figure>

<p>这样，我们就可以直接点击<code>skip</code>进入dashboard,并且拥有全部的权限。</p>
<h1 id="基于token的认证"><a href="#基于token的认证" class="headerlink" title="基于token的认证"></a>基于token的认证</h1><p>下面我们来说说token这种方式。点击选择:Token单选框，提示你输入token。token从哪里获取，我们从来没有生成过token？其实当前K8s中已经有了很多token：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9f6pgul78p7die5tlzZ dashboard]# kc get secret -n kube-system</span><br><span class="line">NAME                                     TYPE                                  DATA      AGE</span><br><span class="line">attachdetach-controller-token-vkm75      kubernetes.io/service-account-token   3         5d</span><br><span class="line">bootstrap-signer-token-k59x3             kubernetes.io/service-account-token   3         5d</span><br><span class="line">bootstrap-token-ff4535                   bootstrap.kubernetes.io/token         5         5d</span><br><span class="line">certificate-controller-token-z3qpm       kubernetes.io/service-account-token   3         5d</span><br><span class="line">daemon-set-controller-token-3lbtj        kubernetes.io/service-account-token   3         5d</span><br><span class="line">default-token-8372f                      kubernetes.io/service-account-token   3         5d</span><br><span class="line">deployment-controller-token-pb2wl        kubernetes.io/service-account-token   3         5d</span><br><span class="line">disruption-controller-token-jwjlt        kubernetes.io/service-account-token   3         5d</span><br><span class="line">endpoint-controller-token-t3h87          kubernetes.io/service-account-token   3         5d</span><br><span class="line">generic-garbage-collector-token-sm8lt    kubernetes.io/service-account-token   3         5d</span><br><span class="line">heapster-token-zqld8                     kubernetes.io/service-account-token   3         6h</span><br><span class="line">horizontal-pod-autoscaler-token-v6wjc    kubernetes.io/service-account-token   3         5d</span><br><span class="line">job-controller-token-hfl7h               kubernetes.io/service-account-token   3         5d</span><br><span class="line">kube-dns-token-rfkvx                     kubernetes.io/service-account-token   3         5d</span><br><span class="line">kube-proxy-token-r017j                   kubernetes.io/service-account-token   3         5d</span><br><span class="line">kubernetes-dashboard-certs               Opaque                                2         2d</span><br><span class="line">kubernetes-dashboard-key-holder          Opaque                                2         4d</span><br><span class="line">kubernetes-dashboard-token-jzx4v         kubernetes.io/service-account-token   3         2d</span><br><span class="line">namespace-controller-token-3j3sn         kubernetes.io/service-account-token   3         5d</span><br><span class="line">node-controller-token-cnjsn              kubernetes.io/service-account-token   3         5d</span><br><span class="line">persistent-volume-binder-token-p1cwr     kubernetes.io/service-account-token   3         5d</span><br><span class="line">pod-garbage-collector-token-rbw2m        kubernetes.io/service-account-token   3         5d</span><br><span class="line">replicaset-controller-token-pt682        kubernetes.io/service-account-token   3         5d</span><br><span class="line">replication-controller-token-s2kb7       kubernetes.io/service-account-token   3         5d</span><br><span class="line">resourcequota-controller-token-xlrrh     kubernetes.io/service-account-token   3         5d</span><br><span class="line">service-account-controller-token-zlcph   kubernetes.io/service-account-token   3         5d</span><br><span class="line">service-controller-token-0cqs6           kubernetes.io/service-account-token   3         5d</span><br><span class="line">statefulset-controller-token-0p29q       kubernetes.io/service-account-token   3         5d</span><br><span class="line">token-cleaner-token-cq9nk                kubernetes.io/service-account-token   3         5d</span><br><span class="line">ttl-controller-token-gndzv               kubernetes.io/service-account-token   3         5d</span><br><span class="line">weave-net-token-w6grc                    kubernetes.io/service-account-token   3         5d</span><br><span class="line">[root@iZwz9f6pgul78p7die5tlzZ dashboard]# kc describe secret attachdetach-controller-token-vkm75 -n kube-system</span><br><span class="line">Name:		attachdetach-controller-token-vkm75</span><br><span class="line">Namespace:	kube-system</span><br><span class="line">Labels:		&lt;none&gt;</span><br><span class="line">Annotations:	kubernetes.io/service-account.name=attachdetach-controller</span><br><span class="line">		kubernetes.io/service-account.uid=691cdfc2-4612-11e8-8dc4-00163e0a39da</span><br><span class="line"></span><br><span class="line">Type:	kubernetes.io/service-account-token</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">ca.crt:		1025 bytes</span><br><span class="line">namespace:	11 bytes</span><br><span class="line">token:		eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhdHRhY2hkZXRhY2gtY29udHJvbGxlci10b2tlbi12a203NSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50Lm5hbWUiOiJhdHRhY2hkZXRhY2gtY29udHJvbGxlciIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjY5MWNkZmMyLTQ2MTItMTFlOC04ZGM0LTAwMTYzZTBhMzlkYSIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDprdWJlLXN5c3RlbTphdHRhY2hkZXRhY2gtY29udHJvbGxlciJ9.ZBoh8-i6882nHH_oaEhtUw7L-M-2kGgrV3dRqAFw1bQUbenOYCK_xqQFeW0gTpEmYa_-k2cukfHKgqtyCF2U_hr1mXikc4aAZzJubnszQhNnASzHFihi5AkZfxBBiqYjd8WUaUSms1VbvImvmSg_Ndrw3-SSB0B0b-sWEH4dAwcXx1_hN2V3GBXZjjdFHT51U6ogvwzs-YJ_Uk5GqWIPxPNHhGMFQtQL3vVIHpxumtG6xdoVRuDitMl0gH71gugSgjabNLPMjIHmApbI3BIeH9bX9jO271OdTzNGvKaBOx2xLRJBTvrk4bSyZsSdqrLkWlUVgCTw7VNLKpmgfNTMDQ</span><br></pre></td></tr></table></figure>

<p>如上，这里有很多的<code>secret</code>存在于系统之中，每个<code>secret</code>都对应了一个<code>token</code>,但是这些<code>token</code>所对应的权限都不相同,所以不一定会符合我们的要求。</p>
<p>这里我们需要创建一个名为admin的ServiceAccount并绑定名为cluster-admin的ClusterRole角色(该角色拥有集群最高权限)，使用下面的yaml文件创建admin用户并赋予他管理员权限，然后可以通过token登陆dashbaord。这种认证方式本质上是通过ServiceAccount的身份认证加上Bearer token请求API server的方式实现。<br>admin-token.yml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">kind: ClusterRoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">metadata:</span><br><span class="line">  name: admin</span><br><span class="line">  annotations:</span><br><span class="line">    rbac.authorization.kubernetes.io/autoupdate: &quot;true&quot;</span><br><span class="line">roleRef:</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: admin</span><br><span class="line">  namespace: kube-system</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: admin</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  labels:</span><br><span class="line">    kubernetes.io/cluster-service: &quot;true&quot;</span><br><span class="line">    addonmanager.kubernetes.io/mode: Reconcile</span><br></pre></td></tr></table></figure>

<p>运行下面的命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f admin-token.yml</span><br></pre></td></tr></table></figure>

<p>然后我们可以通过如下的命令来获取admin ServiceAccount的token：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9f6pgul78p7die5tlzZ ~]# kc get secret -n kube-system | grep admin</span><br><span class="line">admin-token-whj4t                        kubernetes.io/service-account-token   3         1d</span><br><span class="line">[root@iZwz9f6pgul78p7die5tlzZ ~]# kc describe secret/admin-token-whj4t -n kube-system</span><br><span class="line">Name:		admin-token-whj4t</span><br><span class="line">Namespace:	kube-system</span><br><span class="line">Labels:		&lt;none&gt;</span><br><span class="line">Annotations:	kubernetes.io/service-account.name=admin</span><br><span class="line">		kubernetes.io/service-account.uid=f2e69a6e-4a03-11e8-8dc4-00163e0a39da</span><br><span class="line"></span><br><span class="line">Type:	kubernetes.io/service-account-token</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">ca.crt:		1025 bytes</span><br><span class="line">namespace:	11 bytes</span><br><span class="line">token:		eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhZG1pbi10b2tlbi13aGo0dCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50Lm5hbWUiOiJhZG1pbiIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6ImYyZTY5YTZlLTRhMDMtMTFlOC04ZGM0LTAwMTYzZTBhMzlkYSIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDprdWJlLXN5c3RlbTphZG1pbiJ9.Nq6N7E7xY09sITcqa0WP3OeNo6Sp_se69q9aH3oM-gWDx7Sp_sbRn1VIBE-op9yG4XRbkoam-KVYhyX7QVATesYCF1fZ0p0ENcctAhmO9aEoQ1GS5I6W3DWrUXgWgaZJSrNHt-czHC_WUB3ilggaDcOEAqPEb3gYqrezyEarclQPNQZfHo3UNWjhjCqmm2vOEweCbyn9o0t8QHTTT_Pp26Bq1ho2B4HqGEeM8RHa175mG18eJQ5aRYuMM70Yp0uNyyMQmXnPTNzX0uHvU9uq-dSxxDRlq5bRg_l5bravtCsr51I-VMU9FyWd3OJWK0z1hrO76X1JrWfsbmzY3rVCSg</span><br></pre></td></tr></table></figure>

<p>如上，我们得到了该用户的token,<strong>注意：这里的token是进行base64编码后的结果，而我们需要的是解码之后的结果</strong>,直接获取解码之后的token可以通过下面的命令实现:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl -n kube-system get secret admin-token-whj4t -o jsonpath=&#123;.data.token&#125;|base64 -d</span><br></pre></td></tr></table></figure>

<p>这样，我们将解码之后的token复制出来，填入dashboard认证表单中就可以进入dashboard并且获取全集群的最高权限。</p>
<h1 id="基于kubeconfig的认证"><a href="#基于kubeconfig的认证" class="headerlink" title="基于kubeconfig的认证"></a>基于kubeconfig的认证</h1><p>如何生成kubeconfig文件请参考创建<a href="https://jimmysong.io/kubernetes-handbook/guide/kubectl-user-authentication-authorization.html" target="_blank" rel="noopener">用户认证授权的kubeconfig文件</a>。</p>
<p>注意参考文章中生成的kubeconfig文件中没有token字段，如果我们要使用<code>kubeconfig</code>登录dashboard则需要手动添加该字段。</p>
<p>对于访问<code>dashboard</code>时候使用的<code>kubeconfig</code>文件如<code>brand.kubeconfig</code>必须追到<code>token</code>字段，否则认证不会通过。而使用<code>kubectl</code>命令时的用的<code>kubeconfig</code>文件则不需要包含token字段。</p>
<p>kubeconfig的认证可以让拥有该kubeconfig的用户只拥有一个或几个命名空间的操作权限，这相比与上面的token的方式更加的精确和安全。kubeconfig也可以针对<code>kubectl</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp -f brand.kubeconfig　~/.kube/config</span><br></pre></td></tr></table></figure>

<p>这样，该用户就只具有brand.kubeconfig文件所确定的命名空间的操作权限了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Andrew</p>
              <p class="site-description motion-element" itemprop="description">All In</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">67</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Andrew</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
